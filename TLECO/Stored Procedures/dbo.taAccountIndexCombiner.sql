SET QUOTED_IDENTIFIER OFF
GO
SET ANSI_NULLS ON
GO
create procedure [dbo].[taAccountIndexCombiner]   @I_intStartAcct char(15), @I_intEndAcct 	char(15), @I_intACTINDX1 	int, @I_intACTINDX2 	int, @O_iErrorState 	int = NULL  output with encryption as set transaction isolation level read uncommitted set nocount on declare @ACCOUNT_CHG 	char(255), @cStatement 	varchar(255), @budgetid	char(30), @fields		char(50), @cStatement2	varchar(255),	 @cStatement3	varchar(255),	 @cStatement4	varchar(255),	 @cStatement5	varchar(255),	 @cStatement6	varchar(255),	 @cStatement7	varchar(255),	 @cStatement8	varchar(255),	 @cStatement14	varchar(255),	 @cStatement15	varchar(255),	 @cStatement16	varchar(255),	 @cStatement17	varchar(255),	 @cStatement18	varchar(255),	 @cStatement19	varchar(255),	 @cStatement20	varchar(255),	 @DistRef	char (31), 	 @TRXSORCE 	char (13), 	 @statement	varchar(255), @tTransaction	tinyint, @tLoop		tinyint, @DBNAME		varchar(50), @DBID		char(25), @YEAR1		datetime select @O_iErrorState 	= 0, @cStatement15	= '', @cStatement18	= '', @DBNAME = '', @DBID = 0 select @DBNAME = DB_Name() select @DBID = CMPANYID from DYNAMICS..SY01500 where INTERID = @DBNAME if @@trancount = 0 begin select @tTransaction = 1 begin transaction end while ( @tLoop is NULL ) begin select @tLoop = 1 if	@I_intStartAcct	is NULL or @I_intEndAcct	is NULL or @I_intACTINDX1	is NULL or @I_intACTINDX2	is NULL  begin select @O_iErrorState = 98  break end set nocount on truncate table GL50010 if @@error <> 0 begin select @O_iErrorState = 10  break end truncate table GL50011 if @@error <> 0 begin select @O_iErrorState = 11  break end declare ta_AMCCursor insensitive CURSOR for select 'update '+ o.name +' set ACTINDX =' + rtrim(@I_intEndAcct) + ' where ACTINDX = ' + rtrim(@I_intStartAcct)   from sysobjects o, syscolumns c where	(o.id = c.id and o.type = 'U' and c.name = 'ACTINDX') and (o.name <> 'GL00100' and o.name <> 'GL00100F1' and o.name <> 'GL00100F2' and o.name <> 'GL00100F3' and o.name <> 'GL00100F4' and o.name <> 'GL00105' and o.name <> 'GL10001' and o.name <> 'GL10110' and o.name <> 'GL10111' and o.name <> 'GL00201' and o.name <> 'GL20001' and o.name <> 'GL30001' and o.name <> 'MC00200' and o.name <> 'MC00201' and o.name <> 'MC00300' and o.name <> 'XLImport' and o.name <> 'XLActInf' and o.name <> 'MC30001' and o.name <> 'DTA00300' and o.name <> 'DTA00301' and o.name <> 'SE90001' and o.name <> 'SE810000' and o.name <> 'SE000200' and o.name <> 'SE00400' and o.name <> 'SE000401' and o.name <> 'PA10704' and o.name <> 'PA10705' and o.name <> 'PA31104' and o.name <> 'FA42200' and o.name <> 'POP10390' and o.name <> 'POP30390' and o.name <> 'POP10360' and o.name <> 'POP30360' and o.name <> 'AAG00200' and o.name <> 'AAG00905' and o.name <> 'AAG02001' and o.name <> 'IF000003') order by o.name OPEN ta_AMCCursor FETCH NEXT FROM ta_AMCCursor INTO @ACCOUNT_CHG WHILE (@@FETCH_STATUS <> -1) begin exec (@ACCOUNT_CHG) if @@error <> 0 begin select @O_iErrorState = 12  break end FETCH NEXT FROM ta_AMCCursor INTO @ACCOUNT_CHG end DEALLOCATE ta_AMCCursor if @O_iErrorState <> 0 break update GL10001 set ACTINDX = @I_intEndAcct where ACTINDX = @I_intStartAcct and INTERID = @DBNAME if @@error <> 0 begin select @O_iErrorState = 166  break end update MC00200 set ACTINDX = convert(int,@I_intEndAcct) where ACTINDX = convert(int,@I_intStartAcct) and convert(int,@I_intEndAcct)  not in (select ACTINDX from MC00200) if @@error <> 0 begin select @O_iErrorState = 13  break end update MC00201 set ACTINDX = convert(int,@I_intEndAcct) where ACTINDX = convert(int,@I_intStartAcct) and rtrim(@I_intEndAcct) + CURNCYID + ltrim(str(OPENYEAR)) + ltrim(str(PERIODID)) not in (select ltrim(str(ACTINDX)) + CURNCYID + ltrim(str(OPENYEAR)) + ltrim(str(PERIODID)) from MC00201) if @@error <> 0 begin select @O_iErrorState = 14  break end update MC00300 set ACTINDX = convert(int,@I_intEndAcct) where ACTINDX = convert(int,@I_intStartAcct) and rtrim(@I_intEndAcct) + CURNCYID not in (select ltrim(str(ACTINDX)) + CURNCYID from MC00300) if @@error <> 0 begin select @O_iErrorState = 15  break end declare ta_AMCCursor insensitive CURSOR for select 'update '+ o.Tablename +' set '+ rtrim(Columnname)+' = ' + rtrim(@I_intEndAcct) + ' where '+rtrim(Columnname)+' = ' + rtrim(@I_intStartAcct) from ACColumn o order by o.Tablename open ta_AMCCursor fetch next from ta_AMCCursor into @ACCOUNT_CHG while (@@FETCH_STATUS <> -1) begin exec (@ACCOUNT_CHG) if @@error <> 0 begin select @O_iErrorState = 16  break end fetch next from ta_AMCCursor into @ACCOUNT_CHG end deallocate ta_AMCCursor if @O_iErrorState <> 0 break select BUDGETID, PERIODDT, PERIODID, sum(BUDGETAMT) as BUDGETAMT, YEAR1 into #budget from GL00201  where (ACTINDX = @I_intACTINDX1 or ACTINDX = @I_intACTINDX2)  group by BUDGETID,PERIODDT,PERIODID,YEAR1 if @@error <> 0 begin select @O_iErrorState = 18  break end delete GL00201 where ACTINDX = @I_intACTINDX2 if @@error <> 0 begin select @O_iErrorState = 19  break end select @cStatement2 = ' insert GL00201 ( BUDGETID,PERIODDT ' select @cStatement4 = ',PERIODID,BUDGETAMT,ACCATNUM,ACTINDX,YEAR1) ' select @cStatement5 = 'select b.BUDGETID, b.PERIODDT ' select @cStatement7 = ', b.PERIODID,b.BUDGETAMT,m.ACCATNUM, '+ rtrim(str(@I_intACTINDX2)) + ',b.YEAR1' select @cStatement8 = ' from #budget b, GL00100 m, GL00105 i where m.ACTINDX = ' + rtrim(str(@I_intACTINDX2))+' and i.ACTINDX = m.ACTINDX ' exec (@cStatement2+@cStatement4+@cStatement5+@cStatement7+@cStatement8) if @@error <> 0 begin select @O_iErrorState = 20  break end delete GL00201 where ACTINDX = @I_intACTINDX1 if @@error <> 0 begin select @O_iErrorState = 170  break end drop table #budget if @@error <> 0 begin select @O_iErrorState = 21  break end if exists (select * from sysobjects where id = object_id('dbo.XLImport') and sysstat & 0xf = 3) begin select USERID,BUDGETID,PERIODID, sum(BUDGETAMT) as BUDGETAMT into #budget2 from XLImport where (ACTINDX = @I_intACTINDX1 or ACTINDX = @I_intACTINDX2)  group by USERID,BUDGETID,PERIODID if @@error <> 0 begin select @O_iErrorState = 229  break end delete XLImport where ACTINDX = @I_intACTINDX1 or ACTINDX = @I_intACTINDX2	 if @@error <> 0 begin select @O_iErrorState = 210  break end select @cStatement14 = ' insert XLImport ( USERID, BUDGETID' select @cStatement15 = @cStatement15+rtrim(','+'ACTNUMBR_'+ltrim(str(s.SGMTNUMB))) from DYNAMICS..SY00302 s select @cStatement16 = ',PERIODID,BUDGETAMT,ACCATNUM,ACTINDX) ' select @cStatement17 = 'select USERID b,BUDGETID b ' select @cStatement18 = @cStatement18+rtrim(','+'i.ACTNUMBR_'+ltrim(str(s.SGMTNUMB))) from DYNAMICS..SY00302 s select @cStatement19 = ', b.PERIODID, b.BUDGETAMT,m.ACCATNUM, '+ rtrim(str(@I_intACTINDX2)) select @cStatement20 = ' from #budget2 b, GL00100 m, GL00105 i where m.ACTINDX = ' + rtrim(str(@I_intACTINDX2))+' and i.ACTINDX = m.ACTINDX ' exec (@cStatement14+@cStatement15+@cStatement16+@cStatement17+@cStatement18+@cStatement19+@cStatement20) if @@error <> 0 begin select @O_iErrorState = 310  break end drop table #budget2 if @@error <> 0 begin select @O_iErrorState = 311  break end end select ACTINDX,sum(PRCNTAGE) as PRCNTAGE,DSTINDX into #fixed from GL00103  where (DSTINDX = @I_intACTINDX1 or DSTINDX = @I_intACTINDX2)  group by ACTINDX, DSTINDX if @@error <> 0 begin select @O_iErrorState = 26  break end delete GL00103 where DSTINDX = @I_intACTINDX1 or DSTINDX = @I_intACTINDX2 if @@error <> 0 begin select @O_iErrorState = 27  break end insert into GL00103 (ACTINDX,PRCNTAGE,DSTINDX ) select ACTINDX, sum(PRCNTAGE), @I_intACTINDX2 from #fixed a where a.DSTINDX = @I_intACTINDX1 or a.DSTINDX = @I_intACTINDX2 group by ACTINDX if @@error <> 0 begin select @O_iErrorState = 28  break end drop table #fixed if @@error <> 0 begin select @O_iErrorState = 29  break end update GL00104 set DSTINDX = @I_intACTINDX2  where DSTINDX = @I_intACTINDX1 and cast(ACTINDX as varchar)+cast(BDNINDX as varchar) not in (select cast(ACTINDX as varchar)+cast(BDNINDX as varchar) from GL00104 where DSTINDX = @I_intACTINDX2) if @@error <> 0 begin select @O_iErrorState = 30  return end delete GL00104 where DSTINDX = @I_intACTINDX1 if @@error <> 0 begin select @O_iErrorState = 31  return end update GL00104 set BDNINDX = @I_intACTINDX2  where BDNINDX = @I_intACTINDX1 and cast(ACTINDX as varchar)+cast(DSTINDX as varchar) not in (select cast(ACTINDX as varchar)+cast(DSTINDX as varchar) from GL00104 where BDNINDX = @I_intACTINDX2) if @@error <> 0 begin select @O_iErrorState = 32  return end delete GL00104 where BDNINDX = @I_intACTINDX1 if @@error <> 0 begin select @O_iErrorState = 33  return end declare ta_AMCCursor insensitive CURSOR for select 'update '+ o.name +' set BDNINDX =' + rtrim(@I_intEndAcct) + ' where BDNINDX = ' + rtrim(@I_intStartAcct)   from sysobjects o, syscolumns c where	(o.id = c.id and o.type = 'U' and c.name = 'BDNINDX') and (o.name <> 'GL00104') order by o.name OPEN ta_AMCCursor FETCH NEXT FROM ta_AMCCursor INTO @ACCOUNT_CHG WHILE (@@FETCH_STATUS <> -1) begin exec (@ACCOUNT_CHG) if @@error <> 0 begin select @O_iErrorState = 34  break end FETCH NEXT FROM ta_AMCCursor INTO @ACCOUNT_CHG end DEALLOCATE ta_AMCCursor if @O_iErrorState <> 0 break declare ta_AMCCursor insensitive CURSOR for select 'update '+ o.name +' set DSTINDX =' + rtrim(@I_intEndAcct) + ' where DSTINDX = ' + rtrim(@I_intStartAcct)   from sysobjects o, syscolumns c where	(o.id = c.id and o.type = 'U' and c.name = 'DSTINDX') and (o.name <> 'GL00103'  and o.name <> 'GL00104' and o.name <> 'PM10100' and o.name <> 'PM80600') order by o.name OPEN ta_AMCCursor FETCH NEXT FROM ta_AMCCursor INTO @ACCOUNT_CHG WHILE (@@FETCH_STATUS <> -1) begin exec (@ACCOUNT_CHG) if @@error <> 0 begin select @O_iErrorState = 35  break end FETCH NEXT FROM ta_AMCCursor INTO @ACCOUNT_CHG end DEALLOCATE ta_AMCCursor if @O_iErrorState <> 0 break update PM10100 set DSTINDX = @I_intEndAcct where DSTINDX = @I_intStartAcct and INTERID = @DBNAME if @@error <> 0 begin select @O_iErrorState = 167  break end update PM80600 set DSTINDX = @I_intEndAcct where DSTINDX = @I_intStartAcct and INTERID = @DBNAME if @@error <> 0 begin select @O_iErrorState = 168  break end update b set b.FUNCTAMT = a.FUNCTAMT + b.FUNCTAMT, b.ORIGAMT = a.ORIGAMT + b.ORIGAMT from MC30001 a, MC30001 b where a.CURNCYID = b.CURNCYID and a.PERIODID = b.PERIODID and a.HSTYEAR = b.HSTYEAR and a.ACTINDX = @I_intACTINDX1 and b.ACTINDX = @I_intACTINDX2 if @@error <> 0 begin select @O_iErrorState = 36  break end update MC30001 set ACTINDX = @I_intACTINDX2 where ACTINDX = @I_intACTINDX1 and CURNCYID+cast(PERIODID as varchar)+cast(HSTYEAR as varchar) not in(select CURNCYID+cast(PERIODID as varchar)+cast(HSTYEAR as varchar) from MC30001 where ACTINDX = @I_intACTINDX2) if @@error <> 0 begin select @O_iErrorState = 37  break end delete MC30001 where ACTINDX = @I_intACTINDX1 if @@error <> 0 begin select @O_iErrorState = 38  break end if exists(select top 1 1 from sysobjects where name = 'GL20001' and type = 'U') begin update b set b.CRDTAMNT = a.CRDTAMNT + b.CRDTAMNT, b.DEBITAMT = a.DEBITAMT + b.DEBITAMT, b.ORCRDAMT = a.ORCRDAMT + b.ORCRDAMT, b.ORDBTAMT = a.ORDBTAMT + b.ORDBTAMT, b.TranslationCreditAmount = a.TranslationCreditAmount + b.TranslationCreditAmount, b.TranslationDebitAmount = a.TranslationDebitAmount + b.TranslationDebitAmount from GL20001 a, GL20001 b where a.TranslationCurrencyID = b.TranslationCurrencyID and a.OPENYEAR = b.OPENYEAR and a.Ledger_ID = b.Ledger_ID and a.CURNCYID = b.CURNCYID and a.JRNENTRY = b.JRNENTRY and a.TRXDATE = b.TRXDATE and a.SEQNUMBR = b.SEQNUMBR and a.ACTINDX = @I_intACTINDX1 and b.ACTINDX = @I_intACTINDX2 if @@error <> 0 begin select @O_iErrorState = 211  break end update GL20001 set ACTINDX = @I_intACTINDX2 where ACTINDX = @I_intACTINDX1 and TranslationCurrencyID+cast(OPENYEAR as varchar)+cast(Ledger_ID as varchar)+CURNCYID+cast(JRNENTRY as varchar)+ cast(TRXDATE as varchar)+cast(SEQNUMBR as varchar) not in(select TranslationCurrencyID+cast(OPENYEAR as varchar)+cast(Ledger_ID as varchar)+CURNCYID+cast(JRNENTRY as varchar)+ cast(TRXDATE as varchar)+cast(SEQNUMBR as varchar) from GL20001 where ACTINDX = @I_intACTINDX2) if @@error <> 0 begin select @O_iErrorState = 212  break end update b set b.CRDTAMNT = a.CRDTAMNT + b.CRDTAMNT, b.DEBITAMT = a.DEBITAMT + b.DEBITAMT, b.ORCRDAMT = a.ORCRDAMT + b.ORCRDAMT, b.ORDBTAMT = a.ORDBTAMT + b.ORDBTAMT, b.TranslationCreditAmount = a.TranslationCreditAmount + b.TranslationCreditAmount, b.TranslationDebitAmount = a.TranslationDebitAmount + b.TranslationDebitAmount from GL30001 a, GL30001 b where a.TranslationCurrencyID = b.TranslationCurrencyID and a.HSTYEAR = b.HSTYEAR and a.Ledger_ID = b.Ledger_ID and a.CURNCYID = b.CURNCYID and a.JRNENTRY = b.JRNENTRY and a.TRXDATE = b.TRXDATE and a.SEQNUMBR = b.SEQNUMBR and a.ACTINDX = @I_intACTINDX1 and b.ACTINDX = @I_intACTINDX2 if @@error <> 0 begin select @O_iErrorState = 213  break end update GL30001 set ACTINDX = @I_intACTINDX2 where ACTINDX = @I_intACTINDX1 and TranslationCurrencyID+cast(HSTYEAR as varchar)+cast(Ledger_ID as varchar)+CURNCYID+cast(JRNENTRY as varchar)+ cast(TRXDATE as varchar)+cast(SEQNUMBR as varchar) not in(select TranslationCurrencyID+cast(HSTYEAR as varchar)+cast(Ledger_ID as varchar)+CURNCYID+cast(JRNENTRY as varchar)+ cast(TRXDATE as varchar)+cast(SEQNUMBR as varchar) from GL30001 where ACTINDX = @I_intACTINDX2) if @@error <> 0 begin select @O_iErrorState = 214  break end end update DTA00300 set ACTINDX = @I_intEndAcct where ACTINDX = @I_intStartAcct	and GROUPID not in (select GROUPID from DTA00300 (nolock) where ACTINDX = @I_intEndAcct) if @@error <> 0 begin select @O_iErrorState = 47  break end update DTA00301 set ACTINDX = @I_intEndAcct where ACTINDX = @I_intStartAcct	and GROUPID not in (select GROUPID from DTA00301 (nolock) where ACTINDX = @I_intEndAcct) if @@error <> 0 begin select @O_iErrorState = 48  break end if exists (select * from sysobjects where id = object_id('dbo.SE90001') and sysstat & 0xf = 3) begin update SE90001 set ACTINDX = @I_intEndAcct  where ACTINDX = @I_intStartAcct and SEOPTNME not in (select SEOPTNME from SE90001 (nolock) where ACTINDX = @I_intEndAcct) if @@error <> 0 begin select @O_iErrorState = 50  return end end if exists (select * from sysobjects where id = object_id('dbo.SE810000') and sysstat & 0xf = 3) begin update SE810000 set ACTINDX = @I_intEndAcct  where ACTINDX = @I_intStartAcct and USERID not in (select USERID from SE810000 (nolock) where ACTINDX = @I_intEndAcct) if @@error <> 0 begin select @O_iErrorState = 51  return end end if exists (select * from sysobjects where id = object_id('dbo.SE000200') and sysstat & 0xf = 3) begin update SE000200 set ACTINDX = @I_intEndAcct  where ACTINDX = @I_intStartAcct and cast(SGMTNUMB as varchar)+SGMNTID not in (select cast(SGMTNUMB as varchar)+SGMNTID from SE000200 (nolock) where ACTINDX = @I_intEndAcct) if @@error <> 0 begin select @O_iErrorState = 52  return end end if exists (select * from sysobjects where id = object_id('dbo.PA10704') and sysstat & 0xf = 3) begin update b set b.ORPURTAX = a.ORPURTAX + b.ORPURTAX, b.PAOTDTP = a.PAOTDTP + b.PAOTDTP, b.PAOTDTT = a.PAOTDTT + b.PAOTDTT, b.PCTAXAMT = a.PCTAXAMT + b.PCTAXAMT, b.TXDTTPUR = a.TXDTTPUR + b.TXDTTPUR, b.TDTTXPUR = a.TDTTXPUR + b.TDTTXPUR from PA10704 a, PA10704 b where a.ACTINDX = @I_intStartAcct and b.ACTINDX = @I_intEndAcct and a.PAVIDN = b.PAVIDN and a.RCPTLNNM = b.RCPTLNNM and a.TAXDTLID = b.TAXDTLID if @@error <> 0 begin select @O_iErrorState = 207  return end delete a from PA10704 a, PA10704 b where a.ACTINDX = @I_intStartAcct and b.ACTINDX = @I_intEndAcct and a.PAVIDN = b.PAVIDN and a.RCPTLNNM = b.RCPTLNNM and a.TAXDTLID = b.TAXDTLID if @@error <> 0 begin select @O_iErrorState = 208  return end update PA10704 set ACTINDX = @I_intEndAcct where ACTINDX = @I_intStartAcct if @@error <> 0 begin select @O_iErrorState = 209  return end end if exists (select * from sysobjects where id = object_id('dbo.PA10705') and sysstat & 0xf = 3) begin update PA10705 set ACTINDX = @I_intEndAcct where ACTINDX = @I_intStartAcct and PAVIDN+cast(DISTTYPE as varchar)+cast(XCHGRATE as varchar) not in (select PAVIDN+cast(DISTTYPE as varchar)+cast(XCHGRATE as varchar) from PA10705 (nolock) where ACTINDX = @I_intEndAcct) if @@error <> 0 begin select @O_iErrorState = 53  break end delete PA10705 where ACTINDX = @I_intStartAcct if @@error <> 0 begin select @O_iErrorState = 55  break end end if exists (select * from sysobjects where id = object_id('dbo.PA10602') and sysstat & 0xf = 3) begin update PA10602 set ACTINDX = @I_intEndAcct where ACTINDX = @I_intStartAcct and cast(POTYPE as varchar)+PApurordnum+cast(ORD as varchar)+TAXDTLID not in (select cast(POTYPE as varchar)+PApurordnum+cast(ORD as varchar)+TAXDTLID from PA10602 (nolock) where ACTINDX = @I_intEndAcct) if @@error <> 0 begin select @O_iErrorState = 161  break end select * into #PA10602 from PA10602 (nolock) where ACTINDX = @I_intStartAcct and cast(POTYPE as varchar)+PApurordnum+cast(ORD as varchar)+TAXDTLID in (select cast(POTYPE as varchar)+PApurordnum+cast(ORD as varchar)+TAXDTLID from PA10602 (nolock) where ACTINDX = @I_intEndAcct) if @@error <> 0 begin select @O_iErrorState = 162  break end delete PA10602 where ACTINDX = @I_intStartAcct if @@error <> 0 begin select @O_iErrorState = 163  break end update a set 	a.PCTAXAMT = a.PCTAXAMT + b.PCTAXAMT, a.TXDTTPUR = a.TXDTTPUR + b.TXDTTPUR, a.TDTTXPUR = a.TDTTXPUR + b.TDTTXPUR, a.ORPURTAX = a.ORPURTAX + b.ORPURTAX, a.ORFRTAMT = a.ORFRTAMT + b.ORFRTAMT, a.ORMISCAMT = a.ORMISCAMT + b.ORMISCAMT, a.PAOTDTP = a.PAOTDTP + b.PAOTDTP, a.PAOTDTT = a.PAOTDTT + b.PAOTDTT from PA10602 a, #PA10602 b where 	a.POTYPE = b.POTYPE and a.PApurordnum = b.PApurordnum and a.ORD = b.ORD and  a.TAXDTLID = b.TAXDTLID and a.ACTINDX = @I_intEndAcct if @@error <> 0 begin select @O_iErrorState = 164  break end drop table #PA10602 if @@error <> 0 begin select @O_iErrorState = 165  break end end update GL00100F1 set ACTINDX = @I_intEndAcct where ACTINDX = @I_intStartAcct	and RELID not in (select RELID from GL00100F1 (nolock) where ACTINDX = @I_intEndAcct) if @@error <> 0 begin select @O_iErrorState = 67  break end update GL00100F2 set ACTINDX = @I_intEndAcct where ACTINDX = @I_intStartAcct	and RELID not in (select RELID from GL00100F2 (nolock) where ACTINDX = @I_intEndAcct) if @@error <> 0 begin select @O_iErrorState = 68  break end update GL00100F3 set ACTINDX = @I_intEndAcct where ACTINDX = @I_intStartAcct	and RELID not in (select RELID from GL00100F3 (nolock) where ACTINDX = @I_intEndAcct) if @@error <> 0 begin select @O_iErrorState = 69  break end update GL00100F4 set ACTINDX = @I_intEndAcct where ACTINDX = @I_intStartAcct	and RELID not in (select RELID from GL00100F4 (nolock) where ACTINDX = @I_intEndAcct) if @@error <> 0 begin select @O_iErrorState = 70  break end if exists (select * from sysobjects where id = object_id('dbo.FA42200') and sysstat & 0xf = 3) begin update FA42200 set ACTINDX = @I_intEndAcct where ACTINDX = @I_intStartAcct	and not exists (select ACTINDX from FA42200 where ACTINDX = @I_intEndAcct) if @@error <> 0 begin select @O_iErrorState = 158  return end end update b set b.CRDTAMNT = a.CRDTAMNT + b.CRDTAMNT, b.ORCRDAMT = a.ORCRDAMT + b.ORCRDAMT, b.DEBITAMT = a.DEBITAMT + b.DEBITAMT, b.ORDBTAMT = a.ORDBTAMT + b.ORDBTAMT from POP10390 a, POP10390 b where a.ACTINDX = @I_intStartAcct and b.ACTINDX = @I_intEndAcct and a.POPRCTNM = b.POPRCTNM and a.DISTTYPE = b.DISTTYPE and a.XCHGRATE = b.XCHGRATE if @@error <> 0 begin select @O_iErrorState = 58  return end delete a from POP10390 a, POP10390 b where  a.ACTINDX = @I_intStartAcct and b.ACTINDX = @I_intEndAcct and a.POPRCTNM = b.POPRCTNM and a.DISTTYPE = b.DISTTYPE and a.XCHGRATE = b.XCHGRATE if @@error <> 0 begin select @O_iErrorState = 59  return end update POP10390 set ACTINDX = @I_intEndAcct where ACTINDX = @I_intStartAcct if @@error <> 0 begin select @O_iErrorState = 60  return end update b set b.CRDTAMNT = a.CRDTAMNT + b.CRDTAMNT, b.ORCRDAMT = a.ORCRDAMT + b.ORCRDAMT, b.DEBITAMT = a.DEBITAMT + b.DEBITAMT, b.ORDBTAMT = a.ORDBTAMT + b.ORDBTAMT from POP30390 a, POP30390 b where a.ACTINDX = @I_intStartAcct and b.ACTINDX = @I_intEndAcct and a.POPRCTNM = b.POPRCTNM and a.DISTTYPE = b.DISTTYPE and a.XCHGRATE = b.XCHGRATE if @@error <> 0 begin select @O_iErrorState = 61  return end delete a from POP30390 a, POP30390 b where  a.ACTINDX = @I_intStartAcct and b.ACTINDX = @I_intEndAcct and a.POPRCTNM = b.POPRCTNM and a.DISTTYPE = b.DISTTYPE and a.XCHGRATE = b.XCHGRATE if @@error <> 0 begin select @O_iErrorState = 62  return end update POP30390 set ACTINDX = @I_intEndAcct where ACTINDX = @I_intStartAcct if @@error <> 0 begin select @O_iErrorState = 63  return end update b set  b.TAXAMNT = a.TAXAMNT + b.TAXAMNT, b.ORTAXAMT = a.ORTAXAMT + b.ORTAXAMT, b.TAXPURCH = a.TAXPURCH + b.TAXPURCH, b.ORGTXPCH = a.ORGTXPCH + b.ORGTXPCH, b.TOTPURCH = a.TOTPURCH + b.TOTPURCH, b.ORTOTPUR = a.ORTOTPUR + b.ORTOTPUR, b.FRTTXAMT = a.FRTTXAMT + b.FRTTXAMT, b.ORFRTTAX = a.ORFRTTAX + b.ORFRTTAX, b.MSCTXAMT = a.MSCTXAMT + b.MSCTXAMT, b.ORMSCTAX = a.ORMSCTAX + b.ORMSCTAX, b.TXDTOTTX = a.TXDTOTTX + b.TXDTOTTX, b.OTTAXPON = a.OTTAXPON + b.OTTAXPON from POP10360 a, POP10360 b where a.ACTINDX = @I_intStartAcct and b.ACTINDX = @I_intEndAcct and a.POPRCTNM = b.POPRCTNM and a.RCPTLNNM = b.RCPTLNNM and a.TAXDTLID = b.TAXDTLID if @@error <> 0 begin select @O_iErrorState = 201  return end delete a from POP10360 a, POP10360 b where a.ACTINDX = @I_intStartAcct and b.ACTINDX = @I_intEndAcct and a.POPRCTNM = b.POPRCTNM and a.RCPTLNNM = b.RCPTLNNM and a.TAXDTLID = b.TAXDTLID if @@error <> 0 begin select @O_iErrorState = 202  return end update POP10360 set ACTINDX = @I_intEndAcct where ACTINDX = @I_intStartAcct if @@error <> 0 begin select @O_iErrorState = 203  return end update b set b.TAXAMNT = a.TAXAMNT + b.TAXAMNT, b.ORTAXAMT = a.ORTAXAMT + b.ORTAXAMT, b.TAXPURCH = a.TAXPURCH + b.TAXPURCH, b.ORGTXPCH = a.ORGTXPCH + b.ORGTXPCH, b.TOTPURCH = a.TOTPURCH + b.TOTPURCH, b.ORTOTPUR = a.ORTOTPUR + b.ORTOTPUR, b.FRTTXAMT = a.FRTTXAMT + b.FRTTXAMT, b.ORFRTTAX = a.ORFRTTAX + b.ORFRTTAX, b.MSCTXAMT = a.MSCTXAMT + b.MSCTXAMT, b.ORMSCTAX = a.ORMSCTAX + b.ORMSCTAX, b.TXDTOTTX = a.TXDTOTTX + b.TXDTOTTX, b.OTTAXPON = a.OTTAXPON + b.OTTAXPON from POP30360 a, POP30360 b where a.ACTINDX = @I_intStartAcct and b.ACTINDX = @I_intEndAcct and a.POPRCTNM = b.POPRCTNM and a.RCPTLNNM = b.RCPTLNNM and a.TAXDTLID = b.TAXDTLID if @@error <> 0 begin select @O_iErrorState = 204  return end delete a from POP30360 a, POP30360 b where a.ACTINDX = @I_intStartAcct and b.ACTINDX = @I_intEndAcct and a.POPRCTNM = b.POPRCTNM and a.RCPTLNNM = b.RCPTLNNM and a.TAXDTLID = b.TAXDTLID if @@error <> 0 begin select @O_iErrorState = 205  return end update POP30360 set ACTINDX = @I_intEndAcct where ACTINDX = @I_intStartAcct if @@error <> 0 begin select @O_iErrorState = 206  return end declare ta_AMCCursor insensitive CURSOR for select 'update DYNAMICS..'+o.name+' set AccountIndex = ' + rtrim(@I_intEndAcct) +  ' where AccountIndex = ' + rtrim(@I_intStartAcct) + ' and CompanyID = ' + str(@DBID) from DYNAMICS..sysobjects o, DYNAMICS..syscolumns c where	o.id = c.id and o.type = 'U' and c.name = 'AccountIndex' and (o.name = 'ReqItemList' or   o.name = 'ReqItemListHist') order by o.name set nocount on OPEN ta_AMCCursor FETCH NEXT FROM ta_AMCCursor INTO @ACCOUNT_CHG WHILE (@@FETCH_STATUS <> -1) begin exec (@ACCOUNT_CHG) if @@error <> 0  begin select @O_iErrorState = 169  break end FETCH NEXT FROM ta_AMCCursor INTO @ACCOUNT_CHG end DEALLOCATE ta_AMCCursor if @O_iErrorState <> 0 break if (exists(select * from sysobjects where id = object_id('dbo.AAG02001') and sysstat & 0xf = 3)) begin update AAG02001 set ACTINDX = @I_intEndAcct where ACTINDX = @I_intStartAcct and cast(aaTrxDimID as varchar)+cast(aaTrxDimCodeID as varchar) not in (select cast(aaTrxDimID as varchar)+cast(aaTrxDimCodeID as varchar) from AAG02001 (nolock) where ACTINDX = @I_intEndAcct) if @@error <> 0 begin select @O_iErrorState = 500  break end end if (exists(select * from sysobjects where id = object_id('dbo.AAG00200') and sysstat & 0xf = 3)) begin update AAG00200 set ACTINDX = @I_intEndAcct where ACTINDX = @I_intStartAcct and not exists (select ACTINDX from AAG00200 where ACTINDX = @I_intEndAcct) if @@error <> 0 begin select @O_iErrorState = 501  break end end update b set b.TRXAMNT = a.TRXAMNT + b.TRXAMNT, b.ORIGAMT = a.ORIGAMT + b.ORIGAMT from IF000003 a, IF000003 b where a.ACTINDX = @I_intStartAcct and b.ACTINDX = @I_intEndAcct and a.USERID = b.USERID and a.BACHNUMB = b.BACHNUMB and a.BCHSOURC = b.BCHSOURC and a.JRNENTRY = b.JRNENTRY and a.ORCTRNUM = b.ORCTRNUM if @@error <> 0 begin select @O_iErrorState = 502  break end if (exists(select * from sysobjects where id = object_id('dbo.AAG00905') and sysstat & 0xf = 3)) begin INSERT INTO AAG00905  SELECT aaBudgetID, aaCodeSequence, -1, PERIODDT, aaFiscalPeriod, aaActualPriliminary,  aaRange, SUM(Balance), MAX(YEAR1) FROM AAG00905 WHERE ACTINDX IN (@I_intStartAcct, @I_intEndAcct) GROUP BY aaBudgetID, aaCodeSequence, PERIODDT, aaFiscalPeriod, aaActualPriliminary, aaRange DELETE AAG00905 WHERE ACTINDX IN (@I_intStartAcct, @I_intEndAcct) UPDATE AAG00905 SET ACTINDX=@I_intEndAcct WHERE ACTINDX=-1 end if (exists(select * from sysobjects where id = object_id('dbo.AAG00200') and sysstat & 0xf = 3)) begin update AAG00200 set ACTINDX = @I_intEndAcct where ACTINDX = @I_intStartAcct and not exists (select ACTINDX from AAG00200 where ACTINDX = @I_intEndAcct) if @@error <> 0 begin select @O_iErrorState = 501  break end end update b set b.TRXAMNT = a.TRXAMNT + b.TRXAMNT, b.ORIGAMT = a.ORIGAMT + b.ORIGAMT from IF000003 a, IF000003 b where a.ACTINDX = @I_intStartAcct and b.ACTINDX = @I_intEndAcct and a.USERID = b.USERID and a.BACHNUMB = b.BACHNUMB and a.BCHSOURC = b.BCHSOURC and a.JRNENTRY = b.JRNENTRY and a.ORCTRNUM = b.ORCTRNUM if @@error <> 0 begin select @O_iErrorState = 502  break end if (exists(select * from sysobjects where id = object_id('dbo.CPY30130') and sysstat & 0xf = 3)) begin exec taAccountIndexCombinerCPY @I_intStartAcct, @I_intEndAcct, @I_intACTINDX1, @I_intACTINDX2, @O_iErrorState output if (@O_iErrorState <> 0) begin break end end declare ta_AMCCursor insensitive CURSOR for select 'delete '+ o.name +' where ACTINDX =' + rtrim(@I_intStartAcct)  from sysobjects o, syscolumns c where	(o.id = c.id and o.type = 'U' and c.name = 'ACTINDX') and (o.name = 'GL00100' or o.name = 'GL00100F1' or o.name = 'GL00100F2' or o.name = 'GL00100F3' or o.name = 'GL00100F4' or o.name = 'GL00105' or o.name = 'GL10110' or o.name = 'GL10111' or o.name = 'GL20001' or o.name = 'GL30001' or o.name = 'MC00200' or o.name = 'MC00201' or o.name = 'MC00300' or o.name = 'XLImport' or o.name = 'XLActInf' or o.name = 'DTA00300' or o.name = 'DTA00301' or o.name = 'SE90001'	or o.name = 'SE810000' or o.name = 'SE000200' or o.name = 'SE00400'	or o.name = 'SE000401' or o.name = 'FA42200'	or o.name = 'AAG00200' or o.name = 'AAG02001' or o.name = 'IF000003') order by o.name OPEN ta_AMCCursor FETCH NEXT FROM ta_AMCCursor INTO @ACCOUNT_CHG WHILE (@@FETCH_STATUS <> -1) begin exec (@ACCOUNT_CHG) if @@error <> 0 begin select @O_iErrorState = 71  break end FETCH NEXT FROM ta_AMCCursor INTO @ACCOUNT_CHG end DEALLOCATE ta_AMCCursor if @O_iErrorState <> 0 break if exists (select * from sysobjects where id = object_id('dbo.frl_acct_code') and sysstat & 0xf = 3) begin delete frl_acct_code from frl_acct_code where acct_id not in (select ACTINDX from GL00100) if @@error <> 0 begin select @O_iErrorState = 72  return end end end if @O_iErrorState <> 0 begin if @tTransaction = 1 rollback transaction end else if @tTransaction = 1 begin commit transaction end return  
GO
GRANT EXECUTE ON  [dbo].[taAccountIndexCombiner] TO [DYNGRP]
GO
