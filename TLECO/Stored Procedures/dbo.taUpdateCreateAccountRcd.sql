SET QUOTED_IDENTIFIER OFF
GO
SET ANSI_NULLS ON
GO
 create procedure [dbo].[taUpdateCreateAccountRcd]  @I_vACTNUMST char(75) = '',   @I_vACTALIAS char(21) = '',   @I_vACCTTYPE smallint = 1,   @I_vACTDESCR char(50) = '',   @I_vPSTNGTYP smallint = 0,    @I_vCATEGORY char(50) = '',   @I_vACTIVE tinyint = 1,    @I_vTPCLBLNC smallint = 0,   @I_vDECPLACS smallint = 0,   @I_vFXDORVAR smallint = 0,   @I_vBALFRCLC smallint = 0,   @I_vUSERDEF1 char(20) = '',   @I_vUSERDEF2 char(20) = '',   @I_vPostSlsIn smallint = 1,   @I_vPostIvIn smallint = 1,   @I_vPostPurchIn smallint = 1,   @I_vPostPRIn smallint = 1,   @I_vACCTENTR tinyint = 1,   @I_vUSRDEFS1 char(30) = '',   @I_vUSRDEFS2 char(30) = '',   @I_vUpdateIfExists tinyint = 1,   @I_vNOTETEXT varchar(8000) = '',  @I_vDSPLKUPSSALES tinyint = 1,   @I_vDSPLKUPSIV tinyint = 1,   @I_vDSPLKUPSPURCH tinyint = 1,   @I_vDSPLKUPSPR tinyint = 1,   @I_vRequesterTrx smallint = 0,   @I_vUSRDEFND1 char(50) = '',       @I_vUSRDEFND2 char(50) = '',       @I_vUSRDEFND3 char(50) = '',       @I_vUSRDEFND4 varchar(8000) = '',  @I_vUSRDEFND5 varchar(8000) = '',  @O_iErrorState int output, @oErrString varchar(255) output  with encryption as  set transaction isolation level read uncommitted set nocount on  declare   @NOTEINDX numeric(19,5),  @CMPANYID smallint,  @iGetNextNoteIdxErrState int,  @ACTINDX int,     @ADJINFL tinyint,    @INFLAREV int,     @INFLAEQU int,     @CNVRMTHD smallint,    @HSTRCLRT numeric(19,5),   @ACCATNUM int,     @MAINSEGMENT int,    @NumberofSegments int,    @NumAcctSegs int,    @Seperator char(1),    @Segment1 varchar(75),    @Segment2 varchar(75),    @Segment3 varchar(75),    @Segment4 varchar(75),    @Segment5 varchar(75),    @Segment6 varchar(75),    @Segment7 varchar(75),    @Segment8 varchar(75),    @Segment9 varchar(75),    @Segment10 varchar(75),    @Segment11 varchar(800),   @Position1 int,     @Position2 int,     @FullAcct varchar(75),    @MXSEG int,     @ACCTTYPE smallint,    @ACCOUNTINDEX int,    @cStatement varchar(4000),  @cStatement1 varchar(4000),  @cStatement2 varchar(4000),  @cStatement3 varchar(4000),  @cStatement4 varchar(4000),  @cStatement5 varchar(4000),  @cStatement6 varchar(4000),  @cStatement6a varchar(4000),  @cStatement6b varchar(4000),  @cStatement6c varchar(4000),  @cStatement6d varchar(4000),  @cStatement7 varchar(4000),  @cStatement7a varchar(4000),  @cStatement7b varchar(4000),  @cStatement7c varchar(4000),  @cStatement9 varchar(4000),  @cStatement10 varchar(4000),  @cStatement11 varchar(4000),  @cStatement12 varchar(4000),  @cStatement13 varchar(4000),  @cStatement14 varchar(4000),  @cStatement15 varchar(4000),  @cStatement16 varchar(4000),  @cStatement17 varchar(4000),  @cStatement18 varchar(4000),  @cStatement19 varchar(4000),  @cStatement20 varchar(4000),  @cStatement21 varchar(4000),  @cStatement22 varchar(4000),  @cStatement23 varchar(4000),  @cStatement24 varchar(4000),  @cStatement25 varchar(4000),  @cStatement26 varchar(4000),  @cStatement27 varchar(4000),  @cStatement28 varchar(4000),  @cStatement29 varchar(4000),  @cStatement30 varchar(4000),  @cStatement31 varchar(4000),  @cStatement32 varchar(4000),  @cStatement33 varchar(4000),  @cStatement34 varchar(4000),  @cStatement35 varchar(4000),  @cStatement36 varchar(4000),  @cStatement37 varchar(4000),  @cStatement38 varchar(4000),  @cStatement39 varchar(4000),  @cStatement40 varchar(4000),  @cStatement41 varchar(4000),  @cStatement42 varchar(4000),  @cStatement43 varchar(4000),  @cStatement44 varchar(4000),  @cStatement45 varchar(4000),  @cStatement46 varchar(4000),  @cStatement47 varchar(4000),  @cStatement48 varchar(4000),  @cStatement49 varchar(4000),  @cStatement50 varchar(4000),  @cStatement51 varchar(4000),  @cStatement52 varchar(4000),  @cStatement53 varchar(4000),  @cStatement54 varchar(4000),  @cStatement55 varchar(4000),  @cStatement56 varchar(4000),  @cStatement57 varchar(4000),  @cStatement58 varchar(4000),  @ACTDESCR varchar(150),  @USERDEF1 varchar(150),  @USERDEF2 varchar(150),  @USRDEFS1 varchar(150),  @USRDEFS2 varchar(150),  @iStatus int,  @noteindex numeric(19,5),  @iCustomState int,  @iCustomErrString varchar(255),  @O_oErrorState int,  @iError int,  @I_vMETHOD int,  @SUMLOOKUPS tinyint,  @LOOKUPS binary(4),  @loopcounter int,  @DSCRIPTN char(50),  @lSegDescMaxLen int,  @lSegDescDefaultLen int,  @lExtraChars int,  @lActualSegLen int,  @lCalcSegLen int  select @O_iErrorState = 0,  @iStatus = 0,  @NOTEINDX=0,  @CMPANYID=0,  @iGetNextNoteIdxErrState=0,  @ACTINDX = 0,      @ADJINFL = 0,      @INFLAREV = 0,      @INFLAEQU = 0,      @CNVRMTHD = 1,      @HSTRCLRT = 0,      @ACCATNUM = 0,      @MAINSEGMENT = 0,     @Segment1 = '',      @Segment2 = '',      @Segment3 = '',      @Segment4 = '',      @Segment5 = '',      @Segment6= '',      @Segment7 = '',      @Segment8 = '',      @Segment9 = '',      @Segment10 = '',     @Segment11 = '',     @FullAcct = '',      @NumAcctSegs = 0,     @NumberofSegments = 0,     @Seperator = '',     @Position1 = 0,      @Position2 = 0,      @MXSEG = 0,      @ACCTTYPE = 0,      @ACCOUNTINDEX = 0,     @cStatement='',  @cStatement1='',  @cStatement2='',  @cStatement3='',  @cStatement4='',  @cStatement5='',  @cStatement6='',  @cStatement6a='',  @cStatement6b='',  @cStatement6c='',  @cStatement6d='',  @cStatement7='',  @cStatement7a='',  @cStatement7b='',  @cStatement7c='',  @cStatement9='',  @cStatement10='',  @cStatement11='',  @cStatement12='',  @cStatement13='',  @cStatement14='',  @cStatement15='',  @cStatement16='',  @cStatement17='',  @cStatement18='',  @cStatement19='',  @cStatement20='',  @cStatement21='',  @cStatement22='',  @cStatement23='',  @cStatement24='',  @cStatement25='',  @cStatement26='',  @cStatement27='',  @cStatement28='',  @cStatement29='',  @cStatement30='',  @cStatement31='',  @cStatement32='',  @cStatement33='',  @cStatement34='',  @cStatement35='',  @cStatement36='',  @cStatement37='',  @cStatement38='',  @cStatement39='',  @cStatement40='',  @cStatement41='',  @cStatement42='',  @cStatement43='',  @cStatement44='',  @cStatement45='',  @cStatement46='',  @cStatement47='',  @cStatement48='',  @cStatement49='',  @cStatement50='',  @cStatement51='',  @cStatement52='',  @cStatement53='',  @cStatement54='',  @cStatement55='',  @cStatement56='',  @cStatement57='',  @cStatement58='',  @ACTDESCR='',  @noteindex=0,  @USERDEF1='',  @USERDEF2='',  @USRDEFS1='',  @USRDEFS2='',  @I_vMETHOD = 1,  @iCustomState = 0,  @iCustomErrString = '',  @O_oErrorState = 0,  @iError = 0,  @SUMLOOKUPS = 0,  @loopcounter = 0,  @DSCRIPTN = '',  @lSegDescMaxLen = 0,  @lSegDescDefaultLen = 0,  @lExtraChars = 0,  @lActualSegLen = 0,  @lCalcSegLen = 0  if (@oErrString is NULL) begin  select @oErrString = '' end  exec @iStatus = taUpdateCreateAccountRcdPre  @I_vACTNUMST output,  @I_vACTALIAS output,  @I_vACCTTYPE output,  @I_vACTDESCR output,  @I_vPSTNGTYP output,  @I_vCATEGORY output,  @I_vACTIVE output,  @I_vTPCLBLNC output,  @I_vDECPLACS output,  @I_vFXDORVAR output,  @I_vBALFRCLC output,  @I_vUSERDEF1 output,  @I_vUSERDEF2 output,  @I_vPostSlsIn output,  @I_vPostIvIn output,  @I_vPostPurchIn output,  @I_vPostPRIn output,  @I_vACCTENTR output,  @I_vUSRDEFS1 output,  @I_vUSRDEFS2 output,  @I_vUpdateIfExists output,  @I_vNOTETEXT output,  @I_vDSPLKUPSSALES output,  @I_vDSPLKUPSIV output,  @I_vDSPLKUPSPURCH output,  @I_vDSPLKUPSPR output,  @I_vRequesterTrx output,  @I_vUSRDEFND1 output,  @I_vUSRDEFND2 output,  @I_vUSRDEFND3 output,  @I_vUSRDEFND4 output,  @I_vUSRDEFND5 output,  @O_iErrorState = @iCustomState output,  @oErrString = @iCustomErrString output select @iError = @@error if @iStatus = 0 and @iError <> 0 begin  select @iStatus = @iError end if (@iStatus <> 0) or (@iCustomState <> 0) begin  select @oErrString = rtrim(@oErrString) + ' ' + ltrim(rtrim(@iCustomErrString))  select @O_iErrorState = 992     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  if (  @I_vACTNUMST is NULL or  @I_vACTALIAS is NULL or  @I_vACCTTYPE is NULL or  @I_vACTDESCR is NULL or  @I_vPSTNGTYP is NULL or  @I_vCATEGORY is NULL or  @I_vACTIVE is NULL or  @I_vTPCLBLNC is NULL or  @I_vDECPLACS is NULL or  @I_vFXDORVAR is NULL or  @I_vBALFRCLC is NULL or  @I_vUSERDEF1 is NULL or  @I_vUSERDEF2 is NULL or  @I_vPostSlsIn is NULL or  @I_vPostIvIn is NULL or  @I_vPostPurchIn is NULL or  @I_vPostPRIn is NULL or  @I_vACCTENTR is NULL or  @I_vUSRDEFS1 is NULL or  @I_vUSRDEFS2 is NULL or  @I_vUpdateIfExists is NULL or  @I_vRequesterTrx is NULL or  @I_vDSPLKUPSSALES is NULL or  @I_vDSPLKUPSIV is NULL or  @I_vDSPLKUPSPURCH is NULL or  @I_vDSPLKUPSPR is NULL  ) begin  select @O_iErrorState = 1310    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  select  @O_iErrorState = 0  Exec @iStatus = DYNAMICS..taFormatStringsForExecs  @I_vACTDESCR,  @ACTDESCR output,  @O_iErrorState output  Exec @iStatus = DYNAMICS..taFormatStringsForExecs  @I_vUSERDEF1,  @USERDEF1 output,  @O_iErrorState output  Exec @iStatus = DYNAMICS..taFormatStringsForExecs  @I_vUSERDEF2,  @USERDEF2 output,  @O_iErrorState output  Exec @iStatus = DYNAMICS..taFormatStringsForExecs  @I_vUSRDEFS1,  @USRDEFS1 output,  @O_iErrorState output  Exec @iStatus = DYNAMICS..taFormatStringsForExecs  @I_vUSRDEFS2,  @USRDEFS2 output,  @O_iErrorState output  select @MXSEG = MXNUMSEG from DYNAMICS..SY003001 (nolock)  create table #Segments (Seg varchar(75), SegLen int, DSCRIPTN char(50), lActualSegLen int, lCalcSegLen int, DEX_ROW_ID int IDENTITY (1,1))  select @CMPANYID = CMPANYID from DYNAMICS..SY01500 (nolock) where INTERID = db_name()   exec @iStatus = DYNAMICS..tasmGetNextNoteIndex  @I_sCompanyID   = @CMPANYID,  @I_iSQLSessionID = 0,  @I_noteincrement  = 1,  @O_mNoteIndex   = @NOTEINDX output,  @O_iErrorState  = @iGetNextNoteIdxErrState output select @iError = @@error if @iStatus = 0 and @iError <> 0 begin  select @iStatus = @iError end if (@iStatus <> 0) or (@iGetNextNoteIdxErrState <> 0) begin  if (@iGetNextNoteIdxErrState <> 0)  begin  exec @iStatus = taUpdateString  @iGetNextNoteIdxErrState,  @oErrString,  @oErrString output,  @O_oErrorState output  end   select @O_iErrorState = 6504   exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output end  if (@I_vACTNUMST = '') begin  select @O_iErrorState = 877    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  if ( @I_vPSTNGTYP < 0 or @I_vPSTNGTYP > 1 ) begin  select @O_iErrorState = 1663     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  if ( @I_vACTIVE < 0 or @I_vACTIVE > 1 ) begin  select @O_iErrorState = 1664     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  if ( @I_vTPCLBLNC < 0 or @I_vTPCLBLNC > 1 ) begin  select @O_iErrorState = 1665     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  if ( @I_vUpdateIfExists < 0 or @I_vUpdateIfExists > 1 ) begin  select @O_iErrorState = 3709     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output end  if ( @I_vRequesterTrx < 0 or @I_vRequesterTrx > 1 ) begin  select @O_iErrorState = 3710     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output end  if (@I_vDSPLKUPSSALES not in(0,1)) begin  select @O_iErrorState = 8275     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output end  if (@I_vDSPLKUPSIV not in(0,1)) begin  select @O_iErrorState = 8276     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output end  if (@I_vDSPLKUPSPURCH not in(0,1)) begin  select @O_iErrorState = 8277     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output end  if (@I_vDSPLKUPSPR not in(0,1)) begin  select @O_iErrorState = 8278     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output end  select @ACTINDX = isnull(ACTINDX,0) from GL00105 (nolock) where ACTNUMST = @I_vACTNUMST  if (@I_vACTNUMST <> '' and @ACTINDX = 0) begin  select @ACTINDX = max(ACTINDX) + 1 from GL00105 (updlock)   if @ACTINDX is null  begin  select @ACTINDX = 1  end end  if ( @I_vACTNUMST <> '' and @I_vUpdateIfExists = 1 ) begin  select @ACCOUNTINDEX = ACTINDX from GL00105 (nolock) where ACTNUMST = @I_vACTNUMST  if ( @ACCOUNTINDEX <> 0 )  begin   select @ACCTTYPE = ACCTTYPE from GL00100 (nolock) where ACTINDX = @ACCOUNTINDEX  if ( @ACCTTYPE <> @I_vACCTTYPE )  begin   select @O_iErrorState = 5441     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  end  end end  select @Seperator = ACSEGSEP from DYNAMICS..SY01500 (nolock) where INTERID = db_name()  select @Position1 = 1 select @Position2 = patindex('%'+@Seperator+'%',substring(@I_vACTNUMST,@Position1,75)) while (@Position2 <> 0) begin  insert #Segments (Seg, SegLen, DSCRIPTN, lActualSegLen, lCalcSegLen) select substring(@I_vACTNUMST, @Position1, @Position2 - 1)+@Seperator, 0, '', 0, 0  select @Position1 = @Position1 + @Position2  select @Position2 = patindex('%'+@Seperator+'%',substring(@I_vACTNUMST,@Position1,75)) end  insert #Segments (Seg, SegLen, DSCRIPTN, lActualSegLen, lCalcSegLen) select rtrim(substring(@I_vACTNUMST,@Position1,75))+@Seperator, 0, '', 0, 0  update #Segments set SegLen = len(Seg)-1  if exists (select 1 from #Segments s, SY00300 a (nolock) where s.DEX_ROW_ID = a.SGMTNUMB and s.SegLen < a.LOFSGMNT and s.DEX_ROW_ID not in (select max(DEX_ROW_ID) from #Segments)) begin  select @O_iErrorState = 8128    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  update #Segments set Seg = replace(Seg, @Seperator, '')  select @Segment1 = isnull(Seg,'') from #Segments (nolock) where DEX_ROW_ID = 1 select @Segment2 = isnull(Seg,'') from #Segments (nolock) where DEX_ROW_ID = 2 select @Segment3 = isnull(Seg,'') from #Segments (nolock) where DEX_ROW_ID = 3 select @Segment4 = isnull(Seg,'') from #Segments (nolock) where DEX_ROW_ID = 4 select @Segment5 = isnull(Seg,'') from #Segments (nolock) where DEX_ROW_ID = 5 select @Segment6 = isnull(Seg,'') from #Segments (nolock) where DEX_ROW_ID = 6 select @Segment7 = isnull(Seg,'') from #Segments (nolock) where DEX_ROW_ID = 7 select @Segment8 = isnull(Seg,'') from #Segments (nolock) where DEX_ROW_ID = 8 select @Segment9 = isnull(Seg,'') from #Segments (nolock) where DEX_ROW_ID = 9 select @Segment10 = isnull(Seg,'') from #Segments (nolock) where DEX_ROW_ID = 10  select @Segment11 = rtrim(@Segment1)+rtrim(@Segment2)+rtrim(@Segment3)+rtrim(@Segment4)+rtrim(@Segment5)+  rtrim(@Segment6)+rtrim(@Segment7)+rtrim(@Segment8)+rtrim(@Segment9)+rtrim(@Segment10)  exec @iStatus = taValidateString  1,  @Segment11,  @O_iErrorState output  select @iError = @@error  if ((@iStatus = 0) and (@iError <> 0))  select @iStatus = @iError  if ((@iStatus <> 0) or (@O_iErrorState <> 0))  begin  select @O_iErrorState = 8090    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState)  end  if exists(select 1 from #Segments where substring(Seg,1,1) = '' and Seg <> '') begin  select @O_iErrorState = 5883    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  if exists (select 1 from #Segments s, SY00300 a (nolock) where s.DEX_ROW_ID = a.SGMTNUMB and s.SegLen > a.LOFSGMNT) begin  select @O_iErrorState = 879    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  select @NumberofSegments = max(SGMTNUMB) from SY00300 (nolock) select @NumAcctSegs = count(*) from #Segments (nolock) if (@NumAcctSegs > @NumberofSegments) begin  select @O_iErrorState = 990    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  select @FullAcct = @Segment1 select @Position1 = 2 while (@Position1 <= @NumberofSegments) begin  select @FullAcct = @FullAcct + space(a.LOFSGMNT - s2.SegLen) + @Seperator + s.Seg  from #Segments s, SY00300 a (nolock), #Segments s2 where s.DEX_ROW_ID = @Position1 and s.DEX_ROW_ID - 1 = s2.DEX_ROW_ID and s2.DEX_ROW_ID = a.SGMTNUMB  select @Position1 = @Position1 + 1 end  select @MAINSEGMENT = SGMTNUMB from SY00300 (nolock) where MNSEGIND = 1  if (@I_vCATEGORY <> '') begin  select @ACCATNUM = ACCATNUM from GL00102 (nolock) where UPPER(ACCATDSC) = UPPER(@I_vCATEGORY) end   if (@I_vACCTTYPE < 1 or @I_vACCTTYPE > 4) begin  select @O_iErrorState = 873     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  if (@I_vACCTTYPE = 1 and @I_vCATEGORY = '') begin  select @O_iErrorState = 872     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @O_oErrorState output  return (@O_iErrorState) end  if (@I_vACCTTYPE = 1 and @ACCATNUM = 0) begin  select @O_iErrorState = 8085     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  if (@I_vACCTTYPE = 2) and (@I_vDECPLACS not in (0,1,2))    begin  select @O_iErrorState = 874     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  if (@I_vACCTTYPE = 2) begin  select @I_vDECPLACS = @I_vDECPLACS + 1 end  if (@I_vACCTTYPE <> 2) begin  select @I_vDECPLACS = 0 end  if (@I_vACCTTYPE >= 2 and @I_vACCTTYPE <= 4) begin  select @ACCATNUM = 0,     @I_vPSTNGTYP = 0,    @CNVRMTHD = 0,     @I_vTPCLBLNC = 0,    @I_vUSERDEF1 = '',    @USERDEF1 = '''''',  @I_vUSERDEF2 = '',    @USERDEF2 = '''''',  @I_vUSRDEFS1 = '',    @USRDEFS1 = '''''',  @I_vUSRDEFS2 = '',    @USRDEFS2 = '''''',  @I_vACCTENTR = 1    end  if (@I_vACCTTYPE = 1 or @I_vACCTTYPE = 2) begin  select @I_vFXDORVAR = 0 end  if (@I_vPostSlsIn < 0 or @I_vPostSlsIn > 2) begin  select @O_iErrorState = 1312     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  if (@I_vPostIvIn < 0 or @I_vPostIvIn > 2) begin  select @O_iErrorState = 1315     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  if (@I_vPostPurchIn < 0 or @I_vPostPurchIn > 2) begin  select @O_iErrorState = 747     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  if (@I_vPostPRIn < 0 or @I_vPostPRIn > 2) begin  select @O_iErrorState = 917     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  if (@I_vACCTENTR < 0 or @I_vACCTENTR > 1) begin  select @O_iErrorState = 918     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  if (@I_vACCTTYPE = 2) begin  select @I_vPostSlsIn = 0,    @I_vPostIvIn = 0,    @I_vPostPurchIn = 0,    @I_vPostPRIn = 0    end  if (@I_vACCTTYPE = 3 or @I_vACCTTYPE = 4) begin  if (@I_vFXDORVAR <> 1 and @I_vFXDORVAR <> 2)  begin  select @O_iErrorState = 875     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState)  end end  if ((@I_vFXDORVAR = 1 or @I_vFXDORVAR = 2) and exists(select 1 from DTA00300 (nolock) where ACTINDX = @ACTINDX)) begin  select @O_iErrorState = 3762     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  if ((@I_vBALFRCLC = 1) and (@I_vFXDORVAR <> 2)) begin  select @O_iErrorState = 7804     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  if (@I_vACTALIAS <> '') begin  if (exists(select 1 from GL00100 (nolock) where ACTALIAS = @I_vACTALIAS and ACTINDX <> @ACTINDX))  begin  select @O_iErrorState = 991     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  end end  if (@I_vACCTTYPE in(1,3,4)) begin  select @SUMLOOKUPS = sum(@I_vDSPLKUPSSALES * 1) +  (@I_vDSPLKUPSIV * 2) +  (@I_vDSPLKUPSPURCH * 4) +  (@I_vDSPLKUPSPR * 8) end else begin  select @SUMLOOKUPS =  case  when @I_vDSPLKUPSSALES = 1 and @I_vDSPLKUPSPURCH = 1  then 0x07  when @I_vDSPLKUPSSALES = 1  then 0x03  when @I_vDSPLKUPSPURCH = 1  then 0x06  else 0x00  end end  select @LOOKUPS = convert(varbinary(8), @SUMLOOKUPS)  if (@I_vACTDESCR = '') begin  if (@ACTDESCR) = ''''''  begin  select @ACTDESCR = ''  end   select @lSegDescMaxLen = 50 - (@NumberofSegments - 1)   select @lSegDescDefaultLen = (50 - (@NumberofSegments - 1))/@NumberofSegments   select @lExtraChars = 50 - (@lSegDescDefaultLen * @NumberofSegments + (@NumberofSegments - 1))   update b set  b.DSCRIPTN = a.DSCRIPTN,  b.lActualSegLen =  case  when len(a.DSCRIPTN) > 0  then len(a.DSCRIPTN)  else 1  end  from GL40200 a, #Segments b  where  a.SGMTNUMB = b.DEX_ROW_ID  and a.SGMNTID = b.Seg  if (@@error <> 0)  begin  select @O_iErrorState = 8290    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState)  end   select @lExtraChars = @lExtraChars + (@lSegDescDefaultLen - lActualSegLen)  from #Segments where lActualSegLen < @lSegDescDefaultLen   select @loopcounter = 1   while @loopcounter <= @NumberofSegments  begin  select @lActualSegLen = lActualSegLen,  @DSCRIPTN = DSCRIPTN  from #Segments where DEX_ROW_ID = @loopcounter   if ((@lActualSegLen - @lSegDescDefaultLen) > @lExtraChars)  begin  select @lCalcSegLen = @lSegDescDefaultLen + @lExtraChars from #Segments where DEX_ROW_ID = @loopcounter   update #Segments set lCalcSegLen = @lCalcSegLen where DEX_ROW_ID = @loopcounter  if (@@error <> 0)  begin  select @O_iErrorState = 8291    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState)  end  end  else  begin  select @lCalcSegLen = lActualSegLen from #Segments where DEX_ROW_ID = @loopcounter   update #Segments set lCalcSegLen = @lCalcSegLen where DEX_ROW_ID = @loopcounter  if (@@error <> 0)  begin  select @O_iErrorState = 8292    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState)  end  end   if (@lCalcSegLen > @lSegDescDefaultLen)  begin  select @lExtraChars = @lExtraChars - (@lCalcSegLen - @lSegDescDefaultLen)  end   select @ACTDESCR = @ACTDESCR + substring(@DSCRIPTN, 1, @lCalcSegLen)   if (@loopcounter < @NumberofSegments)  begin  select @ACTDESCR = @ACTDESCR + @Seperator   end   select @loopcounter = @loopcounter + 1,  @DSCRIPTN = '',  @lActualSegLen = 0,  @lCalcSegLen = 0  end   exec @iStatus = DYNAMICS..taFormatStringsForExecs  @ACTDESCR,  @ACTDESCR output,  @O_iErrorState output end  if (@I_vRequesterTrx=0) begin  exec @iStatus = eConnectOutVerify  @I_vDOCTYPE='GL_Accounts',  @I_vINDEX1=@ACTINDX,  @I_vINDEX2='',  @I_vINDEX3='',  @I_vINDEX4='',  @I_vINDEX5='',  @I_vINDEX6='',  @I_vINDEX7='',  @I_vINDEX8='',  @I_vINDEX9='',  @I_vINDEX10='',  @I_vINDEX11='',  @I_vINDEX12='',  @I_vINDEX13='',  @I_vINDEX14='',  @I_vINDEX15='',  @I_vDelete = 0,  @O_iErrorState = @iCustomState output  select @iError = @@error  if @iStatus = 0 and @iError <> 0  begin  select @iStatus = @iError  end  if (@iStatus <> 0) or (@iCustomState <> 0)  begin  select @O_iErrorState = 2025    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState)  end end  if (@O_iErrorState = 0) begin  if not exists(select 1 from GL00100 a (nolock) where a.ACTINDX = @ACTINDX)   begin  select @cStatement = 'insert into GL00100(ACTINDX,'  select @cStatement1 = ''  select @cStatement1 = +rtrim(@cStatement1)+rtrim('ACTNUMBR_'+ltrim(str(s.SGMTNUMB))+',') from DYNAMICS..SY00302 s (nolock)  select @cStatement1 = substring(@cStatement1,1,len(@cStatement1)-1)   select @cStatement2 = '  ,ACTALIAS,  MNACSGMT,  ACCTTYPE,  ACTDESCR,  PSTNGTYP,  ACCATNUM,  ACTIVE,  TPCLBLNC,  DECPLACS,  FXDORVAR,  BALFRCLC,  DSPLKUPS,  CNVRMTHD,  HSTRCLRT,  NOTEINDX,  CREATDDT,'  select @cStatement3 = '  MODIFDT,  USERDEF1,  USERDEF2,  PostSlsIn,  PostIvIn,  PostPurchIn,  PostPRIn,  ADJINFL,  INFLAREV,  INFLAEQU,  ACCTENTR,  USRDEFS1,  USRDEFS2  )'  select @cStatement4 =' select '+str(@ACTINDX)+', '  insert into #Segments (Seg) select '' from DYNAMICS..SY00302 (nolock) where SGMTNUMB > @NumAcctSegs  select @cStatement5 = ''   select @cStatement5 = +rtrim(@cStatement5)+''''+rtrim(Seg)+''',' from #Segments  select @cStatement6 = '        '''+rtrim(@I_vACTALIAS)+''',  case  when '+str(@MAINSEGMENT)+' = 1  then '''+(@Segment1)+'''  when '+str(@MAINSEGMENT)+' = 2  then '''+(@Segment2)+'''  when '+str(@MAINSEGMENT)  select @cStatement6a=' = 3  then '''+(@Segment3)+'''  when '+str(@MAINSEGMENT)+' = 4  then '''+(@Segment4)+'''  when '+str(@MAINSEGMENT)  select @cStatement6b=' = 5  then '''+(@Segment5)+'''  when '+str(@MAINSEGMENT)  select @cStatement6c=' = 6  then '''+(@Segment6)+'''  when '+str(@MAINSEGMENT)+' = 7  then '''+(@Segment7)+'''  when '+str(@MAINSEGMENT)+' = 8  then '''+(@Segment8)+'''  when '+str(@MAINSEGMENT)  select @cStatement6d=' = 9  then '''+(@Segment9)+'''  else '''+(@Segment10)+'''  end,'  select @cStatement7 = '  '+str(@I_vACCTTYPE)+',  '+rtrim(@ACTDESCR)+',  '+str(@I_vPSTNGTYP)+',  '+str(@ACCATNUM)+',  '+str(@I_vACTIVE)+',  '+str(@I_vTPCLBLNC)+',  '+str(@I_vDECPLACS)+',  '+str(@I_vFXDORVAR)  select @cStatement7a = ', '+str(@I_vBALFRCLC)+',  '+str(cast(@LOOKUPS as int))+',  '+str(@CNVRMTHD)+',  '+str(@HSTRCLRT)+',  '+str(@NOTEINDX)+',  convert(varchar(12),getdate()),   convert(varchar(12),getdate()),  '+rtrim(@USERDEF1)  select @cStatement7b = ', '+rtrim(@USERDEF2)+',  '+str(@I_vPostSlsIn)+',  '+str(@I_vPostIvIn)+',  '+str(@I_vPostPurchIn)+',  '+str(@I_vPostPRIn)+',  '''+rtrim(@ADJINFL)+''',  '+str(@INFLAREV)+',  '+str(@INFLAEQU)  select @cStatement7c = ', '+str(@I_vACCTENTR)+',  '+rtrim(@USRDEFS1)+',  '+rtrim(@USRDEFS2)  exec (@cStatement+@cStatement1+@cStatement2+@cStatement3+@cStatement4+@cStatement5+@cStatement6+@cStatement6a+@cStatement6b  +@cStatement6c+@cStatement6d+@cStatement7+@cStatement7a+@cStatement7b+@cStatement7c)  if (@@error <> 0)  begin  select @O_iErrorState = 878    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState)  end  end  else  begin  if (@I_vUpdateIfExists > 0)  begin  update GL00100 set   ACTALIAS =   case  WHEN @I_vACTALIAS = ''  THEN ACTALIAS  ELSE @I_vACTALIAS  end,  PSTNGTYP = @I_vPSTNGTYP,  TPCLBLNC = @I_vTPCLBLNC,  BALFRCLC = @I_vBALFRCLC,  PostSlsIn = @I_vPostSlsIn,  PostIvIn = @I_vPostIvIn,  ACCATNUM = @ACCATNUM,  PostPurchIn = @I_vPostPurchIn,  PostPRIn = @I_vPostPRIn,  ACCTENTR = @I_vACCTENTR,  ACTIVE = @I_vACTIVE,  DSPLKUPS = @LOOKUPS,  USERDEF1 =       case  WHEN @I_vUSERDEF1 = ''  THEN USERDEF1  ELSE @I_vUSERDEF1  end,  USERDEF2 =       case  WHEN @I_vUSERDEF2 = ''  THEN USERDEF2  ELSE @I_vUSERDEF2  end,  USRDEFS1 =       case  WHEN @I_vUSRDEFS1 = ''  THEN USRDEFS1  ELSE @I_vUSRDEFS1  end,  USRDEFS2 =       case  WHEN @I_vUSRDEFS2 = ''  THEN USRDEFS2  ELSE @I_vUSRDEFS2  end,  ACTDESCR =   case   WHEN @I_vACTDESCR = ''  THEN ACTDESCR  ELSE @I_vACTDESCR    end  from GL00100 (nolock) where ACTINDX = @ACTINDX  if (@@error <> 0)  begin  select @O_iErrorState = 1314    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState)  end  end  else  begin  select @O_iErrorState = 8088     exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState)  end  end end  if (@O_iErrorState = 0) begin  if not exists(select 1 from GL00105 a (nolock) where a.ACTINDX = @ACTINDX)   begin  select @cStatement = ' insert into GL00105(ACTINDX, '  select @cStatement1 = ''  select @cStatement1 = +rtrim(@cStatement1)+rtrim('ACTNUMBR_'+ltrim(str(s.SGMTNUMB))+',') from DYNAMICS..SY00302 s (nolock)  select @cStatement1 = substring(@cStatement1,1,len(@cStatement1)-1)   select @cStatement2 = '     ,ACTNUMST )'  select @cStatement3 = ' select '+str(@ACTINDX)+', '  select @cStatement4 = ''   select @cStatement4 = +rtrim(@cStatement4)+''''+rtrim(Seg)+''',' from #Segments  select @cStatement5 = ''''+rtrim(@FullAcct)+''''   exec (@cStatement + @cStatement1 + @cStatement2 + @cStatement3 + @cStatement4 + @cStatement5)  if (@@error <> 0)  begin  select @O_iErrorState = 876    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState)  end  end end  if (@O_iErrorState = 0) begin  if @MXSEG > 0 and @Segment1 <> ''  begin  select @cStatement9 = 'if not exists (select 1 from GL40200 (nolock) where SGMNTID = '+char(39) + rtrim(@Segment1) +char(39)+' and SGMTNUMB = 1) '  select @cStatement10 = ' insert into GL40200 (SGMTNUMB, SGMNTID, SEGCOUNT)'  select @cStatement11 = ' select 1, '+char(39)+ rtrim(@Segment1) + char(39) + ' , 1 '  select @cStatement12 = ' else '  select @cStatement13 = 'update GL40200 set SEGCOUNT = SEGCOUNT + 1 where SGMTNUMB = 1 and SGMNTID = '+char(39)+rtrim(@Segment1)+char(39)  end   if @MXSEG > 1 and @Segment2 <> ''  begin  select @cStatement14 = 'if not exists (select 1 from GL40200 (nolock) where SGMNTID = '+char(39) + rtrim(@Segment2) +char(39)+' and SGMTNUMB = 2) '  select @cStatement15 = ' insert into GL40200 (SGMTNUMB, SGMNTID, SEGCOUNT)'  select @cStatement16 = ' select 2, '+char(39)+ rtrim(@Segment2) + char(39) + ' , 1 '  select @cStatement17 = ' else '  select @cStatement18 = 'update GL40200 set SEGCOUNT = SEGCOUNT + 1 where SGMTNUMB = 2 and SGMNTID = '+char(39)+rtrim(@Segment2)+char(39)  end   if @MXSEG > 2 and @Segment3 <> ''  begin  select @cStatement19 = 'if not exists (select 1 from GL40200 (nolock) where SGMNTID = '+char(39) + rtrim(@Segment3) +char(39)+' and SGMTNUMB = 3) '  select @cStatement20 = ' insert into GL40200 (SGMTNUMB, SGMNTID, SEGCOUNT)'  select @cStatement21 = ' select 3, '+char(39)+ rtrim(@Segment3) + char(39) + ' , 1 '  select @cStatement22 = ' else '  select @cStatement23 = 'update GL40200 set SEGCOUNT = SEGCOUNT + 1 where SGMTNUMB = 3 and SGMNTID = '+char(39)+rtrim(@Segment3)+char(39)   end   if @MXSEG > 3 and @Segment4 <> ''  begin  select @cStatement24 = 'if not exists (select 1 from GL40200 (nolock) where SGMNTID = '+char(39) + rtrim(@Segment4) +char(39)+' and SGMTNUMB = 4) '  select @cStatement25 = ' insert into GL40200 (SGMTNUMB, SGMNTID, SEGCOUNT)'  select @cStatement26 = ' select 4, '+char(39)+ rtrim(@Segment4) + char(39) + ' , 1 '  select @cStatement27 = ' else '  select @cStatement28 = 'update GL40200 set SEGCOUNT = SEGCOUNT + 1 where SGMTNUMB = 4 and SGMNTID = '+char(39)+rtrim(@Segment4)+char(39)  end   if @MXSEG > 4 and @Segment5 <> ''  begin  select @cStatement29 = 'if not exists (select 1 from GL40200 (nolock) where SGMNTID = '+char(39) + rtrim(@Segment5) +char(39)+' and SGMTNUMB = 5) '  select @cStatement30 = ' insert into GL40200 (SGMTNUMB, SGMNTID, SEGCOUNT)'  select @cStatement31 = ' select 5, '+char(39)+ rtrim(@Segment5) + char(39) + ' , 1 '  select @cStatement32 = ' else '  select @cStatement33 = 'update GL40200 set SEGCOUNT = SEGCOUNT + 1 where SGMTNUMB = 5 and SGMNTID = '+char(39)+rtrim(@Segment5)+char(39)  end   if @MXSEG > 5 and @Segment6 <> ''  begin  select @cStatement34 = 'if not exists (select 1 from GL40200 (nolock) where SGMNTID = '+char(39) + rtrim(@Segment6) +char(39)+' and SGMTNUMB = 6) '  select @cStatement35 = ' insert into GL40200 (SGMTNUMB, SGMNTID, SEGCOUNT)'  select @cStatement36 = ' select 6, '+char(39)+ rtrim(@Segment6) + char(39) + ' , 1 '  select @cStatement37 = ' else '  select @cStatement38 = 'update GL40200 set SEGCOUNT = SEGCOUNT + 1 where SGMTNUMB = 6 and SGMNTID = '+char(39)+rtrim(@Segment6)+char(39)  end   if @MXSEG > 6 and @Segment7 <> ''  begin  select @cStatement39 = 'if not exists (select 1 from GL40200 (nolock) where SGMNTID = '+char(39) + rtrim(@Segment7) +char(39)+' and SGMTNUMB = 7) '  select @cStatement40 = ' insert into GL40200 (SGMTNUMB, SGMNTID, SEGCOUNT)'  select @cStatement41 = ' select 7, '+char(39)+ rtrim(@Segment7) + char(39) + ' , 1 '  select @cStatement42 = ' else '  select @cStatement43 = 'update GL40200 set SEGCOUNT = SEGCOUNT + 1 where SGMTNUMB = 7 and SGMNTID = '+char(39)+rtrim(@Segment7)+char(39)  end   if @MXSEG > 7 and @Segment8 <> ''  begin  select @cStatement44 = 'if not exists (select 1 from GL40200 (nolock) where SGMNTID = '+char(39) + rtrim(@Segment8) +char(39)+' and SGMTNUMB = 8) '  select @cStatement45 = ' insert into GL40200 (SGMTNUMB, SGMNTID, SEGCOUNT)'  select @cStatement46 = ' select 8, '+char(39)+ rtrim(@Segment8) + char(39) + ' , 1 '  select @cStatement47 = ' else '  select @cStatement48 = 'update GL40200 set SEGCOUNT = SEGCOUNT + 1 where SGMTNUMB = 8 and SGMNTID = '+char(39)+rtrim(@Segment8)+char(39)   end   if @MXSEG > 8 and @Segment9 <> ''  begin  select @cStatement49 = 'if not exists (select 1 from GL40200 (nolock) where SGMNTID = '+char(39) + rtrim(@Segment9) +char(39)+' and SGMTNUMB = 9) '  select @cStatement50 = ' insert into GL40200 (SGMTNUMB, SGMNTID, SEGCOUNT)'  select @cStatement51 = ' select 9, '+char(39)+ rtrim(@Segment9) + char(39) + ' , 1 '  select @cStatement52 = ' else '  select @cStatement53 = 'update GL40200 set SEGCOUNT = SEGCOUNT + 1 where SGMTNUMB = 9 and SGMNTID = '+char(39)+rtrim(@Segment9)+char(39)  end   if @MXSEG > 9 and @Segment10 <> ''  begin  select @cStatement54 = 'if not exists (select 1 from GL40200 (nolock) where SGMNTID = '+char(39) + rtrim(@Segment10) +char(39)+' and SGMTNUMB = 10) '  select @cStatement55 = ' insert into GL40200 (SGMTNUMB, SGMNTID, SEGCOUNT)'  select @cStatement56 = ' select 10, '+char(39)+ rtrim(@Segment10) + char(39) + ' , 1 '  select @cStatement57 = ' else '  select @cStatement58 = 'update GL40200 set SEGCOUNT = SEGCOUNT + 1 where SGMTNUMB = 10 and SGMNTID = '+char(39)+rtrim(@Segment10)+char(39)  end   exec (@cStatement9+ @cStatement10+@cStatement11+@cStatement12+@cStatement13+@cStatement14+@cStatement15+@cStatement16+@cStatement17+@cStatement18+@cStatement19+  @cStatement20+@cStatement21+@cStatement22+@cStatement23+@cStatement24+@cStatement25+@cStatement26+@cStatement27+@cStatement28+@cStatement29+  @cStatement30+@cStatement31+@cStatement32+@cStatement33+@cStatement34+@cStatement35+@cStatement36+@cStatement37+@cStatement38+@cStatement39+  @cStatement40+@cStatement41+@cStatement42+@cStatement43+@cStatement44+@cStatement45+@cStatement46+@cStatement47+@cStatement48+@cStatement49+  @cStatement50+@cStatement51+@cStatement52+@cStatement53+@cStatement54+@cStatement55+@cStatement56+@cStatement57+@cStatement58) end  if (@I_vUpdateIfExists = 1) begin  select @noteindex = NOTEINDX from GL00100 (nolock) where ACTINDX = @ACTINDX  if (@I_vNOTETEXT is null)  begin  select @I_vNOTETEXT = TXTFIELD from SY03900 (nolock) where NOTEINDX = @noteindex  end end else begin  if @I_vNOTETEXT is NULL select @I_vNOTETEXT = '' end  if (@I_vNOTETEXT <> '') begin  if not exists(select 1 from SY03900 (nolock) where NOTEINDX = @noteindex)  begin  insert SY03900   (  NOTEINDX,   DATE1,   TIME1,   TXTFIELD  )   select   @NOTEINDX,  convert(varchar(12),getdate()),  substring(convert(varchar(25),getdate()),12,12),  @I_vNOTETEXT  if (@@error <> 0)  begin  select @O_iErrorState = 7907    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState)  end  end  else  begin  update SY03900 set   DATE1 = convert(varchar(12),getdate()),   TIME1 = substring(convert(varchar(25),getdate()),12,12),   TXTFIELD = @I_vNOTETEXT  where NOTEINDX = @noteindex  if (@@error <> 0)  begin  select @O_iErrorState = 9241    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState)  end  end end else begin  delete SY03900 where NOTEINDX = @noteindex  if (@@error <> 0)  begin  select @O_iErrorState = 9242    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState)  end end  exec @iStatus = taUpdateCreateAccountRcdPost  @I_vACTNUMST,  @I_vACTALIAS,  @I_vACCTTYPE,  @I_vACTDESCR,  @I_vPSTNGTYP,  @I_vCATEGORY,  @I_vACTIVE,  @I_vTPCLBLNC,  @I_vDECPLACS,  @I_vFXDORVAR,  @I_vBALFRCLC,  @I_vUSERDEF1,  @I_vUSERDEF2,  @I_vPostSlsIn,  @I_vPostIvIn,  @I_vPostPurchIn,  @I_vPostPRIn,  @I_vACCTENTR,  @I_vUSRDEFS1,  @I_vUSRDEFS2,  @I_vUpdateIfExists,  @I_vNOTETEXT,  @I_vDSPLKUPSSALES,  @I_vDSPLKUPSIV,  @I_vDSPLKUPSPURCH,  @I_vDSPLKUPSPR,  @I_vRequesterTrx,  @I_vUSRDEFND1,  @I_vUSRDEFND2,  @I_vUSRDEFND3,  @I_vUSRDEFND4,  @I_vUSRDEFND5,  @O_iErrorState = @iCustomState output,  @oErrString = @iCustomErrString output select @iError = @@error if @iStatus = 0 and @iError <> 0 begin  select @iStatus = @iError end if (@iStatus <> 0) or (@iCustomState <> 0) begin  select @oErrString = rtrim(@oErrString) + ' ' + ltrim(rtrim(@iCustomErrString))  select @O_iErrorState = 1311    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  if (@I_vRequesterTrx=0) begin  exec @iStatus = eConnectOutVerify  @I_vDOCTYPE='GL_Accounts',  @I_vINDEX1=@ACTINDX,  @I_vINDEX2='',  @I_vINDEX3='',  @I_vINDEX4='',  @I_vINDEX5='',  @I_vINDEX6='',  @I_vINDEX7='',  @I_vINDEX8='',  @I_vINDEX9='',  @I_vINDEX10='',  @I_vINDEX11='',  @I_vINDEX12='',  @I_vINDEX13='',  @I_vINDEX14='',  @I_vINDEX15='',  @I_vDelete = 1,  @O_iErrorState = @iCustomState output  select @iError = @@error  if @iStatus = 0 and @iError <> 0  begin  select @iStatus = @iError  end  if (@iStatus <> 0) or (@iCustomState <> 0)  begin  select @O_iErrorState = 2026    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState)  end end   return (@O_iErrorState)   
GO
GRANT EXECUTE ON  [dbo].[taUpdateCreateAccountRcd] TO [DYNGRP]
GO
