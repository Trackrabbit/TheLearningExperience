SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
 create    procedure [dbo].[aagYECUtilityCheckForDiv] @I_nYearClosed smallint, @I_nCMPID int, @I_tMCRegistered tinyint  = NULL, @I_nStarting_Journal_Entry int  = NULL output, @I_nRE_Account_Index int  = NULL output, @O_nRun_Utility_Flag int  = NULL output, @O_cDivisional_Close char(18) = NULL output, @I_TrueRetEarFalse tinyint   as Begin  declare  @l_nStatus int,  @l_cPROFIT_AND_LOSS varchar(255),  @O_nSQL_Error_State int,  @l_nError int,  @l_nCntActINDX int,  @l_nHISTORYR int,  @cDBName char(5),  @l_nCntFAActIndx int,  @l_nFAActIndx int,  @l_nSGMTNUMB int,  @l_cExecCmd varchar(1000),  @tBeforeSegmentLength tinyint,  @tDivisionalSegmentLength tinyint,  @tAfterSegmentLength tinyint,  @l_SQL_Error_State int,  @iStatus int,  @TRUE int,  @POST_ACCT int,  @PROFIT_AND_LOSS int,  @cAccountNumberString char(128),  @l_cBBF varchar(255)   set @l_nCntActINDX = 0  set @O_nRun_Utility_Flag = 0  set @l_nHISTORYR = 0  set @cDBName = ''  set @l_nSGMTNUMB = 0   select @l_nHISTORYR = HISTORYR from SY40101 where YEAR1 = @I_nYearClosed + 1   exec    @l_nStatus = DYNAMICS.dbo.smGetMsgString 12125, @cDBName, @l_cPROFIT_AND_LOSS output, @O_nSQL_Error_State output  select @l_nError = @@error  if @l_nStatus = 0 and @l_nError <> 0  select @l_nStatus = @l_nError   if ( (@l_nStatus <> 0) or (@O_nSQL_Error_State <> 0) )  return (@l_nStatus)   exec    @l_nStatus = DYNAMICS.dbo.smGetMsgString 12030, @cDBName, @l_cBBF output, @O_nSQL_Error_State output  select @l_nError = @@error  if @l_nStatus = 0 and @l_nError <> 0  select @l_nStatus = @l_nError   if ( (@l_nStatus <> 0) or (@O_nSQL_Error_State <> 0) )  return (@l_nStatus)  if @I_TrueRetEarFalse = 1   begin  if @l_nHISTORYR = 1  begin  select @I_nStarting_Journal_Entry = JRNENTRY from (   select distinct(JRNENTRY) as JRNENTRY from GL30000  where HSTYEAR = @I_nYearClosed + 1 and   (SOURCDOC = @l_cPROFIT_AND_LOSS or SOURCDOC = @l_cBBF) and   SEQNUMBR = 0 ) a   if exists(select 1 from GL30000 where HSTYEAR = @I_nYearClosed + 1 and JRNENTRY = @I_nStarting_Journal_Entry and SOURCDOC = @l_cPROFIT_AND_LOSS)  begin  return  end  end  else  begin  select @I_nStarting_Journal_Entry = JRNENTRY from (   select distinct(JRNENTRY) as JRNENTRY from GL20000  where OPENYEAR = @I_nYearClosed + 1 and   (SOURCDOC = @l_cPROFIT_AND_LOSS or SOURCDOC = @l_cBBF) and   SEQNUMBR = 0 ) a   if exists(select 1 from GL20000 where OPENYEAR = @I_nYearClosed + 1 and JRNENTRY = @I_nStarting_Journal_Entry and SOURCDOC = @l_cPROFIT_AND_LOSS)  begin  return  end  end  if exists(select name from tempdb..sysobjects where name = '##AAGL40000'    and type = 'U') drop table ##AAGL40000  select @l_cExecCmd = 'select 0 as TRERCLSG, 0 as DIVACTSG into ##AAGL40000'  exec (@l_cExecCmd)  set @O_nRun_Utility_Flag = 1  return  end  select @cDBName = INTERID from DYNAMICS..SY01500 where CMPANYID = @I_nCMPID   set @O_cDivisional_Close = '##Divisional_Close'  exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'TRUE',@TRUE output, @l_SQL_Error_State output  if @l_SQL_Error_State <> 0 return  exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'POST_ACCT', @POST_ACCT output, @l_SQL_Error_State output  if @l_SQL_Error_State <> 0 return   exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'PROFIT_AND_LOSS', @PROFIT_AND_LOSS output, @l_SQL_Error_State output  if @l_SQL_Error_State <> 0 return   if exists(select name from tempdb..sysobjects where name = '##Divisional_Close'    and type = 'U') drop table ##Divisional_Close  create table ##Divisional_Close(  SGMNTID char(67)  NOT NULL,   CURNCYID char(15)  NOT NULL,   CURRNIDX smallint  NOT NULL,   RTCLCMTD smallint  NOT NULL,   RATETPID char(15)  NOT NULL,   EXGTBLID char(15)  NOT NULL,   REARNAMT numeric(19,5)  NOT NULL,   ORIGAMT numeric(19,5)  NOT NULL,  RERINDX    int   NOT NULL)   if @l_nHISTORYR = 1  begin  select @I_nStarting_Journal_Entry = JRNENTRY from (   select distinct(JRNENTRY) as JRNENTRY from GL30000  where HSTYEAR = @I_nYearClosed + 1 and   (SOURCDOC = @l_cPROFIT_AND_LOSS or SOURCDOC = @l_cBBF) and   SEQNUMBR = 0 ) a   if exists(select 1 from GL30000 where HSTYEAR = @I_nYearClosed + 1 and JRNENTRY = @I_nStarting_Journal_Entry and SOURCDOC = @l_cPROFIT_AND_LOSS)  begin  return  end  end  else  begin  select @I_nStarting_Journal_Entry = JRNENTRY from (   select distinct(JRNENTRY) as JRNENTRY from GL20000  where OPENYEAR = @I_nYearClosed + 1 and   (SOURCDOC = @l_cPROFIT_AND_LOSS or SOURCDOC = @l_cBBF) and   SEQNUMBR = 0 ) a  if exists(select 1 from GL20000 where OPENYEAR = @I_nYearClosed + 1 and JRNENTRY = @I_nStarting_Journal_Entry and SOURCDOC = @l_cPROFIT_AND_LOSS)  begin  return  end  end  if exists(SELECT 1   FROM   AAG30000 a  join SY40101 b  on a.YEAR1 = b.YEAR1  WHERE  a.JRNENTRY = @I_nStarting_Journal_Entry  and b.HISTORYR = @I_nYearClosed + 1  and b.HISTORYR = 0)  begin  set @O_nRun_Utility_Flag = 0  return 50    end    select @l_nSGMTNUMB = DIVACTSG, @I_nRE_Account_Index = RERINDX from GL40000   if exists(select name from tempdb..sysobjects where name = '##AAGL40000'    and type = 'U') drop table ##AAGL40000  select 1 as TRERCLSG, @l_nSGMTNUMB as DIVACTSG into ##AAGL40000   exec @iStatus = glCalculateSegment  @l_nSGMTNUMB,  @tBeforeSegmentLength output,  @tDivisionalSegmentLength output,  @tAfterSegmentLength output,  @l_SQL_Error_State output  if @l_SQL_Error_State <> 0 return   select @tBeforeSegmentLength = @tBeforeSegmentLength + 1   if @I_tMCRegistered = @TRUE  begin  insert into  ##Divisional_Close  (SGMNTID,   CURNCYID,   CURRNIDX,   RTCLCMTD,   RATETPID,   EXGTBLID,   REARNAMT,   ORIGAMT,  RERINDX)  select  distinct substring(ACTNUMST,@tBeforeSegmentLength,@tDivisionalSegmentLength),  CURNCYID,  max(CURRNIDX),  0,  '',  '',  SUM(DEBITAMT)-SUM(CRDTAMNT),  SUM(ORDBTAMT)-SUM(ORCRDAMT),  0  from  GL00105,  GL30000,  GL00100  where  GL00105.ACTINDX = GL30000.ACTINDX   and GL00100.ACTINDX = GL00105.ACTINDX  and GL00100.ACCTTYPE = @POST_ACCT  and GL00100.PSTNGTYP = @PROFIT_AND_LOSS  and GL30000.HSTYEAR = @I_nYearClosed   group by substring(ACTNUMST,@tBeforeSegmentLength,@tDivisionalSegmentLength),CURNCYID  end  else   begin  insert into  ##Divisional_Close  (SGMNTID,   CURNCYID,   CURRNIDX,   RTCLCMTD,   RATETPID,   EXGTBLID,   REARNAMT,   ORIGAMT,  RERINDX)  select  distinct substring(ACTNUMST,@tBeforeSegmentLength,@tDivisionalSegmentLength),  '',  0,  0,  '',  '',  SUM(DEBITAMT)-SUM(CRDTAMNT),  0.00,  0   from  GL00105,  GL30000,  GL00100  where  GL00105.ACTINDX  = GL30000.ACTINDX  and GL00105.ACTINDX  = GL00100.ACTINDX  and GL00100.ACCTTYPE = @POST_ACCT  and GL00100.PSTNGTYP = @PROFIT_AND_LOSS  and GL30000.HSTYEAR  = @I_nYearClosed  group by substring(ACTNUMST,@tBeforeSegmentLength,@tDivisionalSegmentLength)  end   select  @cAccountNumberString = ACTNUMST  from  GL00105  where  ACTINDX = @I_nRE_Account_Index   update  ##Divisional_Close  set   RERINDX =  GL00105.ACTINDX  from  GL00105  where  ACTNUMST = stuff(@cAccountNumberString,@tBeforeSegmentLength,  @tDivisionalSegmentLength,rtrim(SGMNTID))   set @O_nRun_Utility_Flag = 1  End    
GO
GRANT EXECUTE ON  [dbo].[aagYECUtilityCheckForDiv] TO [DYNGRP]
GO
