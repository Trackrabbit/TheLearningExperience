SET QUOTED_IDENTIFIER OFF
GO
SET ANSI_NULLS ON
GO
create procedure [dbo].[smItemDescriptionChange1]  @I_charStartItem 	char(30),  @I_charEndItemDesc 	char(100),  @O_iErrorState 		int = NULL  output with encryption as set transaction isolation level read uncommitted set nocount on declare @ITEMDESC  	char(255), @DBNAME  	char(25), @DBID 		char(25), @tTransaction	tinyint, @tLoop		tinyint, @iStatus	int, @cStartItem 	char(50), @cEndItemDesc	char(120) select @DBNAME = DB_NAME() select @DBID = CMPANYID from DYNAMICS..SY01500 where INTERID = @DBNAME exec @iStatus = smFormatStringsForExecs @I_vInputString  = @I_charStartItem, @O_cOutputString = @cStartItem output, @O_iErrorState	 = @O_iErrorState output if @iStatus <> 0 or @O_iErrorState <> 0 begin set @O_iErrorState = 90 return end exec @iStatus = smFormatStringsForExecs @I_vInputString  = @I_charEndItemDesc, @O_cOutputString = @cEndItemDesc output, @O_iErrorState	 = @O_iErrorState output if @iStatus <> 0 or @O_iErrorState <> 0 begin set @O_iErrorState = 91 return end select @O_iErrorState 	 = 0 if @@trancount = 0    begin select @tTransaction = 1 begin transaction end while ( @tLoop is NULL ) begin select @tLoop = 1 if	@I_charStartItem	is NULL or @I_charEndItemDesc	is NULL or @cStartItem		is NULL or @cEndItemDesc		is NULL begin select @O_iErrorState = 1		 break end  declare ta_IDMCursor insensitive CURSOR for select 'update '+o.name+' set ITEMDESC =' + rtrim(@cEndItemDesc) + ' where ITEMNMBR = ' + rtrim(@cStartItem)   from sysobjects o, syscolumns c, syscolumns c2 where	o.id = c.id and o.id = c2.id and o.type = 'U' and c.name = 'ITEMDESC' and c2.name = 'ITEMNMBR' and o.name <>'ME44708' order by o.name set nocount on OPEN ta_IDMCursor FETCH NEXT FROM ta_IDMCursor INTO @ITEMDESC WHILE (@@FETCH_STATUS <> -1) begin exec (@ITEMDESC) if @@error <> 0  begin select @O_iErrorState = 2	 break end  FETCH NEXT FROM ta_IDMCursor INTO @ITEMDESC end DEALLOCATE ta_IDMCursor if @O_iErrorState <> 0 break update a set ORMSTRID = @I_charEndItemDesc from GL10001 a, GL10000 b where 	a.ORMSTRID = @I_charStartItem and a.JRNENTRY = b.JRNENTRY and b.SERIES = 5 if @@error <> 0  begin select @O_iErrorState = 3	 break end update GL20000 set ORMSTRID = @I_charEndItemDesc where ORMSTRID = @I_charStartItem and SERIES = 5 if @@error <> 0  begin select @O_iErrorState = 4	 break end update GL30000 set ORMSTRID = @I_charEndItemDesc where ORMSTRID = @I_charStartItem and SERIES = 5 if @@error <> 0  begin select @O_iErrorState = 5	 break end update PJOURNAL set ORMSTRID = @I_charEndItemDesc where ORMSTRID = @I_charStartItem if @@error <> 0  begin select @O_iErrorState = 6	 break end  declare ta_IDMCursor insensitive CURSOR for select 'update '+o.name+' set VNDITDSC =' + rtrim(@cEndItemDesc) + ' where ITEMNMBR = ' + rtrim(@cStartItem)   from sysobjects o, syscolumns c, syscolumns c2 where	o.id = c.id and o.id = c2.id and o.type = 'U' and c.name = 'VNDITDSC' and c2.name = 'ITEMNMBR' and o.name <>'ME44708'  order by o.name set nocount on OPEN ta_IDMCursor FETCH NEXT FROM ta_IDMCursor INTO @ITEMDESC WHILE (@@FETCH_STATUS <> -1) begin exec (@ITEMDESC) if @@error <> 0  begin select @O_iErrorState = 7	 break end  FETCH NEXT FROM ta_IDMCursor INTO @ITEMDESC end DEALLOCATE ta_IDMCursor if @O_iErrorState <> 0 break end if @O_iErrorState <> 0 begin if @tTransaction = 1 rollback transaction end else if @tTransaction = 1 begin commit transaction end return   
GO
GRANT EXECUTE ON  [dbo].[smItemDescriptionChange1] TO [DYNGRP]
GO
