SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
 CREATE procedure [dbo].[aagMLRows] @iDebug   tinyint  = 0,  @oStatus   smallint  = 0  out as set nocount on begin    if @iDebug = 1   begin  print ''  print '************************'  print '** aagMLRows started **'  print '************************'  print ''  end   declare @retCode int  declare @execCmd  nvarchar(4000)  declare @execCmd1 varchar(8000)  declare @execCmd2 varchar(8000)  declare @execCmd3 varchar(8000)  declare @paramDef nvarchar(512)  declare @codesCmd nvarchar(2000)  declare @treeCodesCmd nvarchar(2000)  declare @cmd varchar(1000)  declare @columnStr nvarchar(512)   declare @treeID int  declare @attachNext tinyint  declare @per smallint  declare @toPer smallint  declare @level smallint  declare @levelCount smallint  declare @rowOrder int  declare @newOrder int  declare @column smallint  declare @count smallint  declare @p char(1)  declare @id int  declare @idWork int  declare @nodeID int  declare @newID int  declare @rowID int  declare @node varchar(50)  declare @dsplLvl int  declare @parentNodeID int  declare @hasNodes tinyint  declare @hasCodes tinyint  declare @cols int  declare @levels int  declare @col smallint  declare @time int  declare @L1CodeID int  declare @MaxLvlCnt int  declare @Columns varchar(8000)  declare @levlcount int  declare @l_nStatus int,  @l_nError int,  @l_cPROFIT_AND_LOSS varchar(255),  @cDBName char(5),  @O_nSQL_Error_State int   select  @retCode    = 0,  @execCmd    = N'',  @paramDef  = N'@dsplLvl int, @nodeID int',  @codesCmd  = N'',  @treeCodesCmd  = N'',  @columnStr  = N'',  @treeID   = 0,  @attachNext   = 0,  @cmd   = '',  @per   = 0,  @toPer   = 0,  @level   = 0,  @levelCount  = 0,  @rowOrder  = 0,  @newOrder  = 0,  @column   = 0,  @count   = 0,  @p   = '''',  @id   = 0,  @idWork   = 0,  @nodeID   = 0,  @newID   = 0,  @rowID   = 0,  @node   = '',  @dsplLvl  = 0,  @dsplLvl   = 0,  @parentNodeID  = 0,  @hasNodes  = 0,  @hasCodes  = 0,  @cols   = 0,  @levels   = 0,  @col   = 0,  @L1CodeID = 0,  @MaxLvlCnt = 0,  @Columns = '',  @levlcount = 0,  @cDBName = db_name(),  @l_nStatus = 0,   @l_nError = 0,  @l_cPROFIT_AND_LOSS = '',  @O_nSQL_Error_State = 0   exec    @l_nStatus = DYNAMICS.dbo.smGetMsgString 12125, @cDBName, @l_cPROFIT_AND_LOSS output, @O_nSQL_Error_State output  select @l_nError = @@error  if @l_nStatus = 0 and @l_nError <> 0  select @l_nStatus = @l_nError   if ( (@l_nStatus <> 0) or (@O_nSQL_Error_State <> 0) )  return (@l_nStatus)   if exists(select * from tempdb..sysobjects where name = '##TempRows' and xtype = 'U') drop table ##TempRows  create table ##TempRows(rowOrder bigint not null UNIQUE, lvl smallint not null, dsplLvl smallint, descr varchar(800),   basePeriod smallint not null, attachNext tinyint not null, pageBreak tinyint not null,   totals tinyint not null)    if exists(select * from tempdb..sysobjects where name = '##TempRowOrder' and xtype = 'U') drop table ##TempRowOrder  create table ##TempRowOrder(rowOrder bigint not null UNIQUE)  select @levelCount = count(*) from ##Lvl   declare c cursor fast_forward for select aaColumn from ##Lvl order by aaOrder  open c  fetch next from c into @column  while (@@fetch_status <> -1) and (dbo.aagMLCancelled() = 0)  begin  select @level = @level +1   create table #Codes(dsplLvl smallint, descr varchar(800), basePeriod smallint not null,   codeID varchar(50) not null, attachNext tinyint not null, pageBreak tinyint not null,  totals tinyint not null, isNode tinyint, hasNodes tinyint, hasCodes tinyint,   rowID int not null identity)    if (select aaUseTree from ##Col where aaColumn = @column) = 1   begin  if @iDebug = 1 print '** Level ' + convert(varchar(3), @level) + ' uses tree **'   create table #Tree(id bigint, nodeID int, node varchar(50), dsplLvl int, attachNext tinyint, parentNode int,   hasNodes tinyint, hasCodes tinyint, rowID int not null identity)   select @codesCmd = convert(varchar(2000), aaSQLCodeCmd) from ##Col where aaColumn = @column  select @treeCodesCmd = convert(varchar(2000), aaSQLTreeCodeCmd) from ##Col where aaColumn = @column  select @treeID = aaTreeID from ##Col where aaColumn = @column  select @cmd = 'declare t cursor fast_forward for' + SPACE(1) + @codesCmd  if @iDebug = 1 print @cmd  exec (@cmd)  open t   fetch next from t into @nodeID, @node, @dsplLvl, @parentNodeID  while (@@fetch_status <> -1) and (dbo.aagMLCancelled() = 0)  begin   if (select aaTreeLevel from ##Col where aaColumn = @column) <> 0   begin   select @dsplLvl = 1  select @hasNodes = 0  end  else   if exists(select top 1 aaTreeID from AAG00601 where aaTreeID = @treeID and aaParentNodeID = @nodeID) select @hasNodes = 1  else select @hasNodes = 0   if exists(select aaTreeID from AAG00602 where aaTreeID = @treeID and aaNodeID = @nodeID)   begin  select @attachNext = 1  select @hasCodes = 1  end  else  begin  select @attachNext = 0  select @hasCodes = 0  end   if not exists(select nodeID from #Tree where nodeID = @parentNodeID)  begin  select @id = @id + 327  select @idWork = @id  end  else  begin  select @idWork = max(id) +1 from #Tree where parentNode = @parentNodeID  if (@idWork is null) select @idWork = max(id) +1 from #Tree where nodeID = @parentNodeID  end   insert #Tree(id, nodeID, node, dsplLvl, attachNext, parentNode, hasNodes, hasCodes)   select @idWork, @nodeID, @node, @dsplLvl, @attachNext, @parentNodeID, @hasNodes, @hasCodes  if @iDebug = 1 select * from #Tree   select @newID = 0   declare r cursor fast_forward for select rowID from #Tree order by id  open r   fetch next from r into @rowID  while (@@fetch_status <> -1)  begin  select @newID = @newID + 32700  update #Tree set id = @newID where rowID = @rowID    fetch next from r into @rowID  end  close r  deallocate r   fetch next from t into @nodeID, @node, @dsplLvl, @parentNodeID  end  close t  deallocate t  if @iDebug = 1 select * from #Tree order by id   if (select aaUseCodes from ##Col where aaColumn = @column) = 0  begin  insert #Codes(dsplLvl, descr, basePeriod, codeID, attachNext, pageBreak, totals, isNode, hasNodes, hasCodes)  select dsplLvl, node, 0, nodeID, attachNext, 0, 0, 1, hasNodes, hasCodes from #Tree order by id  end  else  begin  select @treeCodesCmd = convert(varchar(2000), aaSQLTreeCodeCmd) from ##Col where aaColumn = @column   select @execCmd = N'insert #Codes(dsplLvl, descr, basePeriod, codeID, attachNext, pageBreak, totals) ' + @treeCodesCmd    if (select aaTreeLevel from ##Col where aaColumn = @column) = 0  begin  if @iDebug = 1 print @execCmd  select @dsplLvl = 0, @nodeID = 1  exec @retCode = sp_executesql @execCmd, @paramDef, @dsplLvl = @dsplLvl, @nodeID = @nodeID  if (@retCode <> 0) begin close c deallocate c return @retCode end  if (dbo.aagMLCancelled() = 1) begin close c deallocate c goto DONE end  end   declare t cursor fast_forward for select dsplLvl, nodeID, node, hasNodes, hasCodes from #Tree order by id  open t  fetch next from t into @dsplLvl, @nodeID, @node, @hasNodes, @hasCodes  while (@@fetch_status <> -1) and (dbo.aagMLCancelled() = 0)  begin   insert #Codes(dsplLvl, descr, basePeriod, codeID, attachNext, pageBreak, totals, isNode, hasNodes, hasCodes)  select @dsplLvl, @node, 0, '0', 0, 0, 0, 1, @hasNodes, @hasCodes   exec @retCode = sp_executesql @execCmd, @paramDef, @dsplLvl = @dsplLvl, @nodeID = @nodeID  if (@retCode <> 0) begin close t deallocate t close c deallocate c return @retCode end  if (dbo.aagMLCancelled() = 1) begin close t deallocate t close c deallocate c goto DONE end   fetch next from t into @dsplLvl, @nodeID, @node, @hasNodes, @hasCodes  end  close t  deallocate t  end    drop table #Tree   end   else  if (@column) = -1   begin  if @iDebug = 1 print '** Level ' + convert(varchar(3), @level) + ' is time level **'   select @per = From_Period, @toPer = To_Period from ##Options  while @per <= @toPer  begin  insert #Codes(dsplLvl, descr, basePeriod, codeID, attachNext, pageBreak, totals)  select 1, rtrim(aaPerStr) + SPACE(1) + convert(varchar(3), @per) + '/' + convert(varchar(4), YEAR1),  convert(varchar(3), @per), '0', 1, 0, 0 from ##Options   select @per = @per +1  end  end    else  begin  if @iDebug = 1 print '** Level ' + convert(varchar(3), @level) + ' uses codes **'   if (select aaInclEmptyCodes from ##Col where aaColumn = @column) = 1   begin  if @iDebug = 1 print '** Add empty code **'   insert #Codes(dsplLvl, descr, basePeriod, codeID, attachNext, pageBreak, totals)   select 1, aaEmptyCodeStr, 0, '0', 1, 0, 0 from ##Options  end   select @codesCmd = convert(nvarchar(2000), aaSQLCodeCmd) from ##Col where aaColumn = @column  select @execCmd = N'insert #Codes(dsplLvl, descr, basePeriod, codeID, attachNext, pageBreak, totals) ' + @codesCmd    if @iDebug = 1 print @execCmd  exec @retCode = sp_executesql @execCmd  if (@retCode <> 0) begin close c deallocate c return @retCode end  if (dbo.aagMLCancelled() = 1) begin close c deallocate c goto DONE end  end   if (select count(*) from #Codes) = 0 begin close c deallocate c select @oStatus = @level return end    update #Codes set pageBreak = 0  where  #Codes.rowID = 1   update #Codes set pageBreak = aaPageBreak from ##Col where aaColumn = @column and #Codes.rowID > 1   if (select aaUseTree from ##Col where aaColumn = @column) = 0   begin   if (@level < @levelCount) update #Codes set totals = aaTotals from ##Col where aaColumn = @column  end  else   begin  if (@level = @levelCount)   begin   if (select aaUseCodes from ##Col where aaColumn = @column) = 1   update #Codes set totals = aaTotals from ##Col where aaColumn = @column and isNode = 1 and (hasCodes = 1 or hasNodes = 1)  else   update #Codes set totals = aaTotals from ##Col where aaColumn = @column and isNode = 1 and hasCodes = 0 and hasNodes = 1  end  else   begin   if (select aaUseCodes from ##Col where aaColumn = @column) = 1  begin  update #Codes set totals = aaTotals from ##Col where aaColumn = @column and isNode = 1 and (hasCodes = 1 or hasNodes = 1)  update #Codes set totals = aaTotals from ##Col where aaColumn = @column and attachNext = 1 and isNode is NULL  end  else   update #Codes set totals = aaTotals from ##Col where aaColumn = @column and isNode = 1 and (hasCodes = 1 or hasNodes = 1)  end  end   if @iDebug = 1 select * from #Codes order by rowID   select @cmd = 'alter table ##TempRows ADD ' + 'L' + convert(nvarchar(3), @level) + '_codeID varchar(50) null'  if @iDebug = 1 print @cmd  exec (@cmd)   if @level = 1  begin  select @execCmd =   N'insert ##TempRows(rowOrder, lvl, dsplLvl, descr, basePeriod, attachNext, pageBreak, totals, L1_codeID)' +  '  select new.rowID,' + convert(nvarchar(3), @level) + ', new.dsplLvl, new.descr, new.basePeriod, new.attachNext, new.pageBreak, new.totals,new.codeID' +  '  from #Codes new '  if  (select Top 1 aaColumn from ##Lvl order by aaOrder)<> -1  begin  select @execCmd = @execCmd + 'where (new.codeID in (select distinct L1_codeID from ##PreCalc where period = 400 and L1_codeID not in (select distinct L1_codeID from ##Rows)   and (L1_codeID in(select ACTINDX from AAG30001 where SOURCDOC = '''+ replace(@l_cPROFIT_AND_LOSS, '''', '''''') + ''') or L1_codeID in(select ACTINDX from AAG40001 where SOURCDOC = '''+ replace(@l_cPROFIT_AND_LOSS, '''', '''''') + ''')))  or new.codeID=''0'') order by new.rowID '   end  else  select @execCmd = @execCmd + 'order by new.rowID '  if @iDebug = 1 print @execCmd   exec @retCode = sp_executesql @execCmd  if (@retCode <> 0) begin close c deallocate c return @retCode end  if (dbo.aagMLCancelled() = 1) begin close c deallocate c goto DONE end  end    else   begin  select * into #Work from ##TempRows where lvl = (@level -1) and attachNext = 1 order by rowOrder   select @execCmd = N'insert ##TempRows(rowOrder, lvl, dsplLvl, descr, basePeriod, attachNext, pageBreak, totals'   select @count = 1  while @count <= @level  begin  select @execCmd = @execCmd + N', L' + convert(varchar(3), @count) + '_codeID'  select @count = @count +1  end   select @execCmd = @execCmd +  N') select (old.rowOrder + new.rowID),' + convert(nvarchar(3), @level) + ', new.dsplLvl, new.descr,' +  '     case' +   '       when old.basePeriod <> 0 then old.basePeriod' +  '       when new.basePeriod <> 0 then new.basePeriod' +  '       else 0' +  '     end,' +  '     new.attachNext,' +  '     new.pageBreak,' +  '     new.totals'   select @count = 1  while @count <= (@level -1)  begin  select @execCmd = @execCmd + ', old.L' + convert(nvarchar(3), @count) + '_codeID'  select @count = @count +1  end   select @time=0  if exists(select aaColumn from ##Lvl where aaColumn = -1)  select @time =((select aaOrder from ##Lvl where aaColumn = -1)-(select Min(aaOrder) from ##Lvl)) +1  if @level = @time   select @execCmd = @execCmd + ', new.codeID from #Work old, #Codes new order by old.rowOrder, new.rowID'  else   begin  declare p cursor fast_forward for select aaColumn from ##Lvl order by aaOrder  open p  fetch next from p into @col  begin  select @count = 1  if @col = -1  begin  fetch next from p into @col  select @count = @count +1  end  if @@fetch_status <> 0  select @execCmd = @execCmd + ', new.codeID from ##RowsTemp old, #Codes new '  else   if (@level = 2 )and ((select Top 1 aaColumn from ##Lvl order by aaOrder) = -1 )  select @execCmd = @execCmd +' , new.codeID from ##RowsTemp old, #Codes new where new.codeID in (select distinct L' + convert(nvarchar(3), @level ) + '_codeID from ##PreCalc where period = 400 and L1_codeID not in (select distinct L1_codeID from ##Rows)) or new.codeID=''0'' '  else  select @execCmd = @execCmd +' , new.codeID from ##RowsTemp old, #Codes new where new.codeID in (select distinct L' + convert(nvarchar(3), @level ) + '_codeID from ##PreCalc where '    if not ((@level = 2 )and ((select Top 1 aaColumn from ##Lvl order by aaOrder) = -1 ))  begin  while (@@fetch_status = 0) and (@count <= (@level -1))  begin  if @count =1   begin  if @col <> -1   begin  if ((select Top 1 aaColumn from ##Lvl order by aaOrder)<> -1 )  begin  if (@count > 1) select @execCmd = @execCmd + ' and '  end   else  begin  if (@count > 2) select @execCmd = @execCmd + ' and '  end  select @execCmd = @execCmd +' L' + convert(nvarchar(3), @count) + '_codeID = old.L' + convert(nvarchar(3), @count ) + '_codeID '   end  end  select @count = @count +1  fetch next from p into @col  if (@@fetch_status = -1 or @count = @level)   select @execCmd = @execCmd + ' and period = 400 and L1_codeID not in (select distinct L1_codeID from ##Rows)) or new.codeID=''0'' and old.lvl = 1'   end  end  select @execCmd = @execCmd + ' order by old.rowOrder, new.rowID'  end  close p  deallocate p  end   if exists(select * from tempdb..sysobjects where name = '##RowsTemp' and xtype = 'U') drop table ##RowsTemp  select * into ##RowsTemp from ##TempRows where lvl = 1  if @iDebug = 1 print @execCmd   exec @retCode = sp_executesql @execCmd  if (@retCode <> 0) begin close c deallocate c return @retCode end  if (dbo.aagMLCancelled() = 1) begin close c deallocate c goto DONE end   drop table #Work  end  drop table #Codes  if ((select count(*) from ##TempRows) >65536 ) begin select @oStatus = -70 return end  if (((select Max(dsplLvl) from ##TempRows) + @cols)>256) begin select @oStatus = -80 return end   if @iDebug = 1 print '** Renumber level ' + convert(varchar(3), @level) + ' **'  delete from ##TempRowOrder   insert ##TempRowOrder(rowOrder) select rowOrder from ##TempRows a order by a.rowOrder   if @level = @levelCount select @newOrder = 0  declare r cursor fast_forward for select rowOrder from ##TempRowOrder order by rowOrder  open r  fetch next from r into @rowOrder  while (@@fetch_status <> -1) and (dbo.aagMLCancelled() = 0)  begin  if @level = @levelCount select @newOrder = @newOrder +1  else select @newOrder = @newOrder + 65600  update ##TempRows set rowOrder = @newOrder where rowOrder = @rowOrder   fetch next from r into @rowOrder  end  close r  deallocate r   select @newOrder = @newOrder + 327   fetch next from c into @column  end  close c  deallocate c   if exists(select * from tempdb..sysobjects where name = '##TestRows' and xtype = 'U') drop table ##TestRows  select * into ##TestRows from ##TempRows where 1 <> 1   set @rowOrder = 0  select @cols = count(*) from ##Lvl  select @count = 1  while @count <= @cols  begin   select @Columns = @Columns + ', L' + convert(varchar(3), @count) + '_codeID'  select @count = @count +1  end   exec('declare CurCodeID cursor fast_forward for  select L1_codeID from ##TempRows where lvl = 1 group by L1_codeID')   select @newOrder = isnull(max(rowOrder),0) + 1 from ##Rows  open CurCodeID  fetch next from CurCodeID into @L1CodeID  while @@fetch_status=0  begin  exec('declare curUpdaterowOrder cursor fast_forward for   select lvl,rowOrder from ##TempRows   where L1_codeID = ' + @L1CodeID + '   order by basePeriod,lvl,rowOrder')  open curUpdaterowOrder  fetch next from curUpdaterowOrder into @level, @rowOrder  while @@fetch_status=0  begin  if exists(select 1 from ##Col where aaUseTree = 1)  begin  exec ('insert into ##TestRows   select ' + @newOrder + ', lvl, ((select isnull(max(dsplLvl),0) from   ##TestRows T where lvl = ' + @level + '-1 and L1_codeID = ' + @L1CodeID + ')   + dsplLvl), descr, basePeriod, attachNext, pageBreak, totals ' + @Columns + '  from ##TempRows where rowOrder = ' + @rowOrder + '')  end  else  begin  exec ('insert into ##TestRows   select ' + @newOrder + ', lvl, lvl, descr, basePeriod, attachNext, pageBreak, totals ' + @Columns + '  from ##TempRows where rowOrder = ' + @rowOrder + '')   end   set @newOrder = @newOrder + 1  fetch next from curUpdaterowOrder into @level, @rowOrder  end  close curUpdaterowOrder  deallocate curUpdaterowOrder   fetch next from CurCodeID into @L1CodeID  end  close CurCodeID  deallocate CurCodeID  exec ('insert into ##Rows   select rowOrder, lvl, dsplLvl, descr, basePeriod, attachNext, pageBreak, totals' + @Columns + '  from ##TestRows ')   if exists(select * from tempdb..sysobjects where name = '##TempRows' and xtype = 'U') drop table ##TempRows  if exists(select * from tempdb..sysobjects where name = '##TempRowOrder' and xtype = 'U') drop table ##TempRowOrder   DONE:  if @iDebug = 1   begin  print ''  print '*************************'  print '** aagMLRows finished **'  print '*************************'  print ''  end end    
GO
GRANT EXECUTE ON  [dbo].[aagMLRows] TO [DYNGRP]
GO
