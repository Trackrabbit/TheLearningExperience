SET QUOTED_IDENTIFIER OFF
GO
SET ANSI_NULLS OFF
GO
 create procedure [dbo].[dtaUpdateforDateChange]  @I_iJournalEntry int  = NULL,  @I_nHDRRecurringTrxSeq numeric(19,5) = NULL,  @I_sHDRSeries smallint = NULL,  @I_nDTAIndex numeric(19,5) = NULL,  @I_sDTASeries smallint = NULL,  @I_cOrigTrxSource char(13) = NULL,  @I_sReversing smallint = NULL,  @I_dTrxDate datetime = NULL,  @O_iErrorState                  int             = NULL output as  declare  @TRUE tinyint,  @FALSE tinyint,  @tReversing tinyint,  @sDTAGLStatus smallint,  @iSequenceNumber int,  @iSequenceLine int,  @iOrigSequenceNumber int,  @cOrigDocumentNumber char(21),  @cOrigControlNumber char(21),  @cDocumentNumber char(21),  @sDocumentType smallint,  @sOrigTrxType smallint,  @iAccountIndex int,  @cDTAReference char(25),  @cDTAGLReference char(25),  @sDTASeries smallint,  @iCursorError int,  @tLoopControl tinyint,  @iStatus int,  @iError int  select @O_iErrorState = 0  select  @TRUE = 1,  @FALSE = 0  while @tLoopControl is NULL begin  select @tLoopControl = 1   if @I_iJournalEntry is NULL or  @I_nHDRRecurringTrxSeq is NULL or  @I_sHDRSeries is NULL or  @I_nDTAIndex is NULL or  @I_sDTASeries is NULL or  @I_cOrigTrxSource is NULL or  @I_sReversing is NULL or  @I_dTrxDate is NULL  begin  select @O_iErrorState = 20989  break  end    if @I_sReversing = 1  select @tReversing = @TRUE  else  select @tReversing = @FALSE   exec @iStatus = dtaGetFinancialRef  @I_nDTAIndex,  @FALSE,  0.00,  @cDTAReference output,  @O_iErrorState output   select @iError = @@error   if @iStatus = 0 and @iError <> 0  select @iStatus = @iError   if (@iStatus <> 0) or (@O_iErrorState <> 0)  break   update  DTA10200  set  TRXDATE = @I_dTrxDate  where  DTASERIES = 2  and DTAREF = @cDTAReference   declare  TrxLine INSENSITIVE  cursor for select  DTA_GL_Status,  convert(int,SQNCLINE),  OrigSeqNum,  ORDOCNUM,  ORCTRNUM,  ORTRXTYP,  ACTINDX  from  GL10001  where  JRNENTRY = @I_iJournalEntry   open TrxLine   select @iCursorError = @@cursor_rows   if @iCursorError = 0  begin  deallocate TrxLine  end   else   begin  fetch next from   TrxLine  into  @sDTAGLStatus,  @iSequenceNumber,  @iOrigSequenceNumber,  @cOrigDocumentNumber,  @cOrigControlNumber,  @sOrigTrxType,  @iAccountIndex   while (@@fetch_status <> -1)  begin  if (@@fetch_status = -2)  begin  select @O_iErrorState = 20990  break  end   exec @iStatus = dtaGetGLKeyFields  @sDTAGLStatus,  @I_nHDRRecurringTrxSeq,  @iSequenceNumber,  @iOrigSequenceNumber,  @cOrigDocumentNumber,  @cOrigControlNumber,  @sOrigTrxType,  @I_cOrigTrxSource,  @I_sHDRSeries,  @I_sDTASeries,  1,  @I_nDTAIndex,  @sDTASeries output,  @cDTAReference output,  @iSequenceLine output,  @cDTAGLReference output,  @cDocumentNumber output,  @sDocumentType output,  @O_iErrorState output   select @iError = @@error   if @iStatus = 0 and @iError <> 0  select @iStatus = @iError   if (@iStatus <> 0) or (@O_iErrorState <> 0)  break   if @cDTAGLReference = ''   begin  update  DTA10100  set  TRXDATE = @I_dTrxDate  where  DTASERIES = @sDTASeries  and DTAREF = @cDTAReference  and ACTINDX = @iAccountIndex  and SEQNUMBR = @iSequenceLine   end    ELSE   begin  update  DTA10100  set  TRXDATE = @I_dTrxDate  where  DTASERIES = @sDTASeries  and DTA_GL_Reference = @cDTAGLReference  and ACTINDX = @iAccountIndex   end    fetch next from   TrxLine  into  @sDTAGLStatus,  @iSequenceNumber,  @iOrigSequenceNumber,  @cOrigDocumentNumber,  @cOrigControlNumber,  @sOrigTrxType,  @iAccountIndex   end    deallocate TrxLine   end   end   return(@iStatus)   
GO
GRANT EXECUTE ON  [dbo].[dtaUpdateforDateChange] TO [DYNGRP]
GO
