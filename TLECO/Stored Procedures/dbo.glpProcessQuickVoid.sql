SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
 create procedure [dbo].[glpProcessQuickVoid]  @iJournalEntry int  = NULL,  @iYear smallint = NULL,  @iFuncCurId char(15) = NULL,  @iFuncCurIdx smallint = NULL,  @iBreakDownAlloc smallint = NULL,  @iHistoryYear smallint = NULL as  declare  @lTrxStarted tinyint,  @lControlLoop tinyint,  @lReturnStatus int,  @lSqlError int,  @lError int,  @lAllocAcctIdx int,  @lLineMessages binary(4),  @lAllocAccount smallint,  @lWorkCursorCreated smallint,  @lAllocationCursorCreated smallint,  @lCompanyID char(5),  @lRelationID int,  @lUserLevel smallint,  @lAccessAllAccounts int,  @lAlsRegistered tinyint,  @lAllocSeqLine numeric(19,5),  @OrigPostingDate datetime,  @lSeqLine numeric(19,5),  @lAcctIdx int,  @lDesc char(31),  @lAcctType smallint,  @lOffsetAcctIdx int,  @lOffsetAcctType smallint,  @lSourceDocument      char(11),  @lReference           char(31),  @lTrxDate             datetime,  @lTrxSource           char(13),  @lLastUser            char(15),  @lLastDateEdited      datetime,  @lUserWhoPosted       char(15),  @lCurId               char(15),  @lCurIdx              smallint,  @lNoteIdx             numeric(19,5),  @lPeriodID            smallint,  @lDocDate datetime,  @lSeries smallint,  @BusFrmID char(15),  @nLedgerID int  select @lWorkCursorCreated = 0 select @lAllocationCursorCreated = 0 select @lLineMessages = 0 select @lError = 0 select @lReturnStatus = 0 select @lAllocAccount = 0 select @OrigPostingDate =  STR(DATEPART(month,GETDATE())) + '/' + STR(DATEPART(day,GETDATE())) + '/' + STR(DATEPART(year,GETDATE()))  select @lCompanyID = db_name()  if @@trancount = 0 begin  select @lTrxStarted = 1  begin transaction end  while (@lControlLoop is NULL) begin  select @lControlLoop = 1  if @iJournalEntry is NULL or  @iYear is NULL or   @iFuncCurId is NULL or  @iFuncCurIdx is NULL or  @iBreakDownAlloc is NULL or  @iHistoryYear is NULL  begin  select @lReturnStatus = 1  break  end   select  @lSourceDocument = SOURCDOC,  @lReference = REFRENCE,  @lTrxDate = TRXDATE,  @lTrxSource = TRXSORCE,  @lLastUser = LASTUSER,  @lLastDateEdited = LSTDTEDT,  @lUserWhoPosted = USWHPSTD,  @lCurId = CURNCYID,  @lNoteIdx = NOTEINDX,  @lPeriodID = PERIODID,  @lOffsetAcctIdx = OFFINDX,  @lOffsetAcctType = OFFACTYP,  @lDocDate = DOCDATE,  @lCurIdx = 0,  @BusFrmID = BSNSFMID,  @nLedgerID = 1  from  GL10100  where  JRNENTRY = @iJournalEntry   declare  WorkCursor  cursor Fast_Forward for   select  SQNCLINE,  ACTINDX,  DSCRIPTN,  ACCTTYPE  from  GL10101  where  JRNENTRY = @iJournalEntry  order by  SQNCLINE   open WorkCursor  select @lWorkCursorCreated = 1  if @@cursor_rows = 0  begin  select @lReturnStatus = 1  break  end   fetch   next   from  WorkCursor  into   @lSeqLine,   @lAcctIdx,   @lDesc,   @lAcctType   while @@fetch_status = 0  begin   if @lAcctType = 3   begin  select @lAllocSeqLine = @lSeqLine  select @lAllocAccount = 1  if @lAllocationCursorCreated = 1   begin  close AllocationCursor  deallocate AllocationCursor  select @lAllocationCursorCreated = 0  end    declare  AllocationCursor  cursor Fast_Forward for  select  DSTINDX  from  GL00103  where  ACTINDX = @lAcctIdx  open AllocationCursor  select @lAllocationCursorCreated = 1  if @@cursor_rows = 0  begin   select @lReturnStatus = 1  break  end  fetch  next  from  AllocationCursor  into  @lAllocAcctIdx  while @@fetch_status = 0  begin    exec @lReturnStatus = glpCreateVoidRecord  @iHistoryYear,  @iYear,  @iJournalEntry,  1,  @lSourceDocument,  @lReference,  @lDesc,  @lTrxDate,  @lTrxSource,  @lAllocAcctIdx,  @lLastUser,  @lLastDateEdited,  @lUserWhoPosted,  '',   0,   2,   '',   '',   '',   '',   @OrigPostingDate,   0,   @lCurId,  @lCurIdx,  '',   '',   0,   '',   '',   0,   @lNoteIdx,  0,   '',   0,   0,   0,   '',   @lSeqLine,  5,   @BusFrmID,  1,   @nLedgerID   if @iBreakDownAlloc = 1   begin  exec @lReturnStatus = glpUpdateAllocationRegister  5,   @iJournalEntry,  '',  '',  @lUserWhoPosted,  1,  @lAllocAcctIdx,  3,   0,  0,  @lTrxDate,  @lAllocSeqLine,  @lDesc,  0,   0,   0,   @lLineMessages,  @iFuncCurId,  @iFuncCurIdx,  @lLineMessages,  0,  0,  @lCurId,  @lCurIdx,  '',  0,  '',  '',  '',  '',  0,  0,  0,  0,  @lError output  end   select @lSqlError = @@error  if @lSqlError <> 0  begin  select @lReturnStatus = @lSqlError  break  end   if @lError <> 0  begin  select @lReturnStatus = @lError  break  end   fetch  next  from  AllocationCursor  into  @lAllocAcctIdx  select @lAllocSeqLine = @lAllocSeqLine + 1  end    end   else   begin  exec @lReturnStatus = glpCreateVoidRecord  @iHistoryYear,  @iYear,  @iJournalEntry,  1,  @lSourceDocument,  @lReference,  @lDesc,  @lTrxDate,  @lTrxSource,  @lAcctIdx,  @lLastUser,  @lLastDateEdited,  @lUserWhoPosted,  '',   0,   2,   '',   '',   '',   '',   @OrigPostingDate,   0,   @lCurId,  @lCurIdx,  '',   '',   0,   '',   '',   0,   @lNoteIdx,  0,   '',   0,   0,   0,   '',   @lSeqLine,  5,   @BusFrmID,  1,   @nLedgerID  end    if @lAllocAccount = 0 or (@lAllocAccount = 1 and @iBreakDownAlloc = 0)  begin  exec @lReturnStatus = glpUpdateAllocationRegister  5,   @iJournalEntry,  '',  '',  @lUserWhoPosted,  1,  @lAcctIdx,  @lAcctType,  0,  0,  @lTrxDate,  @lSeqLine,  @lDesc,  0,   0,   0,   @lLineMessages,  @iFuncCurId,  @iFuncCurIdx,  @lLineMessages,  0,  0,  @lCurId,  @lCurIdx,  '',  0,  '',  '',  '',  '',  0,  0,  0,  0,  @lError output  end   select @lSqlError = @@error  if @lSqlError <> 0  begin  select @lReturnStatus = @lSqlError  break  end   if @lError <> 0  begin  select @lReturnStatus = @lError  break  end  fetch   next   from  WorkCursor  into  @lSeqLine,   @lAcctIdx,   @lDesc,   @lAcctType   select @lAllocAccount = 0  end     select @lSeqLine = @lSeqLine + 500  if @lOffsetAcctType = 3   begin  select @lAllocSeqLine = @lSeqLine  select @lAllocAccount = 1   if @lAllocationCursorCreated = 1  begin  close AllocationCursor  deallocate AllocationCursor  select @lAllocationCursorCreated = 0  end  declare  AllocationCursor  cursor Fast_Forward for  select  DSTINDX  from  GL00103  where  ACTINDX = @lOffsetAcctIdx  open AllocationCursor  select @lAllocationCursorCreated = 1  if @@cursor_rows = 0  begin  close AllocationCursor  deallocate AllocationCursor   select @lReturnStatus = 1  break  end  fetch  next  from  AllocationCursor  into  @lAllocAcctIdx  while @@fetch_status = 0  begin    exec @lReturnStatus = glpCreateVoidRecord  @iHistoryYear,  @iYear,  @iJournalEntry,  1,  @lSourceDocument,  @lReference,  @lDesc,  @lTrxDate,  @lTrxSource,  @lAllocAcctIdx,  @lLastUser,  @lLastDateEdited,  @lUserWhoPosted,  '',   0,   2,   '',   '',   '',   '',   @OrigPostingDate,   0,   @lCurId,  @lCurIdx,  '',   '',   0,   '',   '',   0,   @lNoteIdx,  0,   '',   0,   0,   0,   '',   @lSeqLine,  5,   @BusFrmID,  0,   @nLedgerID   if @iBreakDownAlloc = 1   begin  exec @lReturnStatus = glpUpdateAllocationRegister  5,   @iJournalEntry,  '',  '',  @lUserWhoPosted,  1,  @lAllocAcctIdx,  3,   0,  0,  @lTrxDate,  @lAllocSeqLine,  @lDesc,  0,   0,   0,   @lLineMessages,  @iFuncCurId,  @iFuncCurIdx,  @lLineMessages,  0,  0,  @lCurId,  @lCurIdx,  '',  0,  '',  '',  '',  '',  0,  0,  0,  0,  @lError output  end  fetch  next  from  AllocationCursor  into  @lAllocAcctIdx  select @lAllocSeqLine = @lAllocSeqLine + 1  end    end   else   begin  exec @lReturnStatus = glpCreateVoidRecord  @iHistoryYear,  @iYear,  @iJournalEntry,  1,  @lSourceDocument,  @lReference,  @lDesc,  @lTrxDate,  @lTrxSource,  @lOffsetAcctIdx,  @lLastUser,  @lLastDateEdited,  @lUserWhoPosted,  '',   0,   2,   '',   '',   '',   '',   @OrigPostingDate,   0,   @lCurId,  @lCurIdx,  '',   '',   0,   '',   '',   0,   @lNoteIdx,  0,   '',   0,   0,   0,   '',   @lSeqLine,  5,   @BusFrmID,  0,   @nLedgerID  end    if @lAllocAccount = 0 or (@lAllocAccount = 1 and @iBreakDownAlloc = 0)  begin  exec @lReturnStatus = glpUpdateAllocationRegister  5,   @iJournalEntry,  '',  '',  @lUserWhoPosted,  1,  @lOffsetAcctIdx,  @lAcctType,  0,  0,  @lTrxDate,  @lSeqLine,  @lDesc,  0,   0,   0,   @lLineMessages,  @iFuncCurId,  @iFuncCurIdx,  @lLineMessages,  0,  0,  @lCurId,  @lCurIdx,  '',  0,  '',  '',  '',  '',  0,  0,  0,  0,  @lError output  end   select @lSqlError = @@error  if @lSqlError <> 0  begin  select @lReturnStatus = @lSqlError  break  end   if @lError <> 0  begin  select @lReturnStatus = @lError  break  end   exec @lReturnStatus = DYNAMICS..smGetAccountLevelSecurityInfo  @lCompanyID,  @lRelationID output,  @lUserLevel output,  @lAccessAllAccounts output,  @lAlsRegistered output   exec @lReturnStatus = glpGetAccountInfo  '',  0,  0,  @lUserWhoPosted,  @lRelationID,  @lUserLevel,  @lAccessAllAccounts,  @lAlsRegistered,  @lError output end   if @lWorkCursorCreated = 1 Begin   close WorkCursor  deallocate WorkCursor End  if @lAllocationCursorCreated = 1 Begin  close AllocationCursor  deallocate AllocationCursor  select @lAllocationCursorCreated = 0 End  return(@lReturnStatus)   
GO
GRANT EXECUTE ON  [dbo].[glpProcessQuickVoid] TO [DYNGRP]
GO
