SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
 create procedure [dbo].[icpBreakoutDists]   @I_iJournalEntry  int        = NULL,  @I_cBatchNumber char(15)        = NULL,  @I_cBatchSource char(15) = NULL,  @I_cOrigICID char(15)        = NULL,   @I_tVerifyOnly tinyint   = NULL,  @I_tMCRegistered tinyint  = NULL,   @i_tICEREnabled   tinyint  = NULL,  @O_iErrorState        int             = NULL  output as   declare   @TRUE tinyint,   @FALSE tinyint,  @MS_ITEM_14 int,   @tTransaction    int,  @tLoop    tinyint,  @POST    tinyint,  @POST_ALLOC tinyint,  @UNIT    tinyint,  @UNIT_ALLOC tinyint,  @MULTIPLY tinyint,  @DIVIDE tinyint,  @MaxSL numeric(19,5),  @DEFAULT_DATE    datetime,  @iBreakoutCount  int,  @iRelationID int,  @sUserLevel smallint,  @iAccessAllAccounts int,  @tALSRegistered tinyint,  @cCompanyID char(5),  @cDestICID char(5),  @vAccountFilterTable varchar(255),  @iStatus int,  @iError int,  @sORIGINATING smallint,   @sRateCalcMethod smallint,   @nXRate numeric(15,7),  @nDenomXRate numeric(15,7),  @cCurrencyID char(15),  @sMCTrxState smallint,   @sDecimalPlaces smallint,   @mDAmount numeric(19,5),   @mCAmount numeric(19,5),   @mFunctionalDebit numeric(19,5),  @mFunctionalCredit numeric(19,5),  @sCurrencyIndex smallint,  @cUserID char(15),  @sSTANDARD   smallint,  @cDBName char(10)  select  @O_iErrorState = 0  if @@trancount = 0 begin  select @tTransaction = 1  begin transaction  end   exec @iStatus = smGetMinDate @DEFAULT_DATE output  while (@tLoop is NULL) begin   select @tLoop = 1    if     @I_iJournalEntry  is NULL or  @I_cBatchNumber is NULL or   @I_cBatchSource is NULL or  @I_cOrigICID is NULL or   @I_tVerifyOnly is NULL or  @I_tMCRegistered  is NULL or   @i_tICEREnabled   is NULL or   @O_iErrorState        is NULL   begin  select @O_iErrorState = 20905   break  end    select   @TRUE  = 1,  @FALSE  = 0,  @MS_ITEM_14 = power(2, 21),  @POST  = 1,  @POST_ALLOC = 3,  @UNIT  = 2,  @UNIT_ALLOC = 4,  @MULTIPLY = 0,   @DIVIDE  = 1,  @MaxSL  = 0.0 ,  @iBreakoutCount  = 0,  @iRelationID  = 0,  @sUserLevel  = 0,  @iAccessAllAccounts  = 0,  @tALSRegistered  = 0,  @iStatus  = 0,  @iError   = 0,  @sORIGINATING  = 4,  @mFunctionalDebit = 0.0,  @mFunctionalCredit = 0.0,  @sSTANDARD   = 6   insert into   #LineItems   select   gl.INTERID,   comp.CompanyID,  comp.FunctionalCurrency,  gl.SQNCLINE,   gl.ACTINDX,   gl.DEBITAMT,   gl.CRDTAMNT,   gl.ORDBTAMT,   gl.ORCRDAMT,   gl.DSCRIPTN,   gl.CURRNIDX,  gl.RATETPID,  gl.EXGTBLID,  gl.XCHGRATE,   gl.EXCHDATE,  gl.TIME1,  gl.RTCLCMTD,  gl.GLLINVAL,   gl.ACCTTYPE,   gl.FXDORVAR,   gl.BALFRCLC,   gl.PSTNGTYP,  gl.DECPLACS,  gl.ORCTRNUM,  gl.ORDOCNUM,  gl.ORMSTRID,  gl.ORMSTRNM,  gl.ORTRXTYP,  gl.ORTRXDESC,  gl.OrigSeqNum,  gl.DTA_GL_Status,  comp.LineMessages2,  comp.DatabaseName,  @FALSE,       gl.DENXRATE,  gl.MCTRXSTT,  gl.LNESTAT,  gl.CorrespondingUnit  from   GL10001 gl,   #Company comp  where  @I_iJournalEntry = gl.JRNENTRY  and comp.IntercompanyID = gl.INTERID   insert into #Breakout  (IntercompanyID,  DestICID,  UserAccess,  FunctionalDebitTotal,  FunctionalCreditTotal,  OriginatingDebitTotal,  OriginatingCreditTotal,  CompanyID,  AccountIndex,  ExchangeRate,   DecimalPlaces,  RateCalculationMethod,  CurrencyIndex,  RateTypeID,  ExchangeTableID,   ExchangeDate,  ExchangeTime,  DenomExchangeRate,  MCTrxState,  CorrespondingUnit)   select  li.IntercompanyID,       li.IntercompanyID,      0,        0.0,        0.0,        case   when (sum(li.OriginatingDebit) - sum(li.OriginatingCredit)) < 0 then  isnull((sum(li.OriginatingDebit) - sum(li.OriginatingCredit)) * -1,0.0)   else  0.0  end,  case   when (sum(li.OriginatingDebit) - sum(li.OriginatingCredit)) > 0 then  isnull(sum(li.OriginatingDebit) - sum(li.OriginatingCredit),0.0)    else  0.0  end,  0,        0,         0.0,         0,        0,          0,        '',        '',            @DEFAULT_DATE,       @DEFAULT_DATE,          0.0,        0,           ''        from  #LineItems li  where   li.IntercompanyID <> @I_cOrigICID   and   (li.AccountType <> @UNIT   and   li.AccountType <> @UNIT_ALLOC)   group by   li.IntercompanyID  having   (sum(li.OriginatingDebit) - sum(li.OriginatingCredit)) <> 0.0    insert into #Breakout  (IntercompanyID,  DestICID,  UserAccess,  FunctionalDebitTotal,   FunctionalCreditTotal,   OriginatingDebitTotal,  OriginatingCreditTotal,  CompanyID,  AccountIndex,  ExchangeRate,  DecimalPlaces,  RateCalculationMethod,  CurrencyIndex,  RateTypeID,  ExchangeTableID,   ExchangeDate,  ExchangeTime,  DenomExchangeRate,  MCTrxState,  CorrespondingUnit)    select  @I_cOrigICID,        li.IntercompanyID,         0,         0.0,        0.0,        case   when (sum(li.OriginatingDebit) - sum(li.OriginatingCredit))  > 0 then  isnull(sum(li.OriginatingDebit) - sum(li.OriginatingCredit),0.0)    else  0.0  end,  case   when (sum(li.OriginatingDebit) - sum(li.OriginatingCredit)) < 0 then  isnull((sum(li.OriginatingDebit) - sum(li.OriginatingCredit)) * -1,0.0)   else  0.0  end,  0,         0,          0.0,            0,        0,          0,        '',        '',            @DEFAULT_DATE,       @DEFAULT_DATE,          0.0,           0,           ''        from   #LineItems li  where   li.IntercompanyID <> @I_cOrigICID   and   (li.AccountType <> @UNIT   and   li.AccountType <> @UNIT_ALLOC)   group by   li.IntercompanyID   having   (sum(li.OriginatingDebit) - sum(li.OriginatingCredit)) <> 0.0    update #Breakout  set  ExchangeRate   = #LineItems.ExchangeRate,   DecimalPlaces  = #LineItems.DecimalPlaces,   RateCalculationMethod  = #LineItems.RateCalculationMethod,   CurrencyIndex  = #LineItems.CurrencyIndex,  RateTypeID  = #LineItems.RateTypeID,  ExchangeTableID  = #LineItems.ExchangeTableID,   ExchangeDate  = #LineItems.ExchangeDate,  ExchangeTime  = #LineItems.ExchangeTime,   DenomExchangeRate = #LineItems.DenomExchangeRate,  MCTrxState  = #LineItems.MCTrxState   from   #LineItems  where   #Breakout.IntercompanyID = #LineItems.IntercompanyID   and   (#LineItems.AccountType <> @UNIT   and   #LineItems.AccountType <> @UNIT_ALLOC  and   #LineItems.AccountType <> 0)   if @I_tVerifyOnly = @FALSE  begin  update   #Breakout  set   AccountIndex = isnull(  (select  icsetup.DSTTOIDX  from   DYNAMICS..IC40100 icsetup   where  icsetup.ORCOMID = @I_cOrigICID   and icsetup.DSTCOMID = #Breakout.DestICID), 0)  where   #Breakout.IntercompanyID = #Breakout.DestICID  and #Breakout.OriginatingCreditTotal <> 0   update  #Breakout  set   AccountIndex = isnull(   (select  icsetup.DSTFRIDX  from   DYNAMICS..IC40100 icsetup  where  icsetup.ORCOMID = @I_cOrigICID   and icsetup.DSTCOMID = #Breakout.DestICID), 0)  where   #Breakout.IntercompanyID = #Breakout.DestICID   and #Breakout.OriginatingDebitTotal <> 0    update   #Breakout  set   AccountIndex = isnull(  (select   icsetup.ORGFRIDX   from  DYNAMICS..IC40100 icsetup   where  icsetup.ORCOMID = @I_cOrigICID   and icsetup.DSTCOMID = #Breakout.DestICID), 0)   where   #Breakout.IntercompanyID = @I_cOrigICID  and #Breakout.OriginatingDebitTotal <> 0    update   #Breakout  set   AccountIndex = isnull(  (select   icsetup.ORGTOIDX  from  DYNAMICS..IC40100 icsetup  where   icsetup.ORCOMID = @I_cOrigICID   and icsetup.DSTCOMID = #Breakout.DestICID), 0)   where   #Breakout.IntercompanyID = @I_cOrigICID  and #Breakout.OriginatingCreditTotal <> 0    exec @iStatus = DYNAMICS..smGetAccountLevelSecurityInfo  @I_cOrigICID,  @iRelationID output,  @sUserLevel  output,  @iAccessAllAccounts output,  @tALSRegistered output   select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  end     declare DestinationCompany cursor for  select   distinct #Breakout.IntercompanyID, DestICID, isnull(sm.USERID,''), DatabaseName  from   #Breakout,   #Company,  DYNAMICS..SY01500 cm   LEFT OUTER JOIN  DYNAMICS..SY60100 sm  on (cm.CMPANYID =sm.CMPANYID   and   sm.USERID = system_user)  where   cm.INTERID  = #Breakout.IntercompanyID  and #Breakout.IntercompanyID = #Company.IntercompanyID   open DestinationCompany   if @@cursor_rows <>  0  begin   fetch next from  DestinationCompany   into   @cCompanyID, @cDestICID, @cUserID, @cDBName   while (@@fetch_status <> -1)  begin  if @I_tVerifyOnly = @FALSE  begin   if (@tALSRegistered = @TRUE) and   (@iAccessAllAccounts = @FALSE) and  (@cUserID <> '')  begin  select @vAccountFilterTable =   case when @sUserLevel = 0 then  rtrim(@cDBName) + '..GL00100F1 AFT '  else  rtrim(@cDBName) + '..GL00100F' + str(@sUserLevel,1) + ' AFT '  end   exec('update #Breakout set AccountIndex = 0 WHERE IntercompanyID = ''' + @cCompanyID +   ''' and DestICID = ''' + @cDestICID +   ''' and AccountIndex not in   (select AFT.ACTINDX from ' + @vAccountFilterTable +   'where AFT.ACTINDX = AccountIndex)')  end  end     if @I_tMCRegistered = @TRUE   begin     select distinct   @sRateCalcMethod  = isnull(RateCalculationMethod,0),  @nXRate   = isnull(ExchangeRate,0.0),   @nDenomXRate  = isnull(DenomExchangeRate,0.0),   @cCurrencyID  = '',   @sMCTrxState  = isnull(MCTrxState,0),   @sDecimalPlaces  = isnull(DecimalPlaces,0),   @mDAmount     = isnull(OriginatingDebitTotal,0.0),   @mCAmount     = isnull(OriginatingCreditTotal,0.0),   @sCurrencyIndex   = isnull(CurrencyIndex,0),  @mFunctionalDebit = 0.0,  @mFunctionalCredit = 0.0  from   #Breakout  where   IntercompanyID  =   @cCompanyID   and DestICID  =  @cDestICID  if @sCurrencyIndex = (select CurrencyIndex from #TRXHeader)   update   #Breakout  set   FunctionalDebitTotal = OriginatingDebitTotal,   FunctionalCreditTotal = OriginatingCreditTotal   where   IntercompanyID  =   @cCompanyID   and DestICID  =  @cDestICID  else  begin  exec @iStatus = mcCalculateAmount  @sRateCalcMethod,  @sORIGINATING,  @nXRate,  @nDenomXRate,  @cCurrencyID,  @sMCTrxState,  @sDecimalPlaces,  '',    @mDAmount,   @mFunctionalDebit output,   @O_iErrorState output   select @iError = @@error  if @iStatus  = 0 and @iError <> 0  select @iStatus = @iError   if @iStatus <> 0 or @O_iErrorState <> 0   break   if (@mCAmount <> 0.0)  begin  exec @iStatus = mcCalculateAmount  @sRateCalcMethod,  @sORIGINATING,  @nXRate,  @nDenomXRate,  @cCurrencyID,  @sMCTrxState,  @sDecimalPlaces,  '',    @mCAmount,   @mFunctionalCredit output,   @O_iErrorState output   select @iError = @@error  if @iStatus  = 0 and @iError <> 0  select @iStatus = @iError   if @iStatus <> 0 or @O_iErrorState <> 0   break  end   update   #Breakout   set   FunctionalDebitTotal =   case   when (@mFunctionalDebit-@mFunctionalCredit) > 0 then  (@mFunctionalDebit-@mFunctionalCredit)  when (@mFunctionalDebit-@mFunctionalCredit) <= 0 then   0.0   end,  FunctionalCreditTotal =   case   when (@mFunctionalDebit-@mFunctionalCredit) > 0 then  0.0  when (@mFunctionalDebit-@mFunctionalCredit) <= 0 then  abs(@mFunctionalDebit-@mFunctionalCredit)  end  where   IntercompanyID  =   @cCompanyID  and DestICID  =  @cDestICID  end    end     fetch next from  DestinationCompany   into  @cCompanyID, @cDestICID, @cUserID, @cDBName  end    end    deallocate DestinationCompany    if @I_tMCRegistered = @FALSE   begin  update #Breakout  set FunctionalDebitTotal = OriginatingDebitTotal,  FunctionalCreditTotal = OriginatingCreditTotal  end   if @i_tICEREnabled = @TRUE  begin  update   #Breakout  set   CorrespondingUnit = DestICID  where   IntercompanyID = @I_cOrigICID   update   #Breakout  set   CorrespondingUnit = @I_cOrigICID  where   DestICID = IntercompanyID   end   select @MaxSL =max(SequenceLine)  from  #LineItems   insert into   #LineItems  select distinct  brkout.IntercompanyID,   comp.CompanyID,  comp.FunctionalCurrency,  brkout.SequenceLine + @MaxSL,   brkout.AccountIndex,   brkout.FunctionalDebitTotal,   brkout.FunctionalCreditTotal,   brkout.OriginatingDebitTotal,   brkout.OriginatingCreditTotal,   ' ',      brkout.CurrencyIndex,  brkout.RateTypeID,  brkout.ExchangeTableID,  brkout.ExchangeRate,   brkout.ExchangeDate,  brkout.ExchangeTime,   brkout.RateCalculationMethod,  0x00000000,    @POST,        0,      0,       0,     brkout.DecimalPlaces,     '',  '',  '',  '',  0,  ' ',  0,  0,  comp.LineMessages2,  comp.DatabaseName,  @TRUE,       brkout.DenomExchangeRate,   brkout.MCTrxState,  @sSTANDARD,  brkout.CorrespondingUnit   from   #Breakout brkout,  #Company comp  where   comp.IntercompanyID = brkout.IntercompanyID  select  @iBreakoutCount = @@rowcount    update   #LineItems   set   ExchangeRate = 0.0  from  #Company  where   #LineItems.IntercompanyID = #Company.IntercompanyID   and #LineItems.FunctionalCurrency  =   (select  CurrencyID   from   #TRXHeader)   if @iBreakoutCount = 0  break   if @I_tVerifyOnly = @FALSE   begin   update   #LineItems   set   LineMessages2  = (LineMessages2 | @MS_ITEM_14)   where   AccountIndex = 0   end    end   if @O_iErrorState <> 0 begin   if @tTransaction = 1  rollback transaction  end else if @tTransaction = 1  commit transaction  return (@iStatus)    
GO
GRANT EXECUTE ON  [dbo].[icpBreakoutDists] TO [DYNGRP]
GO
