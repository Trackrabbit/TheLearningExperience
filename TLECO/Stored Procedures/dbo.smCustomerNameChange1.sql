SET QUOTED_IDENTIFIER OFF
GO
SET ANSI_NULLS ON
GO
create procedure [dbo].[smCustomerNameChange1]  @I_charStartCustomer char(20),  @I_charEndCustomerName char(64),  @O_iErrorState int = NULL  output with encryption as set transaction isolation level read uncommitted set nocount on declare  @CUSTNAME char(255), @tTransaction tinyint, @tLoop tinyint, @iStatus int, @cStartCustomer char(50), @cEndCustomerName char(80) exec @iStatus = smFormatStringsForExecs @I_vInputString  = @I_charStartCustomer, @O_cOutputString = @cStartCustomer output, @O_iErrorState	 = @O_iErrorState output if @iStatus <> 0 or @O_iErrorState <> 0 begin set @O_iErrorState = 90 return end exec @iStatus = smFormatStringsForExecs @I_vInputString  = @I_charEndCustomerName, @O_cOutputString = @cEndCustomerName output, @O_iErrorState	 = @O_iErrorState output if @iStatus <> 0 or @O_iErrorState <> 0 begin set @O_iErrorState = 91 return end select @O_iErrorState 	 = 0 if @@trancount = 0    begin select @tTransaction = 1 begin transaction end while ( @tLoop is NULL ) begin select @tLoop = 1 if	@I_charStartCustomer	is NULL or @I_charEndCustomerName	is NULL or @cStartCustomer		is NULL or @cEndCustomerName	is NULL begin select @O_iErrorState = 1		 break end  if exists (select * from sysobjects where name = 'RM_Customer_MSTR_NA') ALTER TABLE dbo.RM00101 DROP CONSTRAINT RM_Customer_MSTR_NA  if @@error <> 0  begin select @O_iErrorState = 2	 break end  if exists (select * from sysobjects where name = 'RM_NationalAccounts_MSTR_FKC') ALTER TABLE dbo.RM00105  DROP CONSTRAINT RM_NationalAccounts_MSTR_FKC  if @@error <> 0  begin select @O_iErrorState = 3	 break end  if exists (select * from sysobjects where id = object_id('dbo.taCustomerInsert')) alter table RM00101 disable trigger taCustomerInsert if @@error <> 0  begin select @O_iErrorState = 4	 break end if exists (select * from sysobjects where id = object_id('dbo.taCustomerAddressInsert')) alter table RM00102 disable trigger taCustomerAddressInsert if @@error <> 0  begin select @O_iErrorState = 5	 break end declare ta_CDMCursor insensitive CURSOR for select 'update '+o.name+' set CUSTNAME =' + rtrim(@cEndCustomerName) + ' where CUSTNMBR = ' + rtrim(@cStartCustomer) from sysobjects o, syscolumns c where	o.id = c.id and o.type = 'U' and c.name = 'CUSTNAME' and o.name in (select o.name from sysobjects o, syscolumns c where o.id = c.id and o.type = 'U' and c.name = 'CUSTNMBR') order by o.name set nocount on OPEN ta_CDMCursor FETCH NEXT FROM ta_CDMCursor INTO @CUSTNAME WHILE (@@FETCH_STATUS <> -1) begin exec (@CUSTNAME) if @@error <> 0  begin select @O_iErrorState = 6	 break end  FETCH NEXT FROM ta_CDMCursor INTO @CUSTNAME end DEALLOCATE ta_CDMCursor if @O_iErrorState <> 0 break update a set ORMSTRNM = @I_charEndCustomerName from GL10001 a, GL10000 b where 	a.ORMSTRID = @I_charStartCustomer and a.JRNENTRY = b.JRNENTRY and b.SERIES = 3 if @@error <> 0  begin select @O_iErrorState = 7	 break end update GL20000 set ORMSTRNM = @I_charEndCustomerName where ORMSTRID = @I_charStartCustomer and SERIES = 3 if @@error <> 0  begin select @O_iErrorState = 8	 break end update GL30000 set ORMSTRNM = @I_charEndCustomerName where ORMSTRID = @I_charStartCustomer and SERIES = 3 if @@error <> 0  begin select @O_iErrorState = 9	 break end update PJOURNAL set ORMSTRNM = @I_charEndCustomerName where ORMSTRID = @I_charStartCustomer if @@error <> 0  begin select @O_iErrorState = 10	 break end  update CM20300 set RcvdFrom = @I_charEndCustomerName where CMLinkID = @I_charStartCustomer if @@error <> 0  begin select @O_iErrorState = 11	 break end  declare ta_CDMCursor insensitive CURSOR for select 'update '+o.name+' set STCUSTNM =' + rtrim(@cEndCustomerName) +  ' where STCUSTID = ' + rtrim(@cStartCustomer) from sysobjects o, syscolumns c where	o.id = c.id and o.type = 'U' and c.name = 'STCUSTNM' and o.name <> 'ICJC0125' order by o.name set nocount on OPEN ta_CDMCursor FETCH NEXT FROM ta_CDMCursor INTO @CUSTNAME WHILE (@@FETCH_STATUS <> -1) begin exec (@CUSTNAME) if @@error <> 0  begin select @O_iErrorState = 12	 break end  FETCH NEXT FROM ta_CDMCursor INTO @CUSTNAME end DEALLOCATE ta_CDMCursor if @O_iErrorState <> 0 break declare ta_CDMCursor insensitive CURSOR for select 'update '+o.name+' set ENCSTNAM =' + rtrim(@cEndCustomerName) + ' where ENCUSTID = ' + rtrim(@cStartCustomer)  from sysobjects o, syscolumns c where	o.id = c.id and o.type = 'U' and c.name = 'ENCSTNAM' and o.name <> 'ICJC0125' order by o.name set nocount on OPEN ta_CDMCursor FETCH NEXT FROM ta_CDMCursor INTO @CUSTNAME WHILE (@@FETCH_STATUS <> -1) begin exec (@CUSTNAME) if @@error <> 0  begin select @O_iErrorState = 13	 break end  FETCH NEXT FROM ta_CDMCursor INTO @CUSTNAME end DEALLOCATE ta_CDMCursor if @O_iErrorState <> 0 break update RM00101 set STMTNAME = @I_charEndCustomerName where CUSTNMBR = @I_charStartCustomer if @@error <> 0  begin select @O_iErrorState = 14	 break end update RM00101 set SHRTNAME = substring(@I_charEndCustomerName, 1, 15)  where CUSTNMBR = @I_charStartCustomer if @@error <> 0  begin select @O_iErrorState = 30	 break end declare ta_CDMCursor insensitive CURSOR for select 'update '+o.name+' set ShipToName =' + rtrim(@cEndCustomerName) + ' where CUSTNMBR = ' + rtrim(@cStartCustomer)  from sysobjects o, syscolumns c where	o.id = c.id and o.type = 'U' and c.name = 'ShipToName'  and o.name <> 'SOP10200' and o.name <> 'SOP30300' order by o.name set nocount on OPEN ta_CDMCursor FETCH NEXT FROM ta_CDMCursor INTO @CUSTNAME   WHILE (@@FETCH_STATUS <> -1) begin exec (@CUSTNAME  ) if @@error <> 0  begin select @O_iErrorState = 15	 break end  FETCH NEXT FROM ta_CDMCursor INTO @CUSTNAME   end DEALLOCATE ta_CDMCursor if @O_iErrorState <> 0 break update a set a.ShipToName = @I_charEndCustomerName from SOP10200 a, SOP10100 b where a.SOPTYPE = b.SOPTYPE and a.SOPNUMBE = b.SOPNUMBE and b.CUSTNMBR = @I_charStartCustomer if @@error <> 0  begin select @O_iErrorState = 20	 break end  update a set a.ShipToName = @I_charEndCustomerName from SOP30300 a, SOP30200 b where a.SOPTYPE = b.SOPTYPE and a.SOPNUMBE = b.SOPNUMBE and b.CUSTNMBR = @I_charStartCustomer if @@error <> 0  begin select @O_iErrorState = 21	 break end 	 if exists (select * from sysobjects where id = object_id('dbo.ICJC0001')  and sysstat & 0xf = 3) begin update ICJC0001 set CUSTNAME = @I_charStartCustomer where CUSTOMERID_I = @I_charStartCustomer if @@error <> 0  begin select @O_iErrorState = 22	 break end end if exists (select * from sysobjects where id = object_id('dbo.ICJC0125')  and sysstat & 0xf = 3) begin update ICJC0125 set STCUSTNM = @I_charStartCustomer where STARTJCCUSTID_I = @I_charStartCustomer if @@error <> 0  begin select @O_iErrorState = 23	 break end update ICJC0125 set ENCSTNAM = @I_charStartCustomer where ENDJCCUSTID_I = @I_charStartCustomer if @@error <> 0  begin select @O_iErrorState = 24	 break end end ALTER TABLE dbo.RM00101 WITH NOCHECK  ADD CONSTRAINT RM_Customer_MSTR_NA CHECK  ((CPRCSTNM <> '' AND BALNCTYP = 0) or  (CPRCSTNM = '' AND BALNCTYP = 1) or  (CPRCSTNM = '' AND BALNCTYP = 0)) if @@error <> 0  begin select @O_iErrorState = 16	 break end  ALTER TABLE dbo.RM00105 ADD  CONSTRAINT RM_NationalAccounts_MSTR_FKC FOREIGN KEY  ( CPRCSTNM) REFERENCES dbo.RM00101 (CUSTNMBR) if @@error <> 0  begin select @O_iErrorState = 17	 break end  end  if exists (select * from sysobjects where id = object_id('dbo.taCustomerInsert')) alter table RM00101 enable trigger taCustomerInsert if @@error <> 0  begin select @O_iErrorState = 18	 end if exists (select * from sysobjects where id = object_id('dbo.taCustomerAddressInsert')) alter table RM00102 enable trigger taCustomerAddressInsert if @@error <> 0  begin select @O_iErrorState = 19	 end if @O_iErrorState <> 0 begin if @tTransaction = 1 rollback transaction end else if @tTransaction = 1 begin commit transaction end return  
GO
GRANT EXECUTE ON  [dbo].[smCustomerNameChange1] TO [DYNGRP]
GO
