SET QUOTED_IDENTIFIER OFF
GO
SET ANSI_NULLS ON
GO
 create procedure [dbo].[rmHATBCalculatePaymentTotals]  @I_tUsingDocumentDate tinyint  = NULL,  @I_dStartDate datetime = NULL,  @I_dEndDate datetime = NULL,  @I_tExcludeUnpostedAppldCrDocs  tinyint  = NULL,  @I_cFunctionalCurrency char(15) = NULL,  @I_tMCRegistered tinyint  = NULL,  @I_sPrintCurrencyIn smallint = NULL,  @I_nReportingExchangeRate numeric(15,7) = NULL,  @I_sReportingRateCalcMethod smallint = NULL,  @I_sReportingDecimalPlaces smallint = NULL,  @O_iErrorState                  int             = NULL output as  declare  @cDocumentNumber char(21),  @sRMDocumentTypeAll smallint,  @tStatus tinyint,  @iStatus                 int,  @nCurrentTrxAmount numeric(19,5),  @nOrigCurrentTrxAmount numeric(19,5),  @nRevalCurTrxAmtAdj numeric(19,5),  @nRevalDiscAmtAvailAdj numeric(19,5),  @nAppliedAmount numeric(19,5),  @nRealizedGainLoss numeric(19,5),  @nOriginatingAppliedAmount numeric(19,5),  @nActualApplyToAmount numeric(19,5),  @nCalcAmount numeric(19,5),  @cCurrencyID char(15),  @cApplyToCurrencyID char(15),  @cApplyFromCurrencyID char(15),  @dApplyDate datetime,  @sRateCalcMethod smallint,  @sDecimalPlaces smallint,  @nExchangeRate numeric(15,7),  @nDenomExchangeRate numeric(15,7),  @sMCTrxState smallint,  @iCursorError int,  @iError                  int,  @tLoopControl            tinyint,  @vCurrentTrxAmount varchar(30),  @vOrigCurrentTrxAmount varchar(30),  @vRMDocumentTypeAll varchar(2),  @vDiscAmtAvailAdj varchar(30),  @iTemp int  select @O_iErrorState = 0  select   @cDocumentNumber = '',  @sRMDocumentTypeAll = 0,  @tStatus  = 0,  @iStatus  = 0,  @nCurrentTrxAmount = 0.00,  @nOrigCurrentTrxAmount = 0.00,  @nRevalCurTrxAmtAdj = 0.00,  @nRevalDiscAmtAvailAdj = 0.00,  @nAppliedAmount  = 0.00,  @nRealizedGainLoss = 0.00,  @nOriginatingAppliedAmount = 0.00,  @nCalcAmount  = 0.00,  @cCurrencyID  = '',  @cApplyToCurrencyID = '',  @cApplyFromCurrencyID = '',  @dApplyDate  = '',  @sRateCalcMethod = 0,  @sDecimalPlaces  = 0,  @nExchangeRate  = 0.00,  @nDenomExchangeRate = 0.00,  @sMCTrxState  = 0,  @iCursorError  = 0,  @iError   = 0  while @tLoopControl is NULL begin  select @tLoopControl = 1   if  @I_tUsingDocumentDate is NULL or  @I_dStartDate is NULL or  @I_dEndDate is NULL or  @I_tExcludeUnpostedAppldCrDocs is NULL or  @I_cFunctionalCurrency   is NULL or  @I_tMCRegistered is NULL or  @I_sPrintCurrencyIn is NULL or  @I_nReportingExchangeRate is NULL or  @I_sReportingRateCalcMethod is NULL or  @I_sReportingDecimalPlaces is NULL  begin  select @O_iErrorState = 21050  break  end    CREATE index DocumentNumberIndex  on #TransactionTEMP(DocumentNumber)   declare  PaymentCursor  cursor for select  DocumentNumber,  RMDocumentTypeAll,  CurrentTrxAmount,  RevalCurrentTrxAmountAdj,  RevalDiscAmountAvailAdj,  OrigCurrentTrxAmount,  CurrencyID,  Status  from  #TransactionTEMP  where  #TransactionTEMP.RMDocumentTypeAll > 6  and #TransactionTEMP.CustomerType = 0    open PaymentCursor   fetch next from   PaymentCursor  into   @cDocumentNumber,  @sRMDocumentTypeAll,  @nCurrentTrxAmount,  @nRevalCurTrxAmtAdj,  @nRevalDiscAmtAvailAdj,   @nOrigCurrentTrxAmount,  @cCurrencyID,  @tStatus   while (@@fetch_status <> -1)  begin  if (@@fetch_status = -2)  begin  select @O_iErrorState = 21051  break  end   set rowcount 1   select   @nRevalCurTrxAmtAdj = @nRevalCurTrxAmtAdj +   (CASE when @I_sPrintCurrencyIn = 1 and @I_tMCRegistered = 1 then  CASE when @I_sReportingRateCalcMethod = 1 then  ISNULL(round((A.Total_Gain_or_Loss_on_Cu * @I_nReportingExchangeRate), @I_sReportingDecimalPlaces), 0.00)  else  ISNULL(round((A.Total_Gain_or_Loss_on_Cu / @I_nReportingExchangeRate), @I_sReportingDecimalPlaces), 0.00)  end  else  ISNULL(A.Total_Gain_or_Loss_on_Cu, 0.00)  end)  from  MC020104 A with (NOLOCK)  where  A.CURNCYID = @cCurrencyID  and  A.DOCNUMBR = @cDocumentNumber  and A.DOCTYPE  = @sRMDocumentTypeAll  order by A.RVLUDATE DESC, A.SEQNUMBR DESC    set rowcount 0   select @nCurrentTrxAmount = @nCurrentTrxAmount + @nRevalCurTrxAmtAdj   if @cCurrencyID = '' or @cCurrencyID = @I_cFunctionalCurrency  select @nOrigCurrentTrxAmount = @nCurrentTrxAmount + @nRevalCurTrxAmtAdj  else  select @nOrigCurrentTrxAmount = @nOrigCurrentTrxAmount   if @tStatus = 0    begin   declare  AppliedOpenCursor INSENSITIVE  cursor for select  APPTOAMT,  RLGANLOS,  ORAPTOAM,  ActualApplyToAmount,  CURNCYID,  FROMCURR,  DATE1  from  RM20201  where  RM20201.APFRDCNM = @cDocumentNumber  and RM20201.APFRDCTY = @sRMDocumentTypeAll  and  ((@I_tUsingDocumentDate = 1  and (DATE1 < @I_dStartDate or DATE1 > @I_dEndDate  or  APTODCDT < @I_dStartDate or APTODCDT > @I_dEndDate))  or  (@I_tUsingDocumentDate = 0  and (GLPOSTDT < @I_dStartDate or GLPOSTDT > @I_dEndDate  or  ApplyToGLPostDate < @I_dStartDate or ApplyToGLPostDate > @I_dEndDate)))  and ((@I_tExcludeUnpostedAppldCrDocs = 1  and POSTED = 1)  or (@I_tExcludeUnpostedAppldCrDocs = 0))   open AppliedOpenCursor   fetch next from   AppliedOpenCursor  into   @nAppliedAmount,  @nRealizedGainLoss,  @nOriginatingAppliedAmount,  @nActualApplyToAmount,  @cApplyToCurrencyID,  @cApplyFromCurrencyID,  @dApplyDate   while (@@fetch_status <> -1)  begin  if (@@fetch_status = -2)  begin  select @O_iErrorState = 21052  break  end   if @I_sPrintCurrencyIn = 1 and @I_tMCRegistered = 1  begin  if @I_sReportingRateCalcMethod = 1  begin  select @nCurrentTrxAmount =  @nCurrentTrxAmount +   ISNULL(ROUND((@nAppliedAmount * @I_nReportingExchangeRate),@I_sReportingDecimalPlaces),0.00) +   ISNULL(ROUND((@nRealizedGainLoss * @I_nReportingExchangeRate),@I_sReportingDecimalPlaces),0.00)  end  else  begin  select @nCurrentTrxAmount =  @nCurrentTrxAmount +   ISNULL(ROUND((@nAppliedAmount / @I_nReportingExchangeRate),@I_sReportingDecimalPlaces),0.00) +   ISNULL(ROUND((@nRealizedGainLoss / @I_nReportingExchangeRate),@I_sReportingDecimalPlaces),0.00)  end  end   else    begin  select @nCurrentTrxAmount = @nCurrentTrxAmount + @nAppliedAmount + @nRealizedGainLoss  end   if @cCurrencyID = '' or @cCurrencyID = @I_cFunctionalCurrency  begin  if @I_sPrintCurrencyIn = 1 and @I_tMCRegistered = 1  begin  if @I_sReportingRateCalcMethod = 1  begin  select @nOrigCurrentTrxAmount = @nOrigCurrentTrxAmount +   ISNULL(ROUND((@nAppliedAmount * @I_nReportingExchangeRate),@I_sReportingDecimalPlaces),0.00) +   ISNULL(ROUND((@nRealizedGainLoss * @I_nReportingExchangeRate),@I_sReportingDecimalPlaces),0.00)  end  else  begin  select @nOrigCurrentTrxAmount = @nOrigCurrentTrxAmount +   ISNULL(ROUND((@nAppliedAmount / @I_nReportingExchangeRate),@I_sReportingDecimalPlaces),0.00) +   ISNULL(ROUND((@nRealizedGainLoss / @I_nReportingExchangeRate),@I_sReportingDecimalPlaces),0.00)  end  end   else    begin  select @nOrigCurrentTrxAmount = @nOrigCurrentTrxAmount + @nAppliedAmount + @nRealizedGainLoss  end  end   else if (@cApplyFromCurrencyID <> '' and @cApplyFromCurrencyID <> @I_cFunctionalCurrency) and   (@cApplyToCurrencyID <> '' and @cApplyToCurrencyID <> @I_cFunctionalCurrency)  begin  select @nOrigCurrentTrxAmount = @nOrigCurrentTrxAmount + @nActualApplyToAmount  end   else  begin   if @cApplyToCurrencyID = '' or @cApplyToCurrencyID = @I_cFunctionalCurrency  begin  set rowcount 1   select  @sRateCalcMethod = RTCLCMTD,  @nExchangeRate = XCHGRATE,  @nDenomExchangeRate = DENXRATE,  @sMCTrxState = MCTRXSTT  from  MC020104 with (NOLOCK)  where  CURNCYID = @cApplyFromCurrencyID  and DOCNUMBR = @cDocumentNumber  and DOCTYPE  = @sRMDocumentTypeAll  and RVLUDATE <= @dApplyDate  order by RVLUDATE DESC, SEQNUMBR DESC   if @@rowcount <> 1  begin  select  @sRateCalcMethod = RTCLCMTD,  @nExchangeRate = XCHGRATE,  @nDenomExchangeRate = DENXRATE,  @sMCTrxState = MCTRXSTT  from  MC020102 with (NOLOCK)  where  DOCNUMBR = @cDocumentNumber  and RMDTYPAL  = @sRMDocumentTypeAll   end   set rowcount 0   select  @sDecimalPlaces = ISNULL(DECPLCUR,3) - 1  from  DYNAMICS..MC40200 with (NOLOCK)  where  CURNCYID = @cApplyFromCurrencyID   Exec @iStatus = mcCalculateAmount  @sRateCalcMethod,  3,     @nExchangeRate,  @nDenomExchangeRate,  '',       @sMCTrxState,  @sDecimalPlaces,  '',     @nAppliedAmount,   @nCalcAmount output,  @O_iErrorState          output   select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError   if (@iStatus <> 0) or (@O_iErrorState <> 0)  break   select @nOrigCurrentTrxAmount = @nOrigCurrentTrxAmount + @nCalcAmount  end   else  begin  select @nOrigCurrentTrxAmount = @nOrigCurrentTrxAmount + @nOriginatingAppliedAmount  end  end   fetch next from   AppliedOpenCursor  into   @nAppliedAmount,  @nRealizedGainLoss,  @nOriginatingAppliedAmount,  @nActualApplyToAmount,  @cApplyToCurrencyID,  @cApplyFromCurrencyID,  @dApplyDate   end    deallocate AppliedOpenCursor   if @iStatus <> 0 or @O_iErrorState <> 0  break   end     else    begin   declare  AppliedHistoryCursor INSENSITIVE  cursor for select  APPTOAMT,  RLGANLOS,  ORAPTOAM,  ActualApplyToAmount,  CURNCYID,  FROMCURR,  DATE1  from  RM30201  where  APFRDCNM = @cDocumentNumber  and APFRDCTY = @sRMDocumentTypeAll  and  ((@I_tUsingDocumentDate = 1  and (DATE1 < @I_dStartDate or DATE1 > @I_dEndDate  or APTODCDT < @I_dStartDate or APTODCDT > @I_dEndDate))  or  (@I_tUsingDocumentDate = 0  and (GLPOSTDT < @I_dStartDate or GLPOSTDT > @I_dEndDate  or  ApplyToGLPostDate < @I_dStartDate or ApplyToGLPostDate > @I_dEndDate)))   open AppliedHistoryCursor   fetch next from   AppliedHistoryCursor  into   @nAppliedAmount,  @nRealizedGainLoss,  @nOriginatingAppliedAmount,  @nActualApplyToAmount,  @cApplyToCurrencyID,  @cApplyFromCurrencyID,  @dApplyDate   while (@@fetch_status <> -1)  begin  if (@@fetch_status = -2)  begin  select @O_iErrorState = 21053  break  end   if @I_sPrintCurrencyIn = 1 and @I_tMCRegistered = 1  begin  if @I_sReportingRateCalcMethod = 1  begin  select @nCurrentTrxAmount =  @nCurrentTrxAmount +   ISNULL(ROUND((@nAppliedAmount * @I_nReportingExchangeRate),@I_sReportingDecimalPlaces),0.00) +   ISNULL(ROUND((@nRealizedGainLoss * @I_nReportingExchangeRate),@I_sReportingDecimalPlaces),0.00)  end  else  begin  select @nCurrentTrxAmount =  @nCurrentTrxAmount +   ISNULL(ROUND((@nAppliedAmount / @I_nReportingExchangeRate),@I_sReportingDecimalPlaces),0.00) +   ISNULL(ROUND((@nRealizedGainLoss / @I_nReportingExchangeRate),@I_sReportingDecimalPlaces),0.00)  end  end   else    begin  select @nCurrentTrxAmount = @nCurrentTrxAmount + @nAppliedAmount + @nRealizedGainLoss  end   if @cCurrencyID = '' or @cCurrencyID = @I_cFunctionalCurrency  begin  if @I_sPrintCurrencyIn = 1 and @I_tMCRegistered = 1  begin  if @I_sReportingRateCalcMethod = 1  begin  select @nOrigCurrentTrxAmount = @nOrigCurrentTrxAmount +   ISNULL(ROUND((@nAppliedAmount * @I_nReportingExchangeRate),@I_sReportingDecimalPlaces),0.00) +   ISNULL(ROUND((@nRealizedGainLoss * @I_nReportingExchangeRate),@I_sReportingDecimalPlaces),0.00)  end  else  begin  select @nOrigCurrentTrxAmount = @nOrigCurrentTrxAmount +   ISNULL(ROUND((@nAppliedAmount / @I_nReportingExchangeRate),@I_sReportingDecimalPlaces),0.00) +   ISNULL(ROUND((@nRealizedGainLoss / @I_nReportingExchangeRate),@I_sReportingDecimalPlaces),0.00)  end  end   else    begin  select @nOrigCurrentTrxAmount = @nOrigCurrentTrxAmount + @nAppliedAmount + @nRealizedGainLoss  end  end   else if (@cApplyFromCurrencyID <> '' and @cApplyFromCurrencyID <> @I_cFunctionalCurrency) and   (@cApplyToCurrencyID <> '' and @cApplyToCurrencyID <> @I_cFunctionalCurrency)  begin  select @nOrigCurrentTrxAmount = @nOrigCurrentTrxAmount + @nActualApplyToAmount  end   else  begin   if @cApplyToCurrencyID = '' or @cApplyToCurrencyID = @I_cFunctionalCurrency  begin  set rowcount 1   select  @sRateCalcMethod = RTCLCMTD,  @nExchangeRate = XCHGRATE,  @nDenomExchangeRate = DENXRATE,  @sMCTrxState = MCTRXSTT  from  MC020104 with (NOLOCK)  where  CURNCYID = @cApplyFromCurrencyID  and DOCNUMBR = @cDocumentNumber  and DOCTYPE  = @sRMDocumentTypeAll  and RVLUDATE <= @dApplyDate  order by RVLUDATE DESC, SEQNUMBR DESC   if @@rowcount <> 1  begin  select  @sRateCalcMethod = RTCLCMTD,  @nExchangeRate = XCHGRATE,  @nDenomExchangeRate = DENXRATE,  @sMCTrxState = MCTRXSTT  from  MC020102 with (NOLOCK)  where  DOCNUMBR = @cDocumentNumber  and RMDTYPAL  = @sRMDocumentTypeAll   end   set rowcount 0   select  @sDecimalPlaces = ISNULL(DECPLCUR,3) - 1  from  DYNAMICS..MC40200 with (NOLOCK)  where  CURNCYID = @cApplyFromCurrencyID   Exec @iStatus = mcCalculateAmount  @sRateCalcMethod,  3,     @nExchangeRate,  @nDenomExchangeRate,  '',       @sMCTrxState,  @sDecimalPlaces,  '',     @nAppliedAmount,   @nCalcAmount output,  @O_iErrorState          output   select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError   if (@iStatus <> 0) or (@O_iErrorState <> 0)  break   select @nOrigCurrentTrxAmount = @nOrigCurrentTrxAmount + @nCalcAmount  end   else  begin  select @nOrigCurrentTrxAmount = @nOrigCurrentTrxAmount + @nOriginatingAppliedAmount  end  end   fetch next from   AppliedHistoryCursor  into   @nAppliedAmount,  @nRealizedGainLoss,  @nOriginatingAppliedAmount,  @nActualApplyToAmount,  @cApplyToCurrencyID,  @cApplyFromCurrencyID,  @dApplyDate   end    deallocate AppliedHistoryCursor   if @iStatus <> 0 or @O_iErrorState <> 0  break   end     select   @vCurrentTrxAmount = convert(varchar(30),@nCurrentTrxAmount),  @vOrigCurrentTrxAmount = convert(varchar(30),@nOrigCurrentTrxAmount),  @vRMDocumentTypeAll = convert(varchar(2),@sRMDocumentTypeAll),  @vDiscAmtAvailAdj = convert(varchar(30),@nRevalDiscAmtAvailAdj)  exec('  update  #TransactionTEMP  set  CurrentTrxAmount = -1 * ' + @vCurrentTrxAmount + ',  OrigCurrentTrxAmount = -1 * ' + @vOrigCurrentTrxAmount + ',  RevalDiscAmountAvailAdj = ' + @vDiscAmtAvailAdj + ',   AgingPeriod = 1  from  #TransactionTEMP WITH(INDEX(DocumentNumberIndex))  where  #TransactionTEMP.DocumentNumber = ''' + @cDocumentNumber + '''  and #TransactionTEMP.RMDocumentTypeAll = ' + @vRMDocumentTypeAll )   fetch next from   PaymentCursor  into   @cDocumentNumber,  @sRMDocumentTypeAll,  @nCurrentTrxAmount,  @nRevalCurTrxAmtAdj,  @nRevalDiscAmtAvailAdj,   @nOrigCurrentTrxAmount,  @cCurrencyID,  @tStatus   end    deallocate PaymentCursor    if @iStatus <> 0 or @O_iErrorState <> 0  break  end   return   
GO
GRANT EXECUTE ON  [dbo].[rmHATBCalculatePaymentTotals] TO [DYNGRP]
GO
