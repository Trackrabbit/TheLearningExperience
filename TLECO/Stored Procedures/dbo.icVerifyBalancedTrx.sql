SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
 create procedure [dbo].[icVerifyBalancedTrx]  @I_iJournalEntry integer  = NULL,   @I_cOrigICID char(5)         = NULL,   @I_sCurrencyIndex smallint = NULL,   @I_tICEREnabled   tinyint  = NULL,   @O_tIsBalanced   tinyint  = NULL  output,   @O_iErrorState          int             = NULL  output  as   declare  @TRUE            tinyint,   @FALSE    tinyint,   @POST_ACCT   tinyint,  @POST_ALLOC     tinyint,  @UNIT_ACCT   tinyint,  @UNIT_ALLOC     tinyint,  @cICID char(5),   @sCompID   smallint,  @iStatus int,  @iError   int,  @cExecstring char(250),  @tLoop tinyint,   @cDBName      char(11),  @mOrigTotal numeric(19,5),  @mFuncTotal numeric(19,5),  @NORMAL_TRX   smallint,  @GL_NORMAL   char(15),  @tTransaction tinyint,  @dMinDate datetime  select  @iStatus  = 0,  @iError  = 0,  @POST_ACCT  = 1,  @POST_ALLOC   = 3,   @UNIT_ACCT  = 2,  @UNIT_ALLOC   = 4,   @TRUE           = 1,  @FALSE          = 0,  @NORMAL_TRX = 1  exec @iStatus = smGetMinDate @dMinDate output  select  @O_tIsBalanced = @FALSE,   @O_iErrorState = 0   create table #Breakout (  IntercompanyID char(5)  not null,  DestICID char(5)  not null,  UserAccess tinyint not null,  FunctionalDebitTotal   numeric(19,5) not null,  FunctionalCreditTotal   numeric(19,5) not null,  OriginatingDebitTotal  numeric(19,5) not null,  OriginatingCreditTotal  numeric(19,5) not null,  CompanyID smallint not null,  AccountIndex int not null,  SequenceLine numeric(19,0) not null IDENTITY(500,500),  ExchangeRate numeric(15,7) not null,  DecimalPlaces smallint not null,  RateCalculationMethod smallint not null,  CurrencyIndex smallint not null,  RateTypeID char(15) not null,  ExchangeTableID char(15) not null,  ExchangeDate datetime not null,  ExchangeTime datetime not null,  DenomExchangeRate numeric(15,7) not null,  MCTrxState smallint not null,  CorrespondingUnit char(5)  not null) create table #Company (  IntercompanyID char(5)  not null,  CompanyName char(64)  not null,  CompanyID smallint  not null,  UserAccess tinyint not null,  FunctionalCurrency char(15) not null,  SourceDocument char(11) not null,  BatchNumber char(15) not null,  LineMessages2 binary(4) not null,  DatabaseName char(10) not null) create table #TRXHeader (  JournalEntry int not null,  BatchNumber char(15) not null,  BatchSource char(15) not null,  TransactionType smallint not null,  SourceDocument char(10) not null,  Series smallint not null,  Reference char(31) not null,  TRXSource char(13) not null,  ReversingTRXSource char(13) not null,  RecurringTRX smallint not null,  RecurringTRXSequence numeric(19,5) not null,  TransactionDate datetime not null,  TransactionPeriodID smallint not null,  TransactionYear smallint not null,  TransactionClosingYear smallint not null,  TransactionHistory tinyint not null,  ReversingDate datetime not null,  ReversingPeriodID smallint not null,  ReversingYear smallint not null,  ReversingClosingYear smallint not null,  ReversingHistory tinyint not null,  CurrencyID char(15) not null,  CurrencyIndex smallint not null,  RateTypeID char(15) not null,  ExchangeTableID char(15) not null,  ExchangeRate numeric(15,5) not null,  ExchangeDate datetime not null,  ExchangeTime datetime not null,  RateCalculationMethod smallint not null,  BalanceForCalculation smallint not null,  ControlBalance numeric(19,5) not null,  OffsetAccountIndex int not null,  OffsetAccountType smallint not null,  OffsetFixedOrVariable smallint not null,  OffsetPostingType smallint not null,  PostingStatus smallint not null,  HeaderValid binary(4) not null,  HeaderMessages binary(4) not null,  HeaderMessages2 binary(4) not null,  ICTransaction tinyint not null,  ICDistributionsExist tinyint not null,  OrigIntercompanyID char(5)  not null,  OrigTransactionSource char(13) not null,  OrigDTASeries smallint not null,  DTAIndex numeric(19,5) not null,  DenomExchangeRate numeric(15,7) not null,  MCTrxState smallint not null,  DocumentDate datetime not null,  TaxDate datetime not null)   create table #LineItems (  IntercompanyID char(5)  not null,  CompanyID smallint not null,  FunctionalCurrency char(15) not null,  SequenceLine numeric(19,5) not null,  AccountIndex int not null,  TRXDebit   numeric(19,5)  not null,  TRXCredit   numeric(19,5)  not null,  OriginatingDebit numeric(19,5) not null,  OriginatingCredit numeric(19,5) not null,  Description char(31) not null,  CurrencyIndex smallint not null,  RateTypeID char(15) not null,  ExchangeTableID char(15) not null,  ExchangeRate numeric(15,7) not null,  ExchangeDate datetime not null,  ExchangeTime datetime not null,  RateCalculationMethod smallint not null,  LineValid binary(4) not null,  AccountType smallint not null,  FixedOrVariable smallint not null,  BalanceForCalculation smallint not null,  PostingType smallint not null,  DecimalPlaces smallint not null,  OrigControlNumber char(21) not null,  OrigDocumentNumber char(21) not null,  OrigMasterID char(31) not null,  OrigMasterName char(65) not null,  OrigTransactionType smallint not null,  OrigTRXDesc char(30) not null,  OrigSeqNum int not null,  DTAGLStatus smallint not null,  LineMessages2 binary(4) not null,  DatabaseName char(10) not null,   SystemGenerated tinyint not null,  DenomExchangeRate numeric(15,7) not null,  MCTrxState smallint not null,  LineStatus   smallint not null,  CorrespondingUnit char(5)  not null)  if @@trancount = 0  begin  select @tTransaction = 1  begin transaction end    while (@tLoop is NULL) begin      select @tLoop = 1   if  @I_iJournalEntry is NULL or  @I_cOrigICID is NULL  begin  select @O_iErrorState = 20948  break   end    exec @iStatus = DYNAMICS.dbo.smGetConstantString  'GL_NORMAL_STR',   @GL_NORMAL output,  @O_iErrorState output   select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if @iStatus <> 0 or @O_iErrorState <> 0  break   insert into  #Company   (IntercompanyID,   CompanyName,   CompanyID,   UserAccess,  FunctionalCurrency,   SourceDocument,   BatchNumber,   LineMessages2,  DatabaseName)   (select distinct   gl.INTERID,   '',     0,      1,      '',     '',     '',     0x00000000,    ''      from   GL10001 gl   where   gl.JRNENTRY = @I_iJournalEntry)    if not exists(  select   1   from   #Company   where   IntercompanyID = @I_cOrigICID)  begin  insert into  #Company   (IntercompanyID,   CompanyName,   CompanyID,   UserAccess,  FunctionalCurrency,   SourceDocument,   BatchNumber,   LineMessages2,  DatabaseName)   values  (@I_cOrigICID,   '',   0,   0,   '',   '',   '',   0,   '')  end      update   #Company   set  CompanyID  = isnull(cm.CMPANYID,0),  CompanyName  = isnull(cm.CMPNYNAM, '')  from   DYNAMICS..SY01500 cm  where   #Company.IntercompanyID = cm.INTERID   update   #Company   set   DatabaseName = isnull(pn.DBNAME, '')  from   DYNAMICS..SY02100 pn  where   #Company.CompanyID = pn.CMPANYID    declare   Companycursor INSENSITIVE  cursor for select   IntercompanyID,  CompanyID,  DatabaseName  from   #Company  where   UserAccess = 1   open Companycursor  if @@cursor_rows <>  0  begin   fetch next from  Companycursor  into  @cICID,   @sCompID,  @cDBName   while (@@fetch_status <> -1)  begin  select @cExecstring =   'update #Company ' +   'set FunctionalCurrency = ' +   '(select isnull(FUNLCURR, '' '') from ' +rtrim(@cDBName) + '..MC40000)'+   ' where IntercompanyID = ''' + rtrim(@cICID) + ''''    exec (@cExecstring)    select @iError = @@error  if @iStatus = 0 and @iError <> 0   select @iStatus = @iError   if @iStatus <> 0  break   fetch next from  Companycursor  into  @cICID,   @sCompID,   @cDBName  end    end    deallocate Companycursor   insert into   #TRXHeader  values  (@I_iJournalEntry,  '',  @GL_NORMAL,  @NORMAL_TRX,  '',  2,  '',  '',  '',  0,0,  @dMinDate,  0,0,  0,0,  @dMinDate,  0,0,  0,0,  '',  @I_sCurrencyIndex,   '',  '',  0,  @dMinDate,  @dMinDate,  0,0,  0,0,  0,0,  0,0,  0x00000000,0x00000000,0x00000000,  1,  1,  @I_cOrigICID,  '',  0,  0.0,  0.0,      0,      @dMinDate,      @dMinDate)      select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if @iStatus <> 0 or @O_iErrorState <> 0  break   exec @iStatus = icpBreakoutDists  @I_iJournalEntry,  '',     '',       @I_cOrigICID,   @TRUE,     @TRUE,      @I_tICEREnabled,  @O_iErrorState output   select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if @iStatus <> 0 or @O_iErrorState <> 0  break   select @mOrigTotal = isnull(sum(li.OriginatingDebit), 0) -  isnull(sum(li.OriginatingCredit), 0)  from   #LineItems li   where   li.IntercompanyID  = @I_cOrigICID  and  AccountType  <> @UNIT_ACCT   and AccountType     <> @UNIT_ALLOC   select @mFuncTotal = isnull(sum(li.TRXDebit), 0) - isnull(sum(li.TRXCredit), 0)  from   #LineItems li   where   li.IntercompanyID  = @I_cOrigICID  and  AccountType  <> @UNIT_ACCT   and AccountType     <> @UNIT_ALLOC  if (@mOrigTotal <> 0) and (@mFuncTotal <> 0)   begin  select @O_tIsBalanced = @FALSE   break  end  else   select @O_tIsBalanced = @TRUE  end    if @O_iErrorState <> 0 begin  if @tTransaction = 1  rollback transaction end else if @tTransaction = 1  commit transaction return (@iStatus)    
GO
GRANT EXECUTE ON  [dbo].[icVerifyBalancedTrx] TO [DYNGRP]
GO
