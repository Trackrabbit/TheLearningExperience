SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
 create procedure [dbo].[icpmcCreateRoundingDists]  @I_tPosting tinyint  = NULL,  @I_cOrigICID char(5)         = NULL,   @IO_bLineMessages2 binary(4) = NULL output,   @O_iErrorState        int             = NULL  output as  declare  @MS_ITEM_27 int,  @tTransaction    int,  @tLoop    tinyint,  @FuncTotal numeric(19,5),  @OrigTotal numeric(19,5),  @FunctionalDebit numeric(19,5),  @FunctionalCredit numeric(19,5),  @OriginatingDebit numeric(19,5),  @OriginatingCredit numeric(19,5),  @RoundIndex int,  @POST_ACCT   smallint,  @POST_ALLOC    smallint,   @UNIT_ACCT   smallint,  @UNIT_ALLOC    smallint,   @EmptyDate datetime,  @iStatus   int,  @iError   int,   @CurrencyID char(15),  @RateTypeID char(15),  @cICID char(5),  @SeqLine   numeric(19,5),   @TRUE tinyint,   @vProcName varchar(255),  @vDBName varchar(10),  @vOrigDBName varchar(10),  @tORIGROUND tinyint,  @tDESTROUND   tinyint,  @sAccountType smallint,  @sNORMALROUND smallint,  @sNOTEDITABLE smallint,  @dMinDate datetime  select  @O_iErrorState  = 0,  @iStatus   = 0,   @iError    = 0   if @@trancount = 0 begin  select @tTransaction = 1  begin transaction  end   exec @iStatus = smGetMinDate @dMinDate output  while (@tLoop is NULL) begin   select @tLoop = 1    if     @I_cOrigICID is NULL or  @I_tPosting is NULL or  @IO_bLineMessages2  is NULL   begin     select @O_iErrorState = 20903   break  end    select   @MS_ITEM_27   = power(2, 2),  @EmptyDate = @dMinDate,  @TRUE  = 1,  @POST_ACCT  = 1,  @POST_ALLOC   = 3,  @UNIT_ACCT  = 2,  @UNIT_ALLOC   = 4,  @tORIGROUND = 1,  @tDESTROUND = 2 ,  @sNORMALROUND = 2,  @sNOTEDITABLE = 256   if not exists( select  1  from   #LineItems   where  FunctionalCurrency <> (select CurrencyID from #TRXHeader))   break    select @OrigTotal = isnull(sum(li.OriginatingDebit), 0) -  isnull(sum(li.OriginatingCredit), 0)  from   #LineItems li   where   li.IntercompanyID  = @I_cOrigICID  and  AccountType  <> @UNIT_ACCT   and AccountType     <> @UNIT_ALLOC   select @FuncTotal = isnull(sum(li.TRXDebit), 0) - isnull(sum(li.TRXCredit), 0)  from   #LineItems li   where   li.IntercompanyID  = @I_cOrigICID  and  AccountType  <> @UNIT_ACCT   and AccountType     <> @UNIT_ALLOC  if (@OrigTotal = 0) and (@FuncTotal = 0)   select @RoundIndex = 0  else  if (@OrigTotal <> 0) and (@FuncTotal <> 0)   begin     if (@I_tPosting = @TRUE)  select @O_iErrorState = 20932   break   end   else   begin   select @vOrigDBName =   (select   DatabaseName   from   #Company   where   IntercompanyID = @I_cOrigICID)   if (@OrigTotal <> 0)   begin   select @CurrencyID = (select CurrencyID from #TRXHeader)  select @RateTypeID =   isnull((select distinct  RateTypeID  from   #LineItems   where   IntercompanyID = @I_cOrigICID  and  RateTypeID  <> '') ,'')   select @vProcName = rtrim(@vOrigDBName) + '.dbo.icpmcGetRoundingAccount'  exec @iStatus = @vProcName  @I_cOrigICID,  @CurrencyID,   @RateTypeID,  @RoundIndex output,  @sAccountType  output,   @O_iErrorState output   select @iError = @@error  if @iStatus = 0 and @iError <> 0   select @iStatus = @iError   if @iStatus <> 0 or @O_iErrorState <> 0   break  if @RoundIndex = 0   begin  select @IO_bLineMessages2= (@IO_bLineMessages2| @MS_ITEM_27)   update   #LineItems  set   LineMessages2 = (LineMessages2 | @MS_ITEM_27)   where  IntercompanyID =  @I_cOrigICID   if @I_tPosting = @TRUE  break   end    select @FunctionalDebit = 0.0,  @FunctionalCredit = 0.0  if @OrigTotal < 0   begin   select @OriginatingDebit = @OrigTotal * -1.0   select @OriginatingCredit = 0.0  end  else  begin   select @OriginatingDebit = 0.0   select @OriginatingCredit = @OrigTotal  end  end  else  begin     select @CurrencyID =   (select CurrencyID from #TRXHeader)  select @RateTypeID =   isnull((select distinct  RateTypeID  from   #LineItems   where   IntercompanyID = @I_cOrigICID  and  RateTypeID  <> ''),'')    select @vProcName = rtrim(@vOrigDBName) + '.dbo.icpmcGetRoundingAccount'  exec @iStatus = @vProcName  @I_cOrigICID,  @CurrencyID,   @RateTypeID,  @RoundIndex output,   @sAccountType  output,  @O_iErrorState output   select @iError = @@error  if @iStatus = 0 and @iError <> 0   select @iStatus = @iError   if @iStatus <> 0 or @O_iErrorState <> 0  break    if @RoundIndex = 0   begin     select @IO_bLineMessages2= (@IO_bLineMessages2| @MS_ITEM_27)   update   #LineItems  set   LineMessages2 = (LineMessages2 | @MS_ITEM_27)   where  IntercompanyID =  @I_cOrigICID   if @I_tPosting = @TRUE  break   end    if @FuncTotal < 0   begin  select @FunctionalDebit = @FuncTotal * -1.0  select @FunctionalCredit = 0.0  end  else  begin  select @FunctionalDebit = 0.0  select @FunctionalCredit = @FuncTotal  end  select @OriginatingDebit = 0.0,  @OriginatingCredit = 0.0  end    if @RoundIndex <> 0   begin  select @SeqLine = (select isnull(max(SequenceLine) + 500, 500) from #LineItems)   insert into   #LineItems  select  distinct  @I_cOrigICID,   li.CompanyID,  li.FunctionalCurrency,  @SeqLine,     @RoundIndex,   @FunctionalDebit,   @FunctionalCredit,   @OriginatingDebit,   @OriginatingCredit,   '',     li.CurrencyIndex,  li.RateTypeID,      li.ExchangeTableID,     0.0,      @EmptyDate,    @EmptyDate,    0,     0x0000000,         isnull(@sAccountType,@POST_ACCT),    0,      0,       0,     li.DecimalPlaces,  '',  '',  '',  '',  0,  ' ',  0,  0,  li.LineMessages2,   li.DatabaseName,  @tORIGROUND,     0.0,     li.MCTrxState,  @sNORMALROUND + @sNOTEDITABLE,  ''     from  #LineItems li  where   li.IntercompanyID = @I_cOrigICID   end     end     declare   Companycursor INSENSITIVE  cursor for select distinct  #LineItems.IntercompanyID,  #LineItems.DatabaseName  from   #LineItems,  #TRXHeader,  #Company   where   #LineItems.IntercompanyID   <> @I_cOrigICID   and #LineItems.FunctionalCurrency  <> #TRXHeader.CurrencyID  and   #Company.IntercompanyID = #LineItems.IntercompanyID  and  #Company.UserAccess = 1  open Companycursor   if @@cursor_rows <>  0  begin   fetch next from  Companycursor  into  @cICID,  @vDBName   while (@@fetch_status <> -1)  begin  select   @FuncTotal = isnull(sum(li.TRXDebit), 0) - isnull(sum(li.TRXCredit), 0)  from   #LineItems li   where   li.IntercompanyID  = @cICID   and  AccountType  <> @UNIT_ACCT   and AccountType     <> @UNIT_ALLOC  if (@FuncTotal <> 0)   begin   select @CurrencyID =   (select CurrencyID from #TRXHeader)   select @RateTypeID =   isnull((select distinct  RateTypeID  from   #LineItems   where   IntercompanyID = @cICID  and  RateTypeID  <> '')   ,'')   select @vProcName = rtrim(@vDBName) + '.dbo.icpmcGetRoundingAccount'  exec @iStatus = @vProcName  @cICID,  @CurrencyID,   @RateTypeID,   @RoundIndex output,  @sAccountType  output,  @O_iErrorState output   select @iError = @@error  if @iStatus = 0 and @iError <> 0   select @iStatus = @iError   if @iStatus <> 0 or @O_iErrorState <> 0  break   if @RoundIndex = 0   begin     select @IO_bLineMessages2= (@IO_bLineMessages2| @MS_ITEM_27)  update   #LineItems  set   LineMessages2 = (LineMessages2 | @MS_ITEM_27)   where  IntercompanyID =  @cICID   if @I_tPosting = @TRUE  break   end    if @FuncTotal < 0  begin  select @FunctionalDebit = @FuncTotal * -1.0  select @FunctionalCredit = 0.0  end  else  begin  select @FunctionalDebit = 0.0  select @FunctionalCredit = @FuncTotal   end  select @OriginatingDebit = 0.0,  @OriginatingCredit = 0.0   if @RoundIndex <> 0   begin   select @SeqLine = (select isnull(max(SequenceLine) + 500, 500) from #LineItems)   insert into   #LineItems  select  distinct  @cICID,  li.CompanyID,   li.FunctionalCurrency,  @SeqLine,    @RoundIndex,   @FunctionalDebit,   @FunctionalCredit,   @OriginatingDebit,   @OriginatingCredit,   '',     li.CurrencyIndex,  li.RateTypeID,     li.ExchangeTableID,      0.0,      @EmptyDate,     @EmptyDate,    0,     0x0000000,          isnull(@sAccountType,@POST_ACCT),    0,     0,       0,     li.DecimalPlaces,  '',  '',  '',  '',  0,  ' ',  0,  0,  li.LineMessages2,  li.DatabaseName,  @tDESTROUND,     0.0,     li.MCTrxState,  @sNORMALROUND + @sNOTEDITABLE,  ''     from  #LineItems li  where   li.IntercompanyID = @cICID   end    end     fetch next from  Companycursor  into  @cICID,   @vDBName   end   end    deallocate Companycursor  end   if @O_iErrorState <> 0 or @iStatus <> 0 begin     if @tTransaction = 1   rollback transaction  end else if @tTransaction = 1     commit transaction   return(@iStatus)    
GO
GRANT EXECUTE ON  [dbo].[icpmcCreateRoundingDists] TO [DYNGRP]
GO
