SET QUOTED_IDENTIFIER OFF
GO
SET ANSI_NULLS ON
GO
create procedure [dbo].[ncCreateDestICP] 	@I_iCompanyNum smallint, 			/* target company number */ 	@I_iSourceCompanyNum smallint, 			/* source company number */ 	@I_sSourceCompanyDB char(5) = NULL,		/* source company database id (INTERID) */ 	@I_sUserId char(15) = NULL,			/* current user id */ 	@I_sReportTableName char(64) = NULL,		/* report table (temp table) name */ 	@I_iManualCreate smallint,			/* is this an auto or manual created trx NCL, 21/04/06 Mike South */ 	@I_iMulticurrency smallint,			/* 10/27/2014 KDP Is multicurrency managment enabled */ 	@O_sBatchNumber char(15) = NULL output,		/* batch number created (for subsequent posting) */ 	@O_iError int = NULL output			/* error code (return value) */ as declare @sFuncCurrId char(15), @iFuncCurrIdx smallint, @iDecPlFuncCurr smallint, @iTrnCount smallint, 	@iErrState int, @tiOK tinyint, @iOrigDTASeries smallint, @sSourceDoc char(11), @iNC_FunctionalOriginating smallint,  	@sBatchSource char(15), @sBatchNumber char(15), @iErr int, @sExtSource char(31), @sDBName varchar(8), 	@iJrnEntry int, @nSequence numeric(19,5), @iNC_SourceCoyCurrIdx smallint, @iNC_TrnOriginCurrIdx smallint, 	@iSeries smallint, @dtTrxDate datetime, @sExchangeTableId char(15), @dtExchangeDate datetime, @dtExchangeTime datetime, 	@nExchangeRate numeric(19,7), @nDenominationExchangeRate numeric(19,7), @iMCTransactionState smallint, 	@iRateCalcMethod smallint, @sRateTypeId char(15), @iISMCTrx smallint, @iCurrencyIndex smallint, 	@sCurrencyId char(15), @dtMinDate datetime, @dtCurrentDate datetime, @sCompanyName char(64), @sDTARef char(25), 	@nNoteIndex numeric(19,5), @sTrnReference char(31), @iNewJrnEntry int, @iPrevJrnEntry int, @dtPrevTrxDate datetime, 	@nDTAIndex numeric(19,5), @iLoop tinyint, @sMessageText char(255), @iDecimalPlaces smallint, @nLineSeq numeric(19,5),  	@nDebitAmt numeric(19,5), @nCreditAmt numeric(19,5),  @nOrigDebitAmt numeric(19,5), @nOrigCreditAmt numeric(19,5), 	@nSrcDebitAmt numeric(19,5), @nSrcCreditAmt numeric(19,5), @nSrcOrigDebitAmt numeric(19,5), @nSrcOrigCreditAmt numeric(19,5), 	@c_sExchangeTableId char(15), @c_dtExchangeDate datetime, @c_dtExchangeTime datetime,  	@c_nExchangeRate numeric(19,7), @c_nDenominationExchangeRate numeric(19,7), @c_iMCTransactionState smallint,  	@c_iRateCalcMethod smallint, @c_sRateTypeId char(15), @c_sOriginalReference char(31), 	@SERIES_FINANCIAL smallint, @UNPOSTED smallint,@cLogMsg char(255), 	/* Mike South 11/04/2006*/ 	@sORCTRNUM char(21), 	@tSummaryPosting tinyint, 	@tJournalRequired tinyint, 	@iAccountIndex int, 	@tUpdate tinyint, 	@nSumCreditAmt numeric(19,5), 	@nSumDebitAmt numeric(19,5), 	@iOriginatingTrxType smallint, 	@GENERAL_ENTRY char(25), 	@sBankCurrencyId char(15), 	@nSummarySequence numeric(19,5), 	@nSumOrigDebitAmt numeric(19,5), 	@iBankCurrencyIdx smallint, 	@nSumOrigCreditAmt numeric(19,5), 	@O_ControlNumber numeric(19,5), 	@iMCFunctionalOriginating tinyint, 	/* Mike South 14/06/2006*/ 	/* Start of modifications - 06/07/06 - pjsparrow */ 	@sNC_DTASeries smallint, 	@cNC_DTARef char(25), 	@nNC_SeqLine numeric(19,5), 	@cNC_OrigCtrlNum char(20), 	@sNC_OrigTrxType smallint, 	@iNC_OrigSeqNum int, 	/* End of modifications - 06/07/06 - pjsparrow */ 	@CheckIns		tinyint /*vilasw - Added check for empty batch header*/ set nocount on set @CheckIns = 0 select @SERIES_FINANCIAL = 2, @sBatchSource = 'GL_Normal', @UNPOSTED = 1, @nLineSeq = 0,  	@sDBName = db_name(), @iNewJrnEntry = 0, @O_sBatchNumber = '', @iTrnCount = 0 /* IB - 20/06/06, Added Intercompany Log table */ select @cLogMsg = 'ncCreateDestICP Start.  Company Num:'+str(@I_iCompanyNum)+' srce company num:'+str(@I_iSourceCompanyNum) exec dbo.ncWriteInterLog @cLogMsg exec smGetMinDate @dtMinDate output exec smGetDefaultDate @dtCurrentDate output select @sCompanyName = isnull(CMPNYNAM,'') from DYNAMICS.dbo.SY01500 where CMPANYID=@I_iCompanyNum /* set up functional currency info - MC_SETP (MC40000) and MC_Currency_SETP (DYN..MC40200) */ /* 10/27/2014	KDP added @I_iMulticurrency smallint,  Is multicurrency managment enabled */ if exists(select 1 from MC40000 where FUNCRIDX <> 0) and (@I_iMulticurrency != 0) begin 	if exists(select 1 from MC40000 MCSETP join DYNAMICS.dbo.MC40200 CURRSETP on CURRSETP.CURRNIDX = MCSETP.FUNCRIDX) 	begin 		select @sFuncCurrId = MCSETP.FUNLCURR, @iFuncCurrIdx = MCSETP.FUNCRIDX, @iDecPlFuncCurr = CURRSETP.DECPLCUR-1 		from MC40000 MCSETP join DYNAMICS.dbo.MC40200 CURRSETP on CURRSETP.CURRNIDX = MCSETP.FUNCRIDX 	end 	else 	begin 		/* functional currency set but currency does not exist */ 		select @sMessageText = 'Functional Currency Setup incorrect for company '+rtrim(@sCompanyName) 		exec ncAddReportRecord @I_sReportTableName, @sMessageText 		select @O_iError = 1 		return 	end end else 	select @sFuncCurrId = '', @iFuncCurrIdx = 0, @iDecPlFuncCurr = 2, @iISMCTrx = 0, @nExchangeRate = 1,  		@iCurrencyIndex = 0, @sExchangeTableId = '', @dtExchangeDate = @dtMinDate, @dtExchangeTime = @dtMinDate, 		@nDenominationExchangeRate = 0, @iMCTransactionState = 0, @iRateCalcMethod = 0, 		@sRateTypeId = '', @sCurrencyId = '', @iDecimalPlaces = 2 /* 25/04/2006 Mike South*/ /*select @iNC_FunctionalOriginating = isnull( (select NC_FunctionalOriginating from NCIC3000), 0 )*/ select @tSummaryPosting	= isnull( (select NC_SpareInts_8 from NCIC3000), 0 ) /* determine destination batch id - base ICP_DEST_TRN_01, check activity and Inc number as required */ select @sBatchNumber = 'ICP_DEST_TRN_01' exec ncGetUniqueBatch @SERIES_FINANCIAL, @sBatchSource, @sBatchNumber output, '' /* batch comment */, 	'' /* checkbook */, @I_iCompanyNum, @I_sUserId, @iErr output if @iErr = 2 begin 	select @sMessageText = 'Unable to create posting batch in company '+rtrim(@sCompanyName) 	exec ncAddReportRecord @I_sReportTableName, @sMessageText 	select @O_iError = 1 	return end /* Mike South 27/06/2006 Create Batch Activity Record */ exec DYNAMICS..smGetConstantString   		'TRX_SOURCE_GL_GENERAL_ENTRY', 		@GENERAL_ENTRY output,   		@iErr output  /*Added new if vilasw*/ if not exists (select WINTYPE from DYNAMICS.dbo.SY00800 where WINTYPE = 1 and  USERID = @I_sUserId and  		CMPNYNAM = @sCompanyName and BCHSOURC = @sBatchSource and BACHNUMB = @sBatchNumber and POSTING = 0 and TRXSOURC = @GENERAL_ENTRY) begin 	insert into  DYNAMICS.dbo.SY00800  			  (   WINTYPE,  USERID,  CMPNYNAM,  BCHSOURC,  BACHNUMB,  POSTING,  TRXSOURC )   		values(   1 /*TRX_WINDOW*/,  @I_sUserId,  @sCompanyName,  @sBatchSource, @sBatchNumber,  0,  @GENERAL_ENTRY)   end  /*Added new if vilasw*/ /**/ /* cursor to read through all pending rows for this company...    due to needing multiple journal headers etc. need to use cursor instead of     simple insert/update across the range */ /* NC_IC_Interface_MSTR = DYNAMICS.dbo.NCIC1004 */ select @iPrevJrnEntry = 0, @dtPrevTrxDate = @dtMinDate /* FAST_FORWARD option = optimised READ_ONLY */ /* NCL, 21/04/06,MS */ if @I_iManualCreate=0  begin 	declare crInterfaceRecs cursor LOCAL FAST_FORWARD for  		select JRNENTRY, SQNCLINE, String1, NC_Source_Currency_Index, CURRNIDX, SERIES, TRXDATE,  			EXGTBLID, EXCHDATE, TIME1, XCHGRATE, DENXRATE, MCTRXSTT, RTCLCMTD, RATETPID, SOURCDOC,  			OrigDTASeries, CRDTAMNT, DEBITAMT, ORCRDAMT, ORDBTAMT, ORTRXDESC, 			/*20.04.2006 MS*/  			ORCTRNUM,ORTRXTYP,USERID,NC_Source_Company_ID,NC_Bank_Currency_ID, 			NC_FunctionalOriginating,  			/**/ 			/* Start of modifications - 06/07/06 - pjsparrow */ 			ORCTRNUM, ORTRXTYP, OrigSeqNum 			/* End of modifications - 06/07/06 - pjsparrow */ 		from DYNAMICS.dbo.NCIC1004 		where CMPANYID = @I_iCompanyNum and USERID = @I_sUserId and NC_Dest_Batch_Created <> 1  		and NC_Source_Company_ID = @I_iSourceCompanyNum /*NCL, 21/04/06, MS */ and MKDTOPST=1 /**/ 		order by CMPANYID, JRNENTRY, TRXDATE, SQNCLINE end else begin 	/* if its a manual created transaction we don't need to check for the source company or userid */ 	/* just the destination company and the marked to post flag the same as the old dex code*/ 	declare crInterfaceRecs cursor LOCAL FAST_FORWARD for  		select JRNENTRY, SQNCLINE, String1, NC_Source_Currency_Index, CURRNIDX, SERIES, TRXDATE,  			EXGTBLID, EXCHDATE, TIME1, XCHGRATE, DENXRATE, MCTRXSTT, RTCLCMTD, RATETPID, SOURCDOC,  			OrigDTASeries, CRDTAMNT, DEBITAMT, ORCRDAMT, ORDBTAMT, ORTRXDESC, 			/*20.04.2006 MS*/  			ORCTRNUM,ORTRXTYP,USERID,NC_Source_Company_ID,NC_Bank_Currency_ID, 			NC_FunctionalOriginating,  			/**/ 			/* Start of modifications - 06/07/06 - pjsparrow */ 			ORCTRNUM, ORTRXTYP, OrigSeqNum 			/* End of modifications - 06/07/06 - pjsparrow */ 		from DYNAMICS.dbo.NCIC1004 		where CMPANYID = @I_iCompanyNum and NC_Dest_Batch_Created <> 1 and MKDTOPST=1  		order by CMPANYID, JRNENTRY, TRXDATE, SQNCLINE end /**/ open crInterfaceRecs fetch next from crInterfaceRecs into @iJrnEntry, @nSequence, @sExtSource, @iNC_SourceCoyCurrIdx, @iNC_TrnOriginCurrIdx, 	@iSeries, @dtTrxDate, @c_sExchangeTableId, @c_dtExchangeDate, @c_dtExchangeTime, @c_nExchangeRate, @c_nDenominationExchangeRate, 	@c_iMCTransactionState, @c_iRateCalcMethod, @c_sRateTypeId, @sSourceDoc, @iOrigDTASeries, @nSrcCreditAmt, @nSrcDebitAmt, 	@nSrcOrigCreditAmt, @nSrcOrigDebitAmt, @c_sOriginalReference, 	/*20.04.2006 MS*/  	@sORCTRNUM, @iOriginatingTrxType,@I_sUserId,@I_iSourceCompanyNum,@sBankCurrencyId,@iMCFunctionalOriginating,  	/**/ 	/* Start of modifications - 06/07/06 - pjsparrow */ 	@cNC_OrigCtrlNum, @sNC_OrigTrxType, @iNC_OrigSeqNum 	/* End of modifications - 06/07/06 - pjsparrow */ while @@FETCH_STATUS = 0 begin 	/* IB - 20/06/06, Added Intercompany Log table */ 	select @cLogMsg = 'ncCreateDestICP Updating Interface MSTR to flag Marked to Post.' + 		' Journal Num:'+str(@iJrnEntry)+' Sequence Line:'+str(@nSequence) 	exec dbo.ncWriteInterLog @cLogMsg 	/*NCL, 21/04/06 MS*/ 	select @iNC_FunctionalOriginating=@iMCFunctionalOriginating 	if @I_iManualCreate=1 	begin 		/*if its a manual trx we need to get the source db name*/ 		select @I_sSourceCompanyDB=INTERID 		from DYNAMICS.dbo.SY01500 		where CMPANYID=@I_iSourceCompanyNum 	end  	/**/ 	/* update NC_IC_Interface_MSTR (NCIC1004) to flag 'Marked To Post' (true) and 'NC Dest Batch Created' (=2) */ 	update DYNAMICS.dbo.NCIC1004 set MKDTOPST = 1, NC_Dest_Batch_Created = 2 		where CMPANYID = @I_iCompanyNum and USERID = @I_sUserId 		and JRNENTRY = @iJrnEntry and SQNCLINE = @nSequence 	/* Start of modifications - 04/07/06 - pjsparrow */ 	if @iOrigDTASeries = 0 		select @iOrigDTASeries = @SERIES_FINANCIAL 	/* End of modifications - 04/07/06 - pjsparrow */ 	/* do actual create ... */ 	/* close last journal header and create new journal header if JE or Date changed */ 	if (@iJrnEntry <> @iPrevJrnEntry) or (@dtTrxDate <> @dtPrevTrxDate) 	begin 		select @iLoop = 0 		while( @iLoop = 0 ) 		begin 			select @iLoop = 1 			select @iErr = 0, @iErrState = 0 			/* new journal header required */ 			select @iPrevJrnEntry = @iJrnEntry, @dtPrevTrxDate = @dtTrxDate, @nLineSeq = 0 			/* MC Structure */ 			if @iFuncCurrIdx <> 0 	/* currency info exists */ 			begin 				/* copy transaction rate info into parameters in case that is what we end up using */ 				select 	@sExchangeTableId = @c_sExchangeTableId, @dtExchangeDate = @c_dtExchangeDate,  					@dtExchangeTime = @c_dtExchangeTime, @nExchangeRate = @c_nExchangeRate,  					@nDenominationExchangeRate = @c_nDenominationExchangeRate, 					@iMCTransactionState = @c_iMCTransactionState,  					@iRateCalcMethod = @c_iRateCalcMethod, @sRateTypeId = @c_sRateTypeId 				 				/* 24/04/2006 Mike South if it's a bank transfer we need to get the mc data */                                 /*			 for the bank to the functional currency */ 			 				exec ncDefaultMCData @I_iCompanyNum, @iNC_FunctionalOriginating, @iNC_SourceCoyCurrIdx, @iNC_TrnOriginCurrIdx,0, 					@iSeries, @dtTrxDate, @sExchangeTableId output, @dtExchangeDate output, @dtExchangeTime output, 					@nExchangeRate output, @nDenominationExchangeRate output, @iMCTransactionState output, 					@iRateCalcMethod output, @sRateTypeId output, @iISMCTrx output, @iCurrencyIndex output, 					@sCurrencyId output, @iDecimalPlaces output, @iErr output 				/**/ 				if @iErr <> 0 				begin 					select @iErrState = (@iErr + 100)	/* MC Errors, @iErr ranges from 1 to 12, see ncDefaultMCData for list */ 					/* IB - 20/06/06, Added Intercompany Log table */ 					select @cLogMsg = 'ncCreateDestICP break, ncDefaultMCData failed.' + 						' ErrorState :'+str(@iErrState) 					exec dbo.ncWriteInterLog @cLogMsg 					break 				end 			end 			 			if @tSummaryPosting=1  			begin 				exec dbo.ncValidateDestSummaryJournal 					@I_iCompanyNum, 		/* target company number */ 					@iJrnEntry,			/* old journal number being processed*/ 					@I_sUserId,			/* current user id */ 					@tJournalRequired output        /* returns 0 if no journal required and 1 if it is*/ 			end 			/* Journal Entry */ 			/* Start of modifications - 19/01/06 - pjsparrow */ 			/* exec glGetNextJournalEntry 0, @@SPID, @iNewJrnEntry output, @tiOK output, @iErr output */ 			exec glGetNextJournalEntry 1, @@SPID, @iNewJrnEntry output, @tiOK output, @iErr output 			/* End of modifications - 19/01/06 - pjsparrow */ 			if @tiOK = 0 			begin 				select @iErrState = 1	/* Unable to determine Next Journal Entry */ 				/* IB - 20/06/06, Added Intercompany Log table */ 					select @cLogMsg = 'ncCreateDestICP break, glGetNextJournalEntry failed.' + 						'unable to determine next jrn entry num' 					exec dbo.ncWriteInterLog @cLogMsg 				break 			end 			/* Note Index */ 			exec DYNAMICS.dbo.smGetNextNoteIndex @I_iCompanyNum, @@SPID, @nNoteIndex output, @iErr output 			if @iErr <> 0 			begin 				select @iErrState = 2	/* Unable to determine Next Note Index */ 				select @cLogMsg = 'ncCreateDestICP break, smGetNextNoteIndex failed.' + 						'unable to determine next Note Index' 					exec dbo.ncWriteInterLog @cLogMsg 				break 			end 			/* DTA Index */ 			exec dtaGetDTAIndex @iNewJrnEntry, @nDTAIndex output, @iErr output 			if @iErr <> 0 			begin 				select @iErrState = 3	/* Unable to determine DTA Index */ 				/* IB - 20/06/06, Added Intercompany Log table */ 					select @cLogMsg = 'ncCreateDestICP break, dtaGetDTAIndex failed.' + 						'Unable to determine DTA Inde' 					exec dbo.ncWriteInterLog @cLogMsg 				break 			end 			select @sDTARef = ltrim(str(@nDTAIndex*100000,24,0))+'N'	/* convert DTA_Index to DTA_Reference */ 			/* Transaction Reference */ 			if rtrim(@sExtSource)<>'' 				select @sTrnReference = 'IC: '+rtrim(@sExtSource)+', Journal: '+cast(@iJrnEntry as varchar(12)) 			else 				select @sTrnReference = 'IC: '+rtrim(@I_sSourceCompanyDB)+', Journal: '+cast(@iJrnEntry as varchar(12)) 			/* ...append void reference if a void... */ 			/* TRXSOURC values in SY01000 are NOT affected by language so ok to compare direct */ 			if exists(select 1 from SY01000 where SOURCDOC = @sSourceDoc and TRXSOURC = 'Void Open Trx') 				select @sTrnReference = substring(rtrim(@sTrnReference) + ' Void', 1, 30) 			/* IB - 20/06/06, Added Intercompany Log table */ 				select @cLogMsg = 'ncCreateDestICP inserting into GL10000 ' 				exec dbo.ncWriteInterLog @cLogMsg 			insert into GL10000 ( 				BACHNUMB, BCHSOURC, JRNENTRY, RCTRXSEQ, SOURCDOC, REFRENCE, TRXDATE, RVRSNGDT, RCRNGTRX, BALFRCLC, PSTGSTUS,  				LASTUSER, LSTDTEDT, USWHPSTD, TRXTYPE, SQNCLINE, GLHDRMSG, GLHDRMS2, TRXSORCE, RVTRXSRC, SERIES, ORPSTDDT,  				ORTRXSRC, OrigDTASeries, DTAControlNum, DTATRXType, DTA_Index, CURNCYID, CURRNIDX, RATETPID, EXGTBLID,  				XCHGRATE, EXCHDATE, TIME1, RTCLCMTD, NOTEINDX, GLHDRVAL, PERIODID, OPENYEAR, CLOSEDYR, HISTRX, REVPRDID,  				REVYEAR, REVCLYR, REVHIST, ERRSTATE, ICTRX, ORCOMID, ORIGINJE, ICDISTS, PRNTSTUS, DENXRATE, MCTRXSTT, DOCDATE,  				Tax_Date, VOIDED, Original_JE, Original_JE_Year, Original_JE_Seq_Num, Correcting_Trx_Type,Ledger_ID 			) values ( 				@sBatchNumber, @sBatchSource, @iNewJrnEntry, 0, @sSourceDoc, @sTrnReference, @dtTrxDate, @dtMinDate, 0, 0, @UNPOSTED,  				@I_sUserId, @dtCurrentDate, '', 0, 0, 0x00000000, 0x00000000, '', '', @SERIES_FINANCIAL, /* @dtMinDate prasad */ convert(char(10),getdate(),101), 				'IC', @iOrigDTASeries, '', 0, @nDTAIndex, @sCurrencyId, @iCurrencyIndex, @sRateTypeId, @sExchangeTableId,  				@nExchangeRate, @dtExchangeDate, @dtExchangeTime, @iRateCalcMethod, @nNoteIndex, 0x00000000, 0, 0, 0, 0, 0,  				0, 0, 0, 0, 0, @I_sSourceCompanyDB, @iJrnEntry, 0, @UNPOSTED, @nDenominationExchangeRate, @iMCTransactionState,  				@dtMinDate, @dtMinDate, 0, 0, 0, 0, 0,1 ) 		 			/* create cross reference record too (NC_IC_JRNXREF = NCIC7000 */ 			insert into NCIC7000 (JRNENTRY, REFRENCE) values (@iNewJrnEntry, @c_sOriginalReference) 		end /* end of dummy loop for flow control */ 		/* log to report table */ 		if @iErrState = 0	/* all ok */ 		begin 			select @sMessageText = 'Exported Journal '+ltrim(str(@iJrnEntry))+' to Company '+rtrim(@sCompanyName) 				+', Journal '+ltrim(str(@iNewJrnEntry)) 		end 		else if @iErrState = 1	/* Unable to determine Next Journal Entry */ 		begin 			select @sMessageText = 'Unable to determine Next Journal Entry number in Company '+rtrim(@sCompanyName)+'. Please check setup.' 		end 		else if @iErrState = 2	/* Unable to determine Next Note Index */ 		begin 			select @sMessageText = 'Unable to determine Next Note Index in Company '+rtrim(@sCompanyName) 		end 		else if @iErrState = 3	/* Unable to determine DTA Index */ 		begin 			select @sMessageText = 'Unable to determine Next DTA Index in Company '+rtrim(@sCompanyName) 		end 		else if @iErrState = 101	/* Company does not have access to the currency */ 		begin 			select @sMessageText = 'Company '+rtrim(@sCompanyName)+' does not have access to currency '+rtrim(@sCurrencyId) 		end 		else if @iErrState = 102	/* Currency not active for target company */ 		begin 			select @sMessageText = 'Currency '+rtrim(@sCurrencyId)+' not active for company '+rtrim(@sCompanyName) 		end 		else if @iErrState = 103	/* No default rate type for Financial series */ 		begin 			select @sMessageText = 'Default Financial Rate Type not defined for company '+rtrim(@sCompanyName) 		end 		else if @iErrState = 104	/* Rate type not assigned to an exchange table */ 		begin 			select @sMessageText = 'Default Financial Rate Type not assigned to an exchange table for company '+rtrim(@sCompanyName) 		end 		else if @iErrState = 105	/* Indicated exchange table does not exist */ 		begin 			select @sMessageText = 'Exchange table '+rtrim(@sExchangeTableId)+' does not exist.' 		end 		else if @iErrState = 106	/* Company does not have access to the exchange table */ 		begin 			select @sMessageText = 'Company '+rtrim(@sCompanyName)+' does not have access to exchange table '+rtrim(@sExchangeTableId) 		end 		else if @iErrState = 107	/* Exchange table not active for target company */ 		begin 			select @sMessageText = 'Exchange table '+rtrim(@sExchangeTableId)+' is not active for company '+rtrim(@sCompanyName) 		end 		else if @iErrState = 111	/* Exact rate required and no exact match found */ 		begin 			select @sMessageText = 'Exchange table '+rtrim(@sExchangeTableId)+' for company '+rtrim(@sCompanyName) 				+' requires exact rates and no rate found for transaction date.' 		end 		else if @iErrState = 112	/* No exchange rate found */ 		begin 			select @sMessageText = 'No rate found for exchange table '+rtrim(@sExchangeTableId)+' for company '+rtrim(@sCompanyName) 		end 		exec ncAddReportRecord @I_sReportTableName, @sMessageText 	end /* end of create journal header */ 	/* create details... */ 	if @iErr = 0 	begin 		if @iFuncCurrIdx = 0 		begin 			/* no currency info, so just take default values */ 			select @nCreditAmt = @nSrcCreditAmt, @nDebitAmt = @nSrcDebitAmt,  				@nOrigCreditAmt = @nSrcCreditAmt, @nOrigDebitAmt = @nSrcDebitAmt 		end 	/*To insert*/ 		else if @iNC_FunctionalOriginating = 0 		begin 			/* source functional to dest originating */ 			select @nOrigCreditAmt = @nSrcCreditAmt, @nOrigDebitAmt = @nSrcDebitAmt 			if @iNC_SourceCoyCurrIdx = @iFuncCurrIdx 				select @nCreditAmt = @nSrcCreditAmt, @nDebitAmt = @nSrcDebitAmt 			else 			begin 				/* convert currencies */ 				exec mcCalculateAmount @iRateCalcMethod, 4 /* ORIG to FUNC */, 					@nExchangeRate, @nDenominationExchangeRate, @sCurrencyId, 					@iMCTransactionState, @iDecPlFuncCurr, '',  					@nOrigCreditAmt, @nCreditAmt output, @iErr output 				exec mcCalculateAmount @iRateCalcMethod, 4, 					@nExchangeRate, @nDenominationExchangeRate, @sCurrencyId, 					@iMCTransactionState, @iDecPlFuncCurr, '',  					@nOrigDebitAmt, @nDebitAmt output, @iErr output 			end 		end 		else 		begin 			/* source originating to dest originating */ 			select @nOrigCreditAmt = @nSrcOrigCreditAmt, @nOrigDebitAmt = @nSrcOrigDebitAmt 			if @iNC_TrnOriginCurrIdx = @iFuncCurrIdx 				select @nCreditAmt = @nSrcOrigCreditAmt, @nDebitAmt = @nSrcOrigDebitAmt 			else 			begin 				/* convert currencies */ 				exec mcCalculateAmount @iRateCalcMethod, 4 /* ORIG to FUNC */, 					@nExchangeRate, @nDenominationExchangeRate, @sCurrencyId, 					@iMCTransactionState, @iDecPlFuncCurr, '',  					@nOrigCreditAmt, @nCreditAmt output, @iErr output 				exec mcCalculateAmount @iRateCalcMethod, 4, 					@nExchangeRate, @nDenominationExchangeRate, @sCurrencyId, 					@iMCTransactionState, @iDecPlFuncCurr, '',  					@nOrigDebitAmt, @nDebitAmt output, @iErr output 			end 		end 		/* IC Transaction Line */ 		select @nLineSeq = @nLineSeq + 100 		 		/* IB - 20/06/06, Added Intercompany Log table */ 			select @cLogMsg = 'ncCreateDestICP inserting into GL10001 ' 			exec dbo.ncWriteInterLog @cLogMsg 		 		if @tSummaryPosting=1  			begin 				/*Get Destination Account Index*/ 				select @iAccountIndex=IC.NC_Dest_Account_Index 				from DYNAMICS.dbo.NCIC1004 IC  				where IC.CMPANYID = @I_iCompanyNum and IC.USERID = @I_sUserId and IC.JRNENTRY = @iJrnEntry and IC.SQNCLINE = @nSequence 	 				/*Check if distribution is already there and get previous amounts*/ 				select @tUpdate=1,@nSumCreditAmt=CRDTAMNT,@nSumOrigCreditAmt=ORCRDAMT, 					@nSumOrigDebitAmt=ORDBTAMT,@nSumDebitAmt=DEBITAMT,@nSummarySequence=SQNCLINE 				from GL10001 				where JRNENTRY=@iNewJrnEntry and ACTINDX=@iAccountIndex 			end 		/* KDP 10/23/2014 added NCIC1004 IC.SEQNUMBR (use IC.OrigSeqNum for MDA otherwise IC.SEQNUMBR - for aa )  for GL10001 table specifically to pickup */ 		insert into GL10001 ( 			BACHNUMB, JRNENTRY, SQNCLINE, ACTINDX, XCHGRATE, DSCRIPTN, GLLINMSG, GLLINMS2, CURRNIDX, GLLINVAL, ACCTTYPE,  			FXDORVAR, BALFRCLC, PSTNGTYP, DECPLACS, ORCTRNUM, ORDOCNUM, ORMSTRID, ORMSTRNM, ORTRXTYP, OrigSeqNum, ORTRXDESC, 			DTA_GL_Status, INTERID, RATETPID, EXGTBLID, EXCHDATE, TIME1, RTCLCMTD, CRDTAMNT, DEBITAMT, ORCRDAMT, ORDBTAMT,  			DENXRATE, MCTRXSTT, LNESTAT, CorrespondingUnit 		) select  			@sBatchNumber, @iNewJrnEntry, @nLineSeq, IC.NC_Dest_Account_Index, @nExchangeRate, IC.DSCRIPTN,  			0x00000000, 0x00000000, @iFuncCurrIdx, 0x00000000, AC.ACCTTYPE, AC.FXDORVAR, AC.BALFRCLC,  			AC.PSTNGTYP, @iDecimalPlaces, IC.ORCTRNUM, IC.ORDOCNUM, IC.ORMSTRID, IC.ORMSTRNM, IC.ORTRXTYP,  			(case when IC.NC_Copy_MDA_CB = 1 then IC.OrigSeqNum else IC.SEQNUMBR end), '', IC.DTA_GL_Status, db_name(), @sRateTypeId, @sExchangeTableId,  			@dtExchangeDate, @dtExchangeTime, @iRateCalcMethod, @nCreditAmt, @nDebitAmt, @nOrigCreditAmt,  			@nOrigDebitAmt, @nDenominationExchangeRate, @iMCTransactionState, 0, '' 		from DYNAMICS.dbo.NCIC1004 IC join GL00100 AC on AC.ACTINDX = IC.NC_Dest_Account_Index 		where IC.CMPANYID = @I_iCompanyNum and IC.USERID = @I_sUserId and IC.JRNENTRY = @iJrnEntry and IC.SQNCLINE = @nSequence 		set @CheckIns = 1 		/* handling of DTA, NC_SY_DTA_Details but also create defaults etc. */ 		/* DTA always in functional currency only.   		 * Source and Destination companies may have different function currencies, so extra processing needed. 		 * IF src and dest Func.Index are the same, can just copy, otherwise re-apportion the values. 		 * Cannot use the exchange rate determined above, as that is for destination OC to FC not Src FC to Dest FC 		 */ 		/* Start of modifications - 06/07/06 - pjsparrow */ 		select @sNC_DTASeries = @iOrigDTASeries 		if @sNC_DTASeries = 2 		begin 			select @cNC_DTARef = @sDTARef 			select @nNC_SeqLine = @nLineSeq 		end 		else begin 			select @cNC_DTARef = rtrim(@cNC_OrigCtrlNum) + replicate(' ',(20 - datalength(rtrim(@cNC_OrigCtrlNum)))) + 						ltrim(str(@sNC_OrigTrxType)) 			select @nNC_SeqLine = @iNC_OrigSeqNum 		end 		/* End of modifications - 06/07/06 - pjsparrow */ 		if ( (@nDebitAmt-@nCreditAmt)<>0.00000 and (@nSrcDebitAmt-@nSrcCreditAmt)<>0.00000 ) 		begin 			/* generate group records */ 			/* KDP 10/15/2014 remove userid, if transactions are imported it may be by a different user */ 			insert into DTA10100 ( 				DTASERIES, DTAREF, ACTINDX, SEQNUMBR, GROUPID, DTA_GL_Reference,  				DOCNUMBR, RMDTYPAL, GROUPAMT, JRNENTRY, TRXDATE, PSTGSTUS 			) select distinct 				/* Start of modifications - 06/07/06 - pjsparrow */ 				@sNC_DTASeries, @cNC_DTARef, IC.NC_Dest_Account_Index, @nNC_SeqLine, DTA.GROUPID, '', 				/* End of modifications - 06/07/06 - pjsparrow */ 				DTA.DOCNUMBR, DTA.RMDTYPAL, (@nDebitAmt-@nCreditAmt), @iNewJrnEntry, @dtTrxDate, @UNPOSTED 			from DYNAMICS.dbo.NCIC1004 IC join DYNAMICS.dbo.NCIC2000 DTA  			on DTA.DTASERIES = IC.OrigDTASeries 			and DTA.DTAREF = IC.DTAREF 			and DTA.ACTINDX = (case when IC.NC_Trigger_Account_Index <> 0 then IC.NC_Trigger_Account_Index  				else IC.NC_Src_IC_Account_Index end) 			and DTA.SEQNUMBR = (case when IC.OrigDTASeries > 2 then IC.OrigSeqNum else IC.SEQNUMBR end) 			where DTA.NC_Copy_MDA_CB = 1 and IC.CMPANYID = @I_iCompanyNum /* KDP 10/15/2014 and IC.USERID = @I_sUserId */ 			and IC.JRNENTRY = @iJrnEntry and IC.SQNCLINE = @nSequence 			/* generate initial code records */ 			insert into DTA10200 ( 				DTASERIES, DTAREF, ACTINDX, SEQNUMBR, GROUPID, CODEID, DOCNUMBR,  				RMDTYPAL, POSTDESC, DTAQNTY, CODEAMT, TRXDATE 			) select  				/* Start of modifications - 06/07/06 - pjsparrow */ 				@sNC_DTASeries, @cNC_DTARef, IC.NC_Dest_Account_Index, @nNC_SeqLine,DTA.GROUPID, DTA.CODEID, 				/* End of modifications - 06/07/06 - pjsparrow */ 				DTA.DOCNUMBR, DTA.RMDTYPAL, DTA.POSTDESC, DTA.DTAQNTY,  				round( DTA.CODEAMT * (@nDebitAmt-@nCreditAmt) / (@nSrcDebitAmt-@nSrcCreditAmt), @iDecPlFuncCurr ), 				@dtTrxDate 			from DYNAMICS.dbo.NCIC1004 IC join DYNAMICS.dbo.NCIC2000 DTA  			on DTA.DTASERIES = IC.OrigDTASeries 			and DTA.DTAREF = IC.DTAREF 			and DTA.ACTINDX = (case when IC.NC_Trigger_Account_Index <> 0 then IC.NC_Trigger_Account_Index  				else IC.NC_Src_IC_Account_Index end) 			and DTA.SEQNUMBR = (case when IC.OrigDTASeries > 2 then IC.OrigSeqNum else IC.SEQNUMBR end)  			where DTA.NC_Copy_MDA_CB = 1 and IC.CMPANYID = @I_iCompanyNum /* KDP 10/15/2014 and IC.USERID = @I_sUserId */ 			and IC.JRNENTRY = @iJrnEntry and IC.SQNCLINE = @nSequence 			/* now do any defaulting - ACCTSTAT where fixed (1), remove and replace; where required (2), create if missing */ 			/* so, delete stuff first... */ 			delete from DTA10100 from DTA00300 DF  				where DF.ACTINDX = DTA10100.ACTINDX and DF.GROUPID = DTA10100.GROUPID 				and DF.ACCTSTAT = 1 				/* Start of modifications - 26/07/06 - pjsparrow */ 				and DTA10100.DTASERIES = @sNC_DTASeries 				and DTA10100.DTAREF = @cNC_DTARef 				and DTA10100.SEQNUMBR = @nNC_SeqLine 				/* End of modifications - 26/07/06 - pjsparrow */ 			delete from DTA10200 from DTA00300 DF  				where DF.ACTINDX = DTA10200.ACTINDX and DF.GROUPID = DTA10200.GROUPID 				and DF.ACCTSTAT = 1 				/* Start of modifications - 26/07/06 - pjsparrow */ 				and DTA10200.DTASERIES = @sNC_DTASeries 				and DTA10200.DTAREF = @cNC_DTARef 				and DTA10200.SEQNUMBR = @nNC_SeqLine 				/* End of modifications - 26/07/06 - pjsparrow */ 			/* then create codes for groups which are missing and fixed/required... */ 			insert into DTA10200 ( 				DTASERIES, DTAREF, ACTINDX, SEQNUMBR, GROUPID, CODEID, DOCNUMBR,  				RMDTYPAL, POSTDESC, DTAQNTY, CODEAMT, TRXDATE 			) select  				/* Start of modifications - 06/07/06 - pjsparrow */ 				@sNC_DTASeries, @cNC_DTARef, IC.NC_Dest_Account_Index, @nNC_SeqLine, DTA.GROUPID, DTA.CODEID, 				/* End of modifications - 06/07/06 - pjsparrow */ 				IC.ORDOCNUM, IC.ORTRXTYP, DTA.POSTDESC, 0,  				round( DTA.PERCENTAMOUNT * (@nDebitAmt-@nCreditAmt) / 10000.00000, @iDecPlFuncCurr ), 				@dtTrxDate 			from DYNAMICS.dbo.NCIC1004 IC join DTA00301 DTA  			on DTA.ACTINDX = IC.NC_Dest_Account_Index 			join DTA00300 DTAG on DTAG.GROUPID = DTA.GROUPID and DTAG.ACTINDX = DTA.ACTINDX 			where DTAG.ACCTSTAT < 3 and IC.CMPANYID = @I_iCompanyNum and IC.USERID = @I_sUserId  			and IC.JRNENTRY = @iJrnEntry and IC.SQNCLINE = @nSequence 			and not exists( select 1 from DTA10100 TG 						/* Start of modifications - 26/07/06 - pjsparrow */ 						where TG.DTASERIES = @sNC_DTASeries  						and TG.DTAREF = @cNC_DTARef 						and TG.SEQNUMBR = @nNC_SeqLine 						/* End of modifications - 26/07/06 - pjsparrow */ 						and TG.GROUPID = DTA.GROUPID 						and TG.ACTINDX = DTA.ACTINDX ) 			/* finally create groups which are missing and fixed/required... */ 			insert into DTA10100 ( 				DTASERIES, DTAREF, ACTINDX, SEQNUMBR, GROUPID, DTA_GL_Reference,  				DOCNUMBR, RMDTYPAL, GROUPAMT, JRNENTRY, TRXDATE, PSTGSTUS 			) select distinct 				/* Start of modifications - 06/07/06 - pjsparrow */ 				@sNC_DTASeries, @cNC_DTARef, IC.NC_Dest_Account_Index, @nNC_SeqLine, DTA.GROUPID, '', 				/* End of modifications - 06/07/06 - pjsparrow */ 				IC.ORDOCNUM, IC.ORTRXTYP, (@nDebitAmt-@nCreditAmt), @iNewJrnEntry, @dtTrxDate, @UNPOSTED 			from DYNAMICS.dbo.NCIC1004 IC join DTA00300 DTA  			on DTA.ACTINDX = IC.NC_Dest_Account_Index 			where DTA.ACCTSTAT < 3 and IC.CMPANYID = @I_iCompanyNum and IC.USERID = @I_sUserId  			and IC.JRNENTRY = @iJrnEntry and IC.SQNCLINE = @nSequence 			and not exists( select 1 from DTA10100 TG 						/* Start of modifications - 26/07/06 - pjsparrow */ 						where TG.DTASERIES = @sNC_DTASeries  						and TG.DTAREF = @cNC_DTARef 						and TG.SEQNUMBR = @nNC_SeqLine 						/* End of modifications - 26/07/06 - pjsparrow */ 						and TG.GROUPID = DTA.GROUPID 						and TG.ACTINDX = DTA.ACTINDX ) 			/* due to apportioning of code values, codes per group may no long add up to transaction amount, 			 * so need to check and fix the last code value in each group ... */ 			update DTA10200 set CODEAMT=CODEAMT+GT.ADJ from ( 				select DTASERIES, DTAREF, ACTINDX, SEQNUMBR, GROUPID, max(CODEID)MCODE,  					(@nDebitAmt-@nCreditAmt)-sum(CODEAMT) [ADJ] 				from DTA10200 group by DTASERIES, DTAREF, ACTINDX, SEQNUMBR, GROUPID ) GT 				where GT.DTASERIES = DTA10200.DTASERIES 				and GT.DTAREF = DTA10200.DTAREF 				and GT.ACTINDX = DTA10200.ACTINDX 				and GT.SEQNUMBR = DTA10200.SEQNUMBR 				and GT.GROUPID = DTA10200.GROUPID 				and GT.MCODE = DTA10200.CODEID 				/* Start of modifications - 26/07/06 - pjsparrow */ 				and DTA10200.DTASERIES = @sNC_DTASeries 				and DTA10200.DTAREF = @cNC_DTARef 				and DTA10200.SEQNUMBR = @nNC_SeqLine 				/* End of modifications - 26/07/06 - pjsparrow */ 			/* KDP 10/15/2014 check if values were copied correctly from NCIC2000 to DTA10200 add if they were not */	 			/* will have to be tested for multicurrency data */ 			declare @NC_ACTINDX int, 				@NC_GroupID char(25), 				@NC_CodeID char(25), 				@NC_CodeAMT numeric(19,5) 			if @sNC_DTASeries > 2 			begin 			   declare DTACheckAmtCursor cursor for 			   select ACTINDX,GROUPID,CODEID,CODEAMT from DYNAMICS.dbo.NCIC2000 				where DTASERIES = @sNC_DTASeries and DOCNUMBR = @cNC_OrigCtrlNum and SEQNUMBR = @nNC_SeqLine; 			   open DTACheckAmtCursor	 			   FETCH NEXT from DTACheckAmtCursor into @NC_ACTINDX,@NC_GroupID,@NC_CodeID,@NC_CodeAMT 			   While @@FETCH_STATUS = 0  			     begin 				if (select top 1 CODEAMT from DTA10200 where DTASERIES = @sNC_DTASeries and 					DOCNUMBR = @cNC_OrigCtrlNum and 					SEQNUMBR = @nNC_SeqLine and 					GROUPID = @NC_GroupID and 					CODEID = @NC_CodeID ) = 0 				begin 				    update DTA10200 set CODEAMT = @NC_CodeAMT where  DTASERIES = @sNC_DTASeries and 						DOCNUMBR = @cNC_OrigCtrlNum and 						SEQNUMBR = @nNC_SeqLine and 						GROUPID = @NC_GroupID and 						CODEID = @NC_CodeID  					/* log message - amount updated */ 					select @cLogMsg = 'ncCreateDestICP - MDA Data updated, code amount '+str(@NC_CodeAMT)+' Document Num:'+@cNC_OrigCtrlNum+' Group ID ' +@NC_GroupID+' Code ID '+@NC_CodeID 					exec dbo.ncWriteInterLog @cLogMsg 				end 				else begin 			 					select @cLogMsg = 'ncCreateDestICP - MDA not updated, code amount exists'+str(@NC_CodeAMT)+' Document Num: '+@cNC_OrigCtrlNum+' Group ID ' +@NC_GroupID+' Code ID '+@NC_CodeID			 					exec dbo.ncWriteInterLog @cLogMsg 					select @cLogMsg = 'KDP MDA Sequnce Line '+str(@nNC_SeqLine) 					exec dbo.ncWriteInterLog @cLogMsg 				end 				FETCH NEXT from DTACheckAmtCursor into @NC_ACTINDX,@NC_GroupID,@NC_CodeID,@NC_CodeAMT 	 			     end; 			   close DTACheckAmtCursor; 			   deallocate DTACheckAmtCursor; 			 end	 			/* KDP 10/15/2014 end */ 		end 		/* IC Control Posting */ 		select @nLineSeq = @nLineSeq + 100 		if @tSummaryPosting=1  			begin 				/*Get Destination IC Account Index*/ 				select @iAccountIndex=IC.NC_Dest_IC_Account_Index 				from DYNAMICS.dbo.NCIC1004 IC  				where IC.CMPANYID = @I_iCompanyNum and IC.USERID = @I_sUserId and IC.JRNENTRY = @iJrnEntry and IC.SQNCLINE = @nSequence 	 				/*Check if distribution is already there and get previous amounts*/ 				select @tUpdate=1,@nSumCreditAmt=DEBITAMT,@nSumOrigCreditAmt=ORDBTAMT, 					@nSumOrigDebitAmt=ORCRDAMT,@nSumDebitAmt=CRDTAMNT,@nSummarySequence=SQNCLINE 				from GL10001 				where JRNENTRY=@iNewJrnEntry and ACTINDX=@iAccountIndex 			end 		 		/* KDP 10/23/2014 added NCIC1004 IC.SEQNUMBR (use IC.OrigSeqNum for MDA otherwise IC.SEQNUMBR - for aa )  for GL10001 table specifically to pickup */		 		insert into GL10001 ( 			BACHNUMB, JRNENTRY, SQNCLINE, ACTINDX, XCHGRATE, DSCRIPTN, GLLINMSG, GLLINMS2, CURRNIDX, GLLINVAL, ACCTTYPE,  			FXDORVAR, BALFRCLC, PSTNGTYP, DECPLACS, ORCTRNUM, ORDOCNUM, ORMSTRID, ORMSTRNM, ORTRXTYP, OrigSeqNum, ORTRXDESC, 			DTA_GL_Status, INTERID, RATETPID, EXGTBLID, EXCHDATE, TIME1, RTCLCMTD, CRDTAMNT, DEBITAMT, ORCRDAMT, ORDBTAMT,  			DENXRATE, MCTRXSTT, LNESTAT, CorrespondingUnit 		) select  			@sBatchNumber, @iNewJrnEntry, @nLineSeq, IC.NC_Dest_IC_Account_Index, @nExchangeRate, IC.DSCRIPTN,  			0x00000000, 0x00000000, @iFuncCurrIdx, 0x00000000, AC.ACCTTYPE, AC.FXDORVAR, AC.BALFRCLC,  			AC.PSTNGTYP, @iDecimalPlaces, IC.ORCTRNUM, IC.ORDOCNUM, IC.ORMSTRID, IC.ORMSTRNM, IC.ORTRXTYP,  			(case when IC.NC_Copy_MDA_CB = 1 then IC.OrigSeqNum else IC.SEQNUMBR end), '', IC.DTA_GL_Status, db_name(), @sRateTypeId, @sExchangeTableId,  			@dtExchangeDate, @dtExchangeTime, @iRateCalcMethod, @nDebitAmt, @nCreditAmt, @nOrigDebitAmt,  			@nOrigCreditAmt, @nDenominationExchangeRate, @iMCTransactionState, 0, '' 		from DYNAMICS.dbo.NCIC1004 IC join GL00100 AC on AC.ACTINDX = IC.NC_Dest_IC_Account_Index 		where IC.CMPANYID = @I_iCompanyNum and IC.USERID = @I_sUserId and IC.JRNENTRY = @iJrnEntry and IC.SQNCLINE = @nSequence 		set @CheckIns = 1 		/* no DTA copy or defaulting needed for Destination Control Account */ 		/* update NC_IC_Interface_MSTR (NCIC1004) set 'NC Dest Batch Created' (=1) */ 		update DYNAMICS.dbo.NCIC1004 set NC_Dest_Batch_Created = 1 		where CMPANYID = @I_iCompanyNum and USERID = @I_sUserId	and JRNENTRY = @iJrnEntry and SQNCLINE = @nSequence 		/* Mike South 11/04/2006 */ 		/* if its a financial CM bank transfer trx then create the to side in the destination company*/ 		if @iSeries =2 /*financial*/ 		begin 			if @iOriginatingTrxType=7 /*cm transfer*/ 			begin 				 				exec ncCreateCMTransferICP  					@I_iCompanyNum, 		/* target company number */ 					@I_iSourceCompanyNum, 		/* source company number */ 					@I_sSourceCompanyDB,		/* source company database id (INTERID) */ 					@I_sUserId,			/* current user id */ 					@sORCTRNUM,			/* our transfer number from the source company */ 					@iNewJrnEntry, 					@sBatchSource,  					@sBatchNumber, 			/* need the key fields to the journal we just created to retreive the exchange rate data*/ 					@nDebitAmt, 					@nOrigDebitAmt, 					@I_iMulticurrency,		/* KDP 10/27/2014 */ 					@O_ControlNumber output, 					@O_iError output 				/*14/06/2006 Mike South */ 				/*Update journal lines with the new CM transaction key fields*/ 				if @O_iError=0 				begin 					update GL10001  					set ORCTRNUM= @O_ControlNumber 					where JRNENTRY =@iNewJrnEntry and ORCTRNUM=@sORCTRNUM and ORTRXTYP=7 				end 				/* */ 			end 		end 		/* */ 		select @iTrnCount = @iTrnCount + 1 	end 	 	/* get next row and go round again */ 	fetch next from crInterfaceRecs into @iJrnEntry, @nSequence, @sExtSource, @iNC_SourceCoyCurrIdx, @iNC_TrnOriginCurrIdx, 		@iSeries, @dtTrxDate, @c_sExchangeTableId, @c_dtExchangeDate, @c_dtExchangeTime, @c_nExchangeRate, @c_nDenominationExchangeRate, 		@c_iMCTransactionState, @c_iRateCalcMethod, @c_sRateTypeId, @sSourceDoc, @iOrigDTASeries, @nSrcCreditAmt, @nSrcDebitAmt, 		@nSrcOrigCreditAmt, @nSrcOrigDebitAmt, @c_sOriginalReference, 		/*20.04.2006 MS*/ 		@sORCTRNUM, @iOriginatingTrxType ,@I_sUserId,@I_iSourceCompanyNum,@sBankCurrencyId,@iMCFunctionalOriginating, 		/**/ 		/* Start of modifications - 06/07/06 - pjsparrow */ 		@cNC_OrigCtrlNum, @sNC_OrigTrxType, @iNC_OrigSeqNum 		/* End of modifications - 06/07/06 - pjsparrow */ end /* update of batch totals */ update SY00500 set  	BCHTOTAL = isnull((select sum(CRDTAMNT+DEBITAMT) from GL10001 where GL10001.BACHNUMB = SY00500.BACHNUMB),0),  	NUMOFTRX = isnull((select count(distinct JRNENTRY) from GL10001 where GL10001.BACHNUMB = SY00500.BACHNUMB),0) where BACHNUMB = @sBatchNumber select @I_sUserId = ltrim(rtrim(system_user)) /*Added vilasw*/ /* 27/06/2006 Mike South remove actvity record*/ 	/*delete from  DYNAMICS.dbo.SY00800 where USERID=@I_sUserId and CMPNYNAM=@sCompanyName and BACHNUMB=@sBatchNumber and BCHSOURC=@sBatchSource and WINTYPE=1*/ 	delete from  DYNAMICS.dbo.SY00800 where  CMPNYNAM=@sCompanyName and BACHNUMB=@sBatchNumber and BCHSOURC=@sBatchSource  /**/ /*Added vilasw*/ 	delete from SY00500 where BCHSOURC = @sBatchSource and BACHNUMB = @sBatchNumber and NUMOFTRX = 0  /*Added vilasw*/ /* tidy up */ close crInterfaceRecs deallocate crInterfaceRecs /* return result */ if @iTrnCount = 0 	select @sBatchNumber = ''	/* created no rows so clear batch number as posting not needed */ select @O_iError = 0, @O_sBatchNumber = @sBatchNumber set nocount off  
GO
GRANT EXECUTE ON  [dbo].[ncCreateDestICP] TO [DYNGRP]
GO
GRANT EXECUTE ON  [dbo].[ncCreateDestICP] TO [public]
GO
