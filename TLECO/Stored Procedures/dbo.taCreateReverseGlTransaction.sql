SET QUOTED_IDENTIFIER OFF
GO
SET ANSI_NULLS ON
GO
 create procedure [dbo].[taCreateReverseGlTransaction] @I_vINTERID char(5), @I_vDTAControlNum char(21), @I_vORMSTRID char(30), @I_vCUSTNAME char(64), @I_vCURNCYID char(15), @I_vCURRNIDX int,  @I_vDECPLCUR int, @I_vRATETPID char(15)='', @I_vRTCLCMTD smallint = 0, @I_vXCHGRATE numeric(19,7)=0, @I_vTIME1 datetime = '', @I_vEXCHDATE datetime = '', @I_vEXGTBLID char(15) = '', @I_vTRXDATE datetime,  @I_vDEBITAMT numeric(19,5), @I_vJRNENTRY int, @I_vCASHINDEX int, @I_vDEPINDEX int, @I_vTRXSORCE char(13), @I_vDENXRATE numeric(19,5) = 0, @I_vMCTRXSTT smallint = 0, @I_vDOCDATE datetime = '', @I_vORTRXDESC char(31) = '', @I_vORTRXTYP smallint, @I_vUSWHPSTD char(15) = '', @I_vBATCHTOTAL numeric(19,5) = null, @O_iErrorState int = NULL output, @oErrString varchar(255) = '' output  with encryption as  set transaction isolation level read uncommitted set nocount on  declare   @iStatement int,  @incmnt int,  @secondsdgstr varchar(50),  @datedgstr varchar(50),  @DTA_Index numeric (19,5),  @date datetime,  @day int,  @month int,  @hours int,  @year int,  @seconds int,  @secondsdg int,  @datedg int,  @iStatus int,  @iError int,  @O_iBtchHdrErrState int,  @O_oErrorState int,  @iCreateBatchErrString varchar(255),  @sCompanyID smallint,  @aaSubLedgerHdrID int,  @FUNLCURR char(15),  @FUNLCURRINDX smallint,   @FUNLDECPLCUR smallint,  @PERIODID smallint,  @OPENYEAR smallint,  @ISMCTRX tinyint   select   @iStatement = 0,  @O_iErrorState = 0,  @oErrString = '',  @iStatus = 0,  @date = getdate(),  @day = DATEPART(dd, @date),  @month = DATEPART(mm, @date),  @hours = DATEPART(hh, @date),  @year = DATEPART(yy, @date),  @seconds = DATEPART(ss, @date),  @secondsdg = @hours*3600,  @secondsdgstr = str(@secondsdg + @seconds + @month),  @incmnt = 5 - len(@secondsdgstr),  @secondsdgstr = ltrim(@secondsdgstr),  @O_iBtchHdrErrState = 0,  @sCompanyID = '',  @aaSubLedgerHdrID = 0,  @PERIODID = 0,  @OPENYEAR = 0,  @ISMCTRX = 0   while @incmnt > 0  begin  select @secondsdgstr = '0'+ ltrim(@secondsdgstr)   select @incmnt = @incmnt - 1 end  select @datedg = @day + @month * 31,  @datedgstr = substring(ltrim(str(@datedg)),1,3),  @incmnt = 3 - len(@datedgstr) while @incmnt > 0  begin  select @datedgstr = '0' + ltrim(@datedgstr)  select @incmnt = @incmnt - 1 end  select @datedgstr  = @datedgstr + substring(str(@year),3,2)   select @DTA_Index =   convert(numeric(19,5),ltrim(str(@I_vJRNENTRY)) +  rtrim(ltrim(@secondsdgstr)) +  '.' +  rtrim(ltrim(@datedgstr)))  select @sCompanyID = CMPANYID from DYNAMICS..SY01500 c (nolock) where c.INTERID = db_name()  select @FUNLCURR = FUNLCURR from MC40000 (nolock) select  @FUNLCURRINDX = CURRNIDX,  @FUNLDECPLCUR = DECPLCUR - 1  from DYNAMICS..MC40200 (nolock) where CURNCYID = @FUNLCURR  if (@FUNLCURR <> @I_vCURNCYID) and (@I_vCURNCYID <> '')   select @ISMCTRX = 1 select @OPENYEAR = YEAR1 from SY40101 a (nolock) where @I_vTRXDATE BETWEEN a.FSTFSCDY and a.LSTFSCDY select TOP(1)@PERIODID = PERIODID from SY40100 a (nolock) where a.YEAR1 = @OPENYEAR and @I_vTRXDATE between a.PERIODDT and a.PERDENDT and a.SERIES = 2 and a.ODESCTN = 'General Entry' and CLOSED = 0 Order By PERIODID   insert into GL10000 ( BACHNUMB,  BCHSOURC,  JRNENTRY,  SOURCDOC,  REFRENCE,  TRXDATE,  PSTGSTUS,  USWHPSTD,  SQNCLINE,  SERIES,  ORPSTDDT,  ORTRXSRC,  DTAControlNum,  DTATRXType,  DTA_Index,  CURNCYID,  CURRNIDX,  PRNTSTUS,  DENXRATE,    MCTRXSTT,     DOCDATE,    Tax_Date,     VOIDED,     Original_JE,    Original_JE_Year,   Original_JE_Seq_Num,   Correcting_Trx_Type,   RATETPID,  XCHGRATE,  TIME1,  EXCHDATE,  EXGTBLID,  PERIODID,  Ledger_ID  ) select   @I_vTRXSORCE,  'GL_Normal',  @I_vJRNENTRY,  'CRJ',  'Sales Deposits',  @I_vTRXDATE,  1,  @I_vUSWHPSTD,  16384,  3,  @I_vTRXDATE,  @I_vTRXSORCE,  @I_vDTAControlNum,  @I_vORTRXTYP,  convert(numeric (19,5), @DTA_Index),  @I_vCURNCYID,  @I_vCURRNIDX,  1,  @I_vDENXRATE,     @I_vMCTRXSTT,     @I_vDOCDATE,      '',          0,      0,      0,      0,      0,       @I_vRATETPID,  @I_vXCHGRATE,  @I_vTIME1,  @I_vEXCHDATE,  @I_vEXGTBLID,  @PERIODID,  1 if @@error <> 0 begin  select @O_iErrorState = 3430    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  insert into GL10001 (  BACHNUMB,  JRNENTRY,  SQNCLINE,  ACTINDX,  DSCRIPTN,  CURRNIDX,  ACCTTYPE,  DECPLACS,  ORCTRNUM,  ORDOCNUM,  ORMSTRID,  ORMSTRNM,  ORTRXDESC,  DTA_GL_Status,  INTERID,  CRDTAMNT,  ORCRDAMT,  DENXRATE,  MCTRXSTT,  LNESTAT,  ORTRXTYP,  EXGTBLID,  XCHGRATE,  RATETPID,  EXCHDATE,  TIME1,  RTCLCMTD  ) select  @I_vTRXSORCE,  @I_vJRNENTRY,  16384,  @I_vCASHINDEX,  'CASH',  @FUNLCURRINDX,  1,  @FUNLDECPLCUR,  @I_vDTAControlNum,  @I_vDTAControlNum,  @I_vORMSTRID,  @I_vCUSTNAME,  @I_vORTRXDESC,  40,  @I_vINTERID,  case   when @I_vRTCLCMTD = 0  then round(@I_vDEBITAMT * @I_vXCHGRATE, @I_vDECPLCUR)  when @I_vRTCLCMTD = 1  then round(@I_vDEBITAMT / @I_vXCHGRATE, @I_vDECPLCUR)  else @I_vDEBITAMT  end,  @I_vDEBITAMT,  @I_vDENXRATE,  @I_vMCTRXSTT,  5,  @I_vORTRXTYP,  @I_vEXGTBLID,  @I_vXCHGRATE,  @I_vRATETPID,  @I_vEXCHDATE,  @I_vTIME1,  case  when @I_vRTCLCMTD = -1  then 0  else @I_vRTCLCMTD  end if @@error <> 0 begin  select @O_iErrorState = 2934    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  insert into GL10001 ( BACHNUMB,  JRNENTRY,  SQNCLINE,  ACTINDX,  DSCRIPTN,  CURRNIDX,  ACCTTYPE,  DECPLACS,  ORCTRNUM,  ORDOCNUM,  ORMSTRID,  ORMSTRNM,  ORTRXDESC,  DTA_GL_Status,  INTERID,  DEBITAMT,  ORDBTAMT,  DENXRATE,  MCTRXSTT,  LNESTAT,  ORTRXTYP,  EXGTBLID,  XCHGRATE,  RATETPID,  EXCHDATE,  TIME1,  RTCLCMTD  ) select    @I_vTRXSORCE,  @I_vJRNENTRY,  32768,  @I_vDEPINDEX,  'DEPOSITS',  @FUNLCURRINDX,  1,  @FUNLDECPLCUR,  @I_vDTAControlNum,  @I_vDTAControlNum,  @I_vORMSTRID,  @I_vCUSTNAME,  @I_vORTRXDESC,  40,  @I_vINTERID,  case   when @I_vRTCLCMTD = 0  then round(@I_vDEBITAMT * @I_vXCHGRATE, @I_vDECPLCUR)  when @I_vRTCLCMTD = 1  then round(@I_vDEBITAMT / @I_vXCHGRATE, @I_vDECPLCUR)  else @I_vDEBITAMT  end,  @I_vDEBITAMT,  @I_vDENXRATE,  @I_vMCTRXSTT,  5,  @I_vORTRXTYP,  @I_vEXGTBLID,  @I_vXCHGRATE,  @I_vRATETPID,  @I_vEXCHDATE,  @I_vTIME1,  case  when @I_vRTCLCMTD = -1  then 0  else @I_vRTCLCMTD  end if @@error <> 0 begin  select @O_iErrorState = 2935    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end   select @I_vDEBITAMT = (@I_vDEBITAMT*2)  if (@I_vBATCHTOTAL is null)  begin  select @I_vBATCHTOTAL = @I_vDEBITAMT end else begin  select @I_vBATCHTOTAL = @I_vBATCHTOTAL*2 end  exec @iStatus = taCreateUpdateBatchHeaderRcd  @I_vBACHNUMB = @I_vTRXSORCE,  @I_vSERIES = 2,  @I_vGLPOSTDT = @I_vTRXDATE,  @I_vBCHSOURC = 'GL_Normal',  @I_vDOCAMT = @I_vBATCHTOTAL,  @I_vORIGIN = 1,  @I_vNUMOFTRX = 1,  @I_vBRKDNALL = 1,  @I_vBCHCOMNT = 'Sales Deposits',  @O_iErrorState = @O_iBtchHdrErrState output,  @oErrString = @iCreateBatchErrString output select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError if (@iStatus <> 0) or (@O_iBtchHdrErrState <> 0) begin  select @oErrString = rtrim(isnull(@oErrString, '')) + ' ' + @iCreateBatchErrString  select @O_iErrorState = 2936   exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  if exists(select 1 from DYNAMICS..sysobjects (nolock) where name  = 'AAG00102') begin  if exists(select 1 from DYNAMICS..AAG00102 (nolock) where CMPANYID = @sCompanyID)  begin   select @aaSubLedgerHdrID = isnull(aaSubLedgerHdrID,0) from AAG20000 (nolock)  where DOCTYPE = @I_vORTRXTYP  and DOCNUMBR = @I_vDTAControlNum   if @aaSubLedgerHdrID <> 0  begin  exec @iStatus = aagCreateVoideRecordInGLForBR   @aaSubLedgerHdrID = @aaSubLedgerHdrID,   @JRNENTRY = @I_vJRNENTRY,   @lastDist = 0,   @GLPOSTDT = @I_vTRXDATE,   @CompanyID = @sCompanyID,  @MCRegistered = @ISMCTRX   if (@@error <> 0)   begin  select @O_iErrorState = 8202    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState)  end  end  end end  return (@O_iErrorState)   
GO
GRANT EXECUTE ON  [dbo].[taCreateReverseGlTransaction] TO [DYNGRP]
GO
