SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
 create procedure [dbo].[glpPostBatch]  @I_iSQLSessionID int   = NULL,  @I_cBatchSource char(15) = NULL,  @I_cBatchNumber char(15) = NULL,  @I_cTransactionSource char(25) = NULL,  @I_sTransactionType smallint = NULL,  @I_cUserID char(15) = NULL,  @I_tPrinting tinyint  = NULL output,  @I_tPosting tinyint  = NULL output,  @I_sWindowType smallint = NULL,  @I_cCompanyName char(64) = NULL,  @I_sCompanyID smallint = NULL,  @I_cFuncCurrencyID char(15) = NULL,  @I_sFuncCurrencyIndex smallint = NULL,  @I_sFuncDecimalPlaces smallint = NULL,  @I_tMCRegistered tinyint  = NULL,  @I_tMCReport tinyint  = NULL,  @I_tICRegistered tinyint  = NULL,  @I_cOrigIntercompanyID char(5)  = NULL,  @I_cProductName char(30) = NULL,  @I_tMDARegistered tinyint  = NULL,  @I_tCalculateGLTaxes tinyint  = NULL,  @I_tUseTaxPeriods    tinyint     = NULL,  @O_iErrorState int   = NULL output as  set deadlock_priority low set arithabort off set nocount on  declare  @TRUE                           tinyint,  @FALSE                          tinyint,  @NORMAL_TRX smallint,  @BUDGET_TRX smallint,   @RECUR_TRX smallint,  @BUSINESS_FORM                  smallint,  @POSTED smallint,  @UNPOSTED                       smallint,  @BATCH_AVAILABLE                smallint,  @BATCH_POSTING                  smallint,  @BATCH_PRINTING                 smallint,  @BATCH_POSTED_WITH_ERROR        smallint,  @BATCH_POSTING_INCOMPLETE       smallint,  @BATCH_PRINTING_INCOMPLETE      smallint,  @BATCH_UPDATING_INCOMPLETE      smallint,  @BATCH_RECURRING_INCOMPLETE     smallint,  @FINANCIAL                      smallint,  @SERIES_WINDOW                  smallint,  @MASTER_WINDOW                  smallint,  @RECOVERY_WINDOW                smallint,  @TRACKING_INITIALIZE            smallint,  @TRACKING_ERROR                 smallint,  @SINGLE_USE                     smallint,  @MS_ITEM_4                      int,  @MS_ITEM_1                int,  @DEFAULT_DATE                   datetime,  @DELETE_REPORT smallint,  @DISPLAY_REPORT smallint,  @tMultipleBatches               tinyint,  @tContinue                      tinyint,  @cBatchNumber                   char(15),  @cTempBatchNumber               char(15),  @sBatchFrequency                smallint,  @sBatchStatus                   smallint,  @tPrintDistributions            tinyint,  @sControlPostings               smallint,  @sActualPostings                smallint,  @sOrigin                        smallint,  @tBatchApproval                 tinyint,  @mActualBatchTotal              numeric(19,5),  @mControlBatchTotal             numeric(19,5),  @iActualNumberOfTRX             int,  @iControlNumberOfTRX            int,  @tDeleteBatch                   tinyint,  @iJournalEntry                  int,  @iTempJournalEntry              int,  @cOpenAuditTrailCode            char(13),  @cHistoryAuditTrailCode         char(13),  @cICOpenAuditTrailCode char(13),  @cICHistoryAuditTrailCode char(13),  @mSequenceLine                  numeric(19,5),  @bBatchMessages1                binary(4),  @bBatchMessages2                binary(4),  @bHeaderMessages                binary(4),   @bHeaderMessages2               binary(4),   @bLineMessages                  binary(4),   @bLineMessages2                 binary(4),   @bOffsetMessages                binary(4),   @bOffsetMessages2               binary(4),   @bBatchValid                    binary(4),  @tLoop                          tinyint,  @iPrintErrorState               int,  @iPostErrorState                int,  @iErrorState                    int,  @iError                         int,  @iStatus                        int,  @iRowCount int,  @sCurrencyIndex                 smallint,  @sDecimalPlaces                 smallint,  @iTranCount int,  @iPostedCount int,  @tCursorExists tinyint,  @tMarkedToPost tinyint,  @tAddBatchActivity tinyint,  @sActivityStatus smallint,  @tActivityTracking   tinyint,  @tFirst tinyint,  @tValidCurrency tinyint,  @iMCErrorState int,  @tMCPosting tinyint,  @iCursorState int,  @tHeaderCursorRemoved tinyint,  @tTempTablesCreated tinyint,  @iRelationID int,  @sUserLevel smallint,  @iAccessAllAccounts int,  @securityoptions int,  @tALSRegistered tinyint,  @cCompanyID char(5),  @dMinDate datetime,  @tICEREnabled    tinyint,  @ICMODULEID smallint,  @RULE_RESERVESTATE smallint,  @AllowReportingLedgers tinyint  select @AllowReportingLedgers = (select Allow_Reporting_Ledgers from GL40000)  select  @O_iErrorState   = 0,  @iMCErrorState   = 0,  @iStatus         = 0,  @iRelationID   = 0,  @sUserLevel    = 0,  @iAccessAllAccounts = 0,  @tALSRegistered  = 0  exec @iStatus = smGetMinDate @dMinDate output  while (@tLoop is NULL) begin  select @tLoop = 1   if @@trancount <> 0  begin  select @O_iErrorState = 20821  break  end   if @I_iSQLSessionID        is NULL or  @I_cBatchSource         is NULL or  @I_cBatchNumber         is NULL or  @I_cTransactionSource   is NULL or  @I_sTransactionType     is NULL or  @I_cUserID              is NULL or  @I_tPrinting            is NULL or  @I_tPosting             is NULL or  @I_sWindowType          is NULL or  @I_cCompanyName   is NULL or  @I_sCompanyID           is NULL or  @I_cFuncCurrencyID      is NULL or   @I_sFuncCurrencyIndex   is NULL or  @I_sFuncDecimalPlaces   is NULL or  @I_tMCRegistered        is NULL or  @I_tMCReport            is NULL or  @I_tICRegistered is NULL or  @I_tCalculateGLTaxes is NULL or   @I_cOrigIntercompanyID is NULL or   @I_cProductName is NULL or  @I_tMDARegistered is NULL   begin  select @O_iErrorState = 20283  break  end    select  @TRUE                           = 1,  @FALSE                          = 0,  @POSTED       = 2,  @UNPOSTED                       = 1,  @BATCH_AVAILABLE                = 0,  @BATCH_POSTING                  = 1,  @BATCH_PRINTING                 = 5,  @BATCH_POSTED_WITH_ERROR        = 11,  @BATCH_POSTING_INCOMPLETE       = 7,  @BATCH_PRINTING_INCOMPLETE      = 8,  @BATCH_UPDATING_INCOMPLETE      = 9,  @BATCH_RECURRING_INCOMPLETE     = 10,  @NORMAL_TRX      = 1,  @BUDGET_TRX      = 4,    @RECUR_TRX      = 1,  @BUSINESS_FORM                  = 5,  @FINANCIAL                      = 2,   @SERIES_WINDOW                  = 3,  @MASTER_WINDOW                  = 4,  @RECOVERY_WINDOW                = 5,  @TRACKING_INITIALIZE            = 1,  @TRACKING_ERROR                 = 3,  @SINGLE_USE                     = 1,  @MS_ITEM_4                      = power(2,27),  @MS_ITEM_1                 = power(2,24),  @DEFAULT_DATE                   = @dMinDate,  @DELETE_REPORT     = 1,  @ICMODULEID      = 22,  @DISPLAY_REPORT     = 0   exec @iStatus = DYNAMICS..smGetConstantInt  'RULE_RESERVESTATE',  @RULE_RESERVESTATE output,  @O_iErrorState    output  select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if (@O_iErrorState <> 0) or (@iStatus <> 0)   return (@iStatus)   select   @cBatchNumber           = @I_cBatchNumber,  @tContinue              = @TRUE,  @bBatchMessages1        = 0x00000000,  @bBatchMessages2        = 0x00000000,  @iErrorState            = 0,  @tHeaderCursorRemoved = @TRUE,    @tICEREnabled    = @FALSE   select @cCompanyID = db_name()   exec @iStatus = DYNAMICS..smGetAccountLevelSecurityInfo  @cCompanyID,  @iRelationID output,  @sUserLevel  output,  @iAccessAllAccounts output,  @tALSRegistered output   select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError   create table #MCAccounts(  AccountIndex int not null,  CurrencyID char(15) not null,  CurrencyIndex smallint not null,  FunctionalDebit numeric(19,5)  not null,  FunctionalCredit numeric(19,5)  not null,  OriginatingDebit numeric(19,5)  not null,  OriginatingCredit numeric(19,5)  not null)   create table #Distributions(  SQLSessionID int not null,   AllocationIndex int not null,   DistributionIndex int not null,   Percentage numeric(19,5)  not null,   LineMessage binary(4) not null,  LineMessages2 binary(4) not null,   AccountType smallint not null,   Active tinyint not null,  Debit numeric(19,5)  not null,   Credit numeric(19,5)  not null,   OriginatingDebit numeric(19,5)  not null,  OriginatingCredit numeric(19,5)  not null,  PostingType smallint not null,   AllocationType smallint not null,   Segment char(66) not null,  UnitDecimalPlaces smallint not null,  CurrencyID char(15) not null,  Verified tinyint not null)   create table #HistorySetup (  SQLSessionID int not null,   KeepingTransactionHistory tinyint not null,  KeepingAccountHistory tinyint not null,  KeepingMCSummaryHistory tinyint not null,  DivisionalClosing tinyint not null,  RetainedEarningsIndex int not null,  DivisionalAccountSegment smallint not null,  BeforeSegmentLength tinyint not null,  DivisionalSegmentLength tinyint not null,  AfterSegmentLength tinyint not null,  ClosingDate datetime not null)   create table #Breakdowns (  SQLSessionID int not null,  AllocationIndex int not null,  DistributionIndex int not null,  BreakdownIndex int not null,  Percentage numeric(19,5)  not null,  LineMessage binary(4) not null,  AccountType smallint not null,  Active tinyint not null,  Debit numeric(19,5)  not null,  Credit numeric(19,5)  not null,  AllocationType smallint not null)   create table #RetainedEarn (  tVerified               int             not null,  iSQLSessionID           int             not null,  cSegment                char(66)        not null,  iAccountIndex           int             not null,  sAccountType            smallint        not null,  sPostingType            smallint        not null,  tActive                 tinyint   not null,  sFixedOrVariable        smallint        not null,  bLineMessages           binary(4)       not null,  tDistributionsExist  tinyint      not null,  cCurrencyID             char(15)   not null)  create table #AcctCurrency (  iAccountIndex     int    not null,  cCurrencyID             char(15)  not null,  sCurrencyIndex          smallint  not null,  sAccountType            smallint   not null,  bLineMessages2    binary(4)   not null,  mFuncDebit              numeric(19,5)   not null,  mFuncCredit             numeric(19,5)   not null,  mOrigDebit              numeric(19,5)   not null,  mOrigCredit             numeric(19,5)   not null,  sOrigDecimalPlaces      smallint  not null,  sRateCalcMethod   smallint  not null,  cRateTypeID             char(15)  not null,  cExchangeTableID        char(15)  not null,  tVerified               int    not null)   create table #Breakout (  IntercompanyID char(5)  not null,  DestICID char(5)  not null,  UserAccess tinyint not null,  FunctionalDebitTotal   numeric(19,5) not null,  FunctionalCreditTotal   numeric(19,5) not null,  OriginatingDebitTotal  numeric(19,5) not null,  OriginatingCreditTotal  numeric(19,5) not null,  CompanyID smallint not null,  AccountIndex int not null,  SequenceLine numeric(19,0) not null IDENTITY(500,500),  ExchangeRate numeric(15,7) not null,  DecimalPlaces smallint not null,  RateCalculationMethod smallint not null,  CurrencyIndex smallint not null,  RateTypeID char(15) not null,  ExchangeTableID char(15) not null,  ExchangeDate datetime not null,  ExchangeTime datetime not null,  DenomExchangeRate numeric(15,7) not null,  MCTrxState smallint not null,  CorrespondingUnit char(5)  not null)  create table #Company (  IntercompanyID char(5)  not null,  CompanyName char(30)  not null,  CompanyID smallint  not null,  UserAccess tinyint not null,  FunctionalCurrency char(15) not null,  SourceDocument char(11) not null,  BatchNumber char(15) not null,  LineMessages2 binary(4) not null,  DatabaseName char(10) not null)  create table #TRXHeader (  JournalEntry int not null,  BatchNumber char(15) not null,  BatchSource char(15) not null,  TransactionType smallint not null,  SourceDocument char(10) not null,  Series smallint not null,  Reference char(31) not null,  TRXSource char(13) not null,  ReversingTRXSource char(13) not null,  RecurringTRX smallint not null,  RecurringTRXSequence numeric(19,5) not null,  TransactionDate datetime not null,  TransactionPeriodID smallint not null,  TransactionYear smallint not null,  TransactionClosingYear smallint not null,  TransactionHistory tinyint not null,  ReversingDate datetime not null,  ReversingPeriodID smallint not null,  ReversingYear smallint not null,  ReversingClosingYear smallint not null,  ReversingHistory tinyint not null,  CurrencyID char(15) not null,  CurrencyIndex smallint not null,  RateTypeID char(15) not null,  ExchangeTableID char(15) not null,  ExchangeRate numeric(15,7) not null,  ExchangeDate datetime not null,  ExchangeTime datetime not null,  RateCalculationMethod smallint not null,  BalanceForCalculation smallint not null,  ControlBalance numeric(19,5) not null,  OffsetAccountIndex int not null,  OffsetAccountType smallint not null,  OffsetFixedOrVariable smallint not null,  OffsetPostingType smallint not null,  PostingStatus smallint not null,  HeaderValid binary(4) not null,  HeaderMessages binary(4) not null,  HeaderMessages2 binary(4) not null,  ICTransaction tinyint not null,  ICDistributionsExist tinyint not null,  OrigIntercompanyID char(5)  not null,  OrigTransactionSource char(13) not null,  OrigDTASeries smallint not null,  DTAIndex numeric(19,5) not null,  DenomExchangeRate numeric(15,7) not null,  MCTrxState smallint not null,  DocumentDate datetime not null,  TaxDate datetime not null,  OriginalJE       int      not null,  OriginalJEYear smallint    not null,  OriginalJESeqNum numeric(19,5) not null,  CorrectingTrxType     int     not null,  Ledger_ID int not null,  Adjustment_Transaction tinyint not null)   create table #LineItems (  IntercompanyID char(5)  not null,  CompanyID smallint not null,  FunctionalCurrency char(15) not null,  SequenceLine numeric(19,5) not null,  AccountIndex int not null,  TRXDebit    numeric(19,5)  not null,  TRXCredit    numeric(19,5)  not null,  OriginatingDebit numeric(19,5) not null,  OriginatingCredit numeric(19,5) not null,  Description char(31) not null,  CurrencyIndex smallint not null,  RateTypeID char(15) not null,  ExchangeTableID char(15) not null,  ExchangeRate numeric(15,7) not null,  ExchangeDate datetime not null,  ExchangeTime datetime not null,  RateCalculationMethod smallint not null,  LineValid binary(4) not null,  AccountType smallint not null,  FixedOrVariable smallint not null,  BalanceForCalculation smallint not null,  PostingType smallint not null,  DecimalPlaces smallint not null,  OrigControlNumber char(21) not null,  OrigDocumentNumber char(21) not null,  OrigMasterID char(31) not null,  OrigMasterName char(65) not null,  OrigTransactionType smallint not null,  OrigTRXDesc char(30) not null,  OrigSeqNum int not null,  DTAGLStatus smallint not null,  LineMessages2 binary(4) not null,  DatabaseName char(10) not null,   SystemGenerated tinyint not null,  DenomExchangeRate numeric(15,7) not null,  MCTrxState smallint not null,  LineStatus smallint not null,  CorrespondingUnit char(5)  not null)   create table #DistErrors(  SQLSessionID int not null,   AllocationIndex int not null,   DistributionIndex int not null,   DistMessages2 binary(4) not null)   create table #ReportSetup (  PrintDistributions tinyint not null,  MCRegistered tinyint not null,  MCReport tinyint not null)   create table #DTATempWork(  GROUPID char(15) not null,  ROUNDAMT numeric(19,5) not null,  GROUPAMT  numeric(19,5) not null,   CODEID char(15) not null,  SEQNUMBR int not null,  PERCENTAMOUNT smallint not null)    create table #AccountNumberInfo (  AccountType          smallint not NULL,  Active               tinyint not NULL,  AccountCategory smallint not NULL,  FixedOrVariable         smallint not NULL,  BalanceForCalculation   smallint not NULL,  PostingType             smallint not NULL,  UnitDecimalPlaces       smallint not NULL)   create table #accttype   (AccountType smallint)   create table #REAccount (  ACCTTYPE smallint,  PSTNGTYP smallint,  ACTIVE tinyint,  FXDORVAR smallint,  ACTINDX  int)   select @tTempTablesCreated = @TRUE   if @I_cBatchNumber = ''  select @tMultipleBatches = @TRUE  else  select @tMultipleBatches = @FALSE   select   @tCursorExists = @FALSE,  @tFirst = @TRUE   while @tContinue = @TRUE  begin  if @tFirst = @FALSE  begin  if @iStatus <> 0 or   @O_iErrorState <> 0 or  @iMCErrorState <> 0  begin  if @iStatus <> 0 or  (@bBatchMessages1 = 0x00000000 and   @bBatchMessages2 = 0x00000000)  begin  select   @sBatchStatus = @BATCH_POSTING_INCOMPLETE,  @tMarkedToPost = @FALSE,  @tAddBatchActivity = @FALSE,  @sActivityStatus = @TRACKING_ERROR,  @tDeleteBatch = @FALSE,  @tActivityTracking = @TRUE  end    else  begin  select   @sBatchStatus = @BATCH_PRINTING,  @tMarkedToPost = @TRUE,  @tAddBatchActivity = @TRUE,  @sActivityStatus = @TRACKING_ERROR,  @tDeleteBatch = @FALSE,  @tActivityTracking = @FALSE  end   end    else  begin  select   @sBatchStatus  = @BATCH_PRINTING,  @tMarkedToPost  = @TRUE,  @tAddBatchActivity = @TRUE,  @sActivityStatus = @TRACKING_INITIALIZE,  @tActivityTracking = @FALSE  end    if @iErrorState = 0  select @iErrorState = @O_iErrorState   if @I_tPosting    = @TRUE and  @I_sTransactionType  = @NORMAL_TRX and  @sBatchStatus   = @BATCH_PRINTING and  (@cICOpenAuditTrailCode <> '' or  @cICHistoryAuditTrailCode <> '')  begin  exec @iStatus = icpUpdateDestinationCompanies  @I_cUserID,  @I_cOrigIntercompanyID,  @O_iErrorState output   select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if @iStatus <> 0 or @O_iErrorState <> 0   break  end     exec @iStatus = glpUpdateBatchStatus  @I_iSQLSessionID,  @cBatchNumber,  @I_cBatchSource,  @sBatchStatus,  @I_cTransactionSource,  @tMarkedToPost,  @I_cUserID,  @I_cCompanyName,  @I_sWindowType,  @tAddBatchActivity,  @sActivityStatus,  @bBatchMessages1,  @bBatchMessages2,  @tActivityTracking,  @tDeleteBatch,  @I_tPosting,  @O_iErrorState,  @O_iErrorState output   select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError   if @tMultipleBatches = @FALSE or  @iStatus <> 0  break   end    select   @bBatchMessages1 = 0x00000000,  @bBatchMessages2 = 0x00000000,  @O_iErrorState = 0,  @tFirst = @FALSE   if @tMultipleBatches = @TRUE  begin  if @tCursorExists = @FALSE  begin  declare  BatchCursor INSENSITIVE  cursor for select  BACHNUMB,  BACHFREQ,  BCHSTTUS,  BRKDNALL,  ORIGIN,  APPROVL,  BCHTOTAL,  CNTRLTOT,  NUMOFTRX,  CNTRLTRX,  NOFPSTGS,  RECPSTGS,  GLBCHVAL  from  SY00500  where   BCHSOURC = @I_cBatchSource  and BACHNUMB in ( select RSRCID from DYNAMICS.dbo.SY00801  where RULEID = @RULE_RESERVESTATE  and RSRCSBID = @I_cBatchSource  and CMPANYID = @I_sCompanyID  and USERID = @I_cUserID  and RSRDESC = str(@I_iSQLSessionID) )  and MKDTOPST = @TRUE  and USERID  = @I_cUserID  and (BCHSTTUS = @BATCH_AVAILABLE  or BCHSTTUS = @BATCH_POSTING_INCOMPLETE)  order by  BCHSOURC,  BACHNUMB   open BatchCursor   select @tCursorExists = @TRUE   if @@cursor_rows = 0  begin  if @I_sWindowType <> @RECOVERY_WINDOW  begin  select @O_iErrorState = 20503  break  end  end  end      fetch next from  BatchCursor  into  @cBatchNumber,  @sBatchFrequency,  @sBatchStatus,  @tPrintDistributions,  @sOrigin,  @tBatchApproval,  @mActualBatchTotal,  @mControlBatchTotal,  @iActualNumberOfTRX,  @iControlNumberOfTRX,  @sActualPostings,  @sControlPostings,  @bBatchValid   if @@fetch_status <> 0  begin  if @@fetch_status = -2  begin   select @O_iErrorState = 20485  break  end  break  end   delete #Company   end    else  begin  select  @sBatchFrequency        = BACHFREQ,  @sBatchStatus           = BCHSTTUS,  @tPrintDistributions    = BRKDNALL,  @sOrigin                = ORIGIN,  @tBatchApproval         = APPROVL,  @mActualBatchTotal      = BCHTOTAL,  @mControlBatchTotal     = CNTRLTOT,  @iActualNumberOfTRX     = NUMOFTRX,  @iControlNumberOfTRX    = CNTRLTRX,  @sActualPostings        = NOFPSTGS,  @sControlPostings       = RECPSTGS,  @bBatchValid            = GLBCHVAL  from  SY00500  where   BCHSOURC = @I_cBatchSource   and     BACHNUMB = @cBatchNumber  and BACHNUMB in (select RSRCID from DYNAMICS.dbo.SY00801  where RULEID = @RULE_RESERVESTATE  and RSRCID = @cBatchNumber  and RSRCSBID = @I_cBatchSource  and CMPANYID = @I_sCompanyID  and USERID = @I_cUserID  and RSRDESC = str(@I_iSQLSessionID) )   if @@rowcount <> 1  begin  select @O_iErrorState = 20286  continue  end   end     if @I_sWindowType <> @RECOVERY_WINDOW and @sBatchStatus <> @BATCH_POSTING_INCOMPLETE  begin  update  PJOURNAL  set REPORT = @DELETE_REPORT  where  USERID  = @I_cUserID  and BCHSOURC = @I_cBatchSource  and   BACHNUMB = @cBatchNumber  and REPORT = @DISPLAY_REPORT  end   if @I_tPosting = @TRUE  begin  exec @iStatus = glpUpdateBatchStatus  @I_iSQLSessionID,  @cBatchNumber,  @I_cBatchSource,  @BATCH_POSTING,    @I_cTransactionSource,  @TRUE,      @I_cUserID,  @I_cCompanyName,  @I_sWindowType,  @TRUE,     @TRACKING_INITIALIZE,   @bBatchMessages1,   @bBatchMessages2,  @TRUE,     @FALSE,     @TRUE,  @O_iErrorState,   @O_iErrorState output   select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if (@O_iErrorState <> 0) or (@iStatus <> 0)  break   if @sBatchFrequency > @SINGLE_USE   begin   if (@sControlPostings <= @sActualPostings) and  (@sControlPostings <> 0)  begin  select @O_iErrorState = 20484  continue  end   else if (@sControlPostings = @sActualPostings + 1)  select @tDeleteBatch = @TRUE  else  select @tDeleteBatch = @FALSE  end    else  select @tDeleteBatch = @TRUE  end    else  select @tDeleteBatch = @FALSE    if @I_tPosting = @FALSE and   @I_sTransactionType <> @BUSINESS_FORM  begin  exec @iStatus = glpVerifyBatch  @I_iSQLSessionID,  @I_cBatchSource,  @cBatchNumber,  @I_cTransactionSource,  @sOrigin,  @tBatchApproval,  @mActualBatchTotal,  @mControlBatchTotal,  @iActualNumberOfTRX,  @iControlNumberOfTRX,  @I_tMCRegistered,  @I_cFuncCurrencyID,  @I_sCompanyID,  @bBatchMessages1 output,  @bBatchMessages2 output,  @O_iErrorState output   select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError   if (@O_iErrorState <> 0) or (@iStatus <> 0)  continue   end    exec @iStatus = glpGetValidationState   @I_cBatchSource,  @cBatchNumber,   @bBatchValid    output,  @O_iErrorState  output    select @iError = @@error   if @iStatus = 0 and @iError <> 0  select @iStatus = @iError   if @iStatus <> 0 or @O_iErrorState <> 0   continue   select   @bHeaderMessages = 0x00000000,  @bHeaderMessages2 = 0x00000000   if @I_tMCRegistered = @TRUE and   @I_sTransactionType <> @BUSINESS_FORM  begin  select   @tValidCurrency = @FALSE,  @tMCPosting = @I_tPosting,  @iMCErrorState = 0   while @tValidCurrency = @FALSE  begin  exec @iStatus = glpmcVerifyCurrency  @I_sCompanyID,  @I_cFuncCurrencyID,  @DEFAULT_DATE,  1.0000,  ' ',  @DEFAULT_DATE,   @TRUE,  @TRUE,   @tMCPosting,   @FALSE,   ' ',  @DEFAULT_DATE,  0,     @bBatchMessages2 output,  @sCurrencyIndex         output,  @sDecimalPlaces         output,  @iMCErrorState          output    select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError    select @tValidCurrency = @TRUE   if @iStatus <> 0  break   if @iMCErrorState <> 0 and @tMCPosting = @TRUE   begin  if @I_tPrinting = @TRUE  begin  select   @tMCPosting = @FALSE,   @O_iErrorState = @iMCErrorState,  @tValidCurrency = @FALSE   select @iMCErrorState = 0  end  else if @iMCErrorState <> 0  select @O_iErrorState = @iMCErrorState    end   end    if @iStatus <> 0 or @O_iErrorState <> 0  continue  end     if @I_tICRegistered = @TRUE  select @tICEREnabled = @TRUE   where   exists( select 1   from   DYNAMICS..SY80000   where   MODULEID = @ICMODULEID   and  (MODOPTIONS | @MS_ITEM_1) = @MS_ITEM_1)  else  select @tICEREnabled = @FALSE   if @tHeaderCursorRemoved = @FALSE  deallocate HeaderCursor   if @I_sTransactionType = @BUSINESS_FORM  declare  HeaderCursor INSENSITIVE  cursor for select  JRNENTRY  from  GL10100 with (NOLOCK)  where  BSNSFMID  = @cBatchNumber  and     PSTGSTUS = @UNPOSTED   else if @I_sTransactionType = @BUDGET_TRX   declare  HeaderCursor INSENSITIVE  cursor for select  JRNENTRY  from  GL12000 with (NOLOCK)  where  BCHSOURC = @I_cBatchSource   and BACHNUMB = @cBatchNumber  and PSTGSTUS = @UNPOSTED   else if @I_tPosting = @FALSE and  @I_tPrinting = @TRUE   declare  HeaderCursor INSENSITIVE  cursor for select  JRNENTRY  from  GL10000 with (NOLOCK)  where  BCHSOURC = @I_cBatchSource   and BACHNUMB = @cBatchNumber  and (PSTGSTUS = @UNPOSTED   or RCRNGTRX = @RECUR_TRX)  order by JRNENTRY   else  declare  HeaderCursor INSENSITIVE  cursor for select  JRNENTRY  from  GL10000 with (NOLOCK)  where  BCHSOURC = @I_cBatchSource   and BACHNUMB = @cBatchNumber  and PSTGSTUS = @UNPOSTED  order by JRNENTRY   open HeaderCursor   select @iCursorState = @@cursor_rows   select @tHeaderCursorRemoved = @FALSE   if @iCursorState = 0 or @iCursorState = -1  begin  exec @iStatus = glpVerifyBatchTransactions  @I_cBatchSource,  @cBatchNumber,  @I_sTransactionType,  @bBatchMessages1 output,  @O_iErrorState      output    select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if @iStatus <> 0 or @O_iErrorState <> 0   continue  end    if @I_sTransactionType = @NORMAL_TRX  begin  exec @iStatus = icpVerifyIC  @cBatchNumber,  @I_cBatchSource,  @I_cOrigIntercompanyID,  @I_tICRegistered,  @bHeaderMessages output,  @O_iErrorState      output   select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if @iStatus <> 0 or @O_iErrorState <> 0   continue   if @I_tICRegistered = @TRUE  begin  exec @iStatus = icpVerifyCompany  @cBatchNumber,  @I_cBatchSource,  @I_cOrigIntercompanyID,   @I_cUserID,   @sBatchFrequency,   @I_tMCRegistered,  @I_cFuncCurrencyID,  @I_tPosting,  @bLineMessages2 output,  @O_iErrorState output    select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if @iStatus <> 0 or @O_iErrorState <> 0   continue   end   end    if @sBatchStatus = @BATCH_POSTING_INCOMPLETE  begin  exec @iStatus = glpGetAuditTrailCodes  @I_cBatchSource,  @cBatchNumber,  @I_sTransactionType,  @I_tICRegistered,  @cOpenAuditTrailCode     output,   @cHistoryAuditTrailCode     output,  @cICOpenAuditTrailCode     output,   @cICHistoryAuditTrailCode   output,  @O_iErrorState              output   select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if @iStatus <> 0 or @O_iErrorState <> 0   continue   if @I_tPosting = @TRUE and  @I_sTransactionType = @NORMAL_TRX and  (@cICOpenAuditTrailCode <> '' or  @cICHistoryAuditTrailCode <> '')  begin  exec @iStatus = icpGetDestinationCompanies  @I_cOrigIntercompanyID,  @cICOpenAuditTrailCode,   @cICHistoryAuditTrailCode,  @I_sWindowType,  @I_cUserID,  @O_iErrorState                  output   select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if @iStatus <> 0 or @O_iErrorState <> 0   continue   end   end   else  select   @cOpenAuditTrailCode = ' ',  @cHistoryAuditTrailCode = ' ',  @cICOpenAuditTrailCode = ' ',  @cICHistoryAuditTrailCode = ' '   fetch next from   HeaderCursor  into   @iJournalEntry   while (@@fetch_status <> -1)  begin   if (@@fetch_status = -2)  begin     select @O_iErrorState = 20287   break  end   exec @iStatus = glpPostTransaction  @I_iSQLSessionID,  @I_sTransactionType,  @I_tPrinting,  @I_tPosting,  @FALSE,     @iJournalEntry,  @I_cUserID,  @I_cBatchSource,  @cBatchNumber,  @sBatchFrequency,  @tPrintDistributions,  @bBatchValid,  @tDeleteBatch,  @I_sCompanyID,  @I_cFuncCurrencyID,  @I_sFuncCurrencyIndex,  @I_sFuncDecimalPlaces,  @I_tMCRegistered,  @I_tMCReport,  @I_cProductName,  @I_sWindowType,  @I_tICRegistered,  @I_cOrigIntercompanyID,  @I_tMDARegistered,  @I_tCalculateGLTaxes,   @tICEREnabled,  @I_tUseTaxPeriods,  @AllowReportingLedgers,  @cOpenAuditTrailCode            output,  @cHistoryAuditTrailCode         output,  @cICOpenAuditTrailCode output,  @cICHistoryAuditTrailCode output,  @mSequenceLine                  output,  @bHeaderMessages                output,  @bHeaderMessages2               output,  @bLineMessages                  output,  @bLineMessages2                 output,   @bOffsetMessages                output,  @bOffsetMessages2               output,   @iPrintErrorState               output,  @iPostErrorState                output   select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError   if @iStatus <> 0   break   if @iPrintErrorState <> 0  begin  select  @O_iErrorState =  @iPrintErrorState  break  end   fetch next from   HeaderCursor  into   @iJournalEntry   end    deallocate HeaderCursor   select @tHeaderCursorRemoved = @TRUE   end    if @tHeaderCursorRemoved = @FALSE  begin  deallocate HeaderCursor   select @tHeaderCursorRemoved = @TRUE  end   if @tCursorExists = @TRUE     deallocate BatchCursor   if @I_tPrinting = @TRUE  begin  exec @iStatus = glpGetAccountInfo  @I_cOrigIntercompanyID,  @I_tICRegistered,  @I_sCompanyID,  @I_cUserID,  @iRelationID,  @sUserLevel,  @iAccessAllAccounts,  @tALSRegistered,  @O_iErrorState output    select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if @iStatus <> 0 or @O_iErrorState <> 0   continue  end    if @iErrorState > 0  select @O_iErrorState = @iErrorState  end   set deadlock_priority normal set arithabort on set nocount off  return (@iStatus)    
GO
GRANT EXECUTE ON  [dbo].[glpPostBatch] TO [DYNGRP]
GO
