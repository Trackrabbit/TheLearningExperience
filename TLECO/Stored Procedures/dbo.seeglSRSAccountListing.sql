SET QUOTED_IDENTIFIER OFF
GO
SET ANSI_NULLS ON
GO
 create procedure [dbo].[seeglSRSAccountListing]  @type int,  @actsegmnt char(2) as  declare  @segdivider varchar(1),  @segnumber int,  @segid int,  @segname char(30),  @seglength int,  @begaccountstring varchar(120),  @endaccountstring varchar(120),  @seglisting varchar(66),  @segmentcount int,  @segcounter int,  @string char(2000),  @acclengthcounter int  create table #accountsegment (SegmentID int, SegmentListing char(66), begaccstr char(66), endaccstr char(66)) if @type = 2 begin  select @string = 'insert #accountsegment select ' + @actsegmnt + ' as SegmentID, rtrim(ACTNUMBR_' + @actsegmnt + ') as SegmentListing, null, null from GL00105 group by rtrim(ACTNUMBR_' + @actsegmnt + ') order by rtrim(ACTNUMBR_' + @actsegmnt + ')' end else begin select @string = 'insert #accountsegment select ' + @actsegmnt + ' as SegmentID, rtrim(ACTNUMST) as SegmentListing , rtrim(ACTNUMST) as begaccstr, rtrim(ACTNUMST) as endaccstr from GL00105 group by rtrim(ACTNUMST) order by rtrim(ACTNUMST)' end  exec(@string)  if @type = 2 begin   select @segdivider = ACSEGSEP from DYNAMICS..SY01500 where INTERID = db_name()  select @segmentcount = count(*) from SY00300  select @segcounter = 1   declare account_cursor cursor   for  select SegmentID, SegmentListing from #accountsegment order by SegmentListing  open account_cursor  fetch next from account_cursor into @segid, @seglisting  while @@FETCH_STATUS = 0  begin  select @begaccountstring = ''  select @endaccountstring = ''   declare segment_cursor cursor   for  select SGMTNUMB, SGMTNAME, LOFSGMNT from SY00300 order by SGMTNUMB  open segment_cursor  fetch next from segment_cursor into @segnumber, @segname, @seglength  while @@FETCH_STATUS = 0  begin   print 'Begining Segment Build for: ' + @seglisting  print str(@segid)  print str(@segnumber)  if @segid = @segnumber  begin  print 'setting segment'  select @begaccountstring = @begaccountstring + rtrim(@seglisting)  select @endaccountstring = @endaccountstring + rtrim(@seglisting)  end  else  Begin    select @acclengthcounter = 1  while @acclengthcounter <= @seglength  begin  print 'setting blank for place: ' + rtrim(str(@acclengthcounter))  select @begaccountstring = @begaccountstring + ' '  select @endaccountstring = @endaccountstring + 'Ã¿'  select @acclengthcounter = @acclengthcounter + 1  end  End  print 'adding divider'  if @segnumber <> @segmentcount   begin  select @begaccountstring = @begaccountstring + @segdivider   select @endaccountstring = @endaccountstring + @segdivider  end    select @segcounter = @segcounter + 1  print 'Beginging: ' + @begaccountstring   fetch next from segment_cursor into @segnumber, @segname, @seglength  end  close segment_cursor  deallocate segment_cursor   update #accountsegment  set begaccstr = @begaccountstring, endaccstr = @endaccountstring  where SegmentListing = @seglisting and SegmentID = @segid   fetch next from account_cursor into @segid, @seglisting  end  close account_cursor  deallocate account_cursor end  select * from #accountsegment   
GO
GRANT EXECUTE ON  [dbo].[seeglSRSAccountListing] TO [DYNGRP]
GO
GRANT EXECUTE ON  [dbo].[seeglSRSAccountListing] TO [rpt_accounting manager]
GO
GRANT EXECUTE ON  [dbo].[seeglSRSAccountListing] TO [rpt_bookkeeper]
GO
GRANT EXECUTE ON  [dbo].[seeglSRSAccountListing] TO [rpt_certified accountant]
GO
GRANT EXECUTE ON  [dbo].[seeglSRSAccountListing] TO [rpt_executive]
GO
