SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
 CREATE       procedure [dbo].[aagMLStep3]  @iStoredProcIdx  smallint = 0,   @iExpColTable varchar(64) = '',  @iDebug   tinyint  = 0,  @iBBFTable varchar(64) = '',  @iBBFFromTable varchar(64) = '',   @oSQLQueryTable1 char(255) = '' out,  @oSQLQueryTable2 char(255) = '' out,  @oNmbrOfRows  smallint = 0 out,  @oNmbrOfDsplLvls smallint = 0 out,  @oQueryTableCmd char(255) = '' out,  @oStatus   smallint  = 0  out  as  set nocount on set dateformat ymd if @iDebug = 1   begin  print ''  print '************************'  print '** aagMLStep3 started **'  print '************************'  print ''  end  declare @retCode int, @execCmd  nvarchar(4000), @execCmd1 varchar(8000), @execCmd2 varchar(8000), @execCmd3 varchar(8000), @paramDef nvarchar(512), @codesCmd nvarchar(2000), @treeCodesCmd nvarchar(2000), @cmd varchar(1000), @columnStr nvarchar(512),  @treeID int, @attachNext tinyint, @per smallint, @toPer smallint, @level smallint, @levelCount smallint, @rowOrder int, @newOrder int, @column smallint, @count smallint, @p char(1), @id int, @idWork int, @nodeID int, @newID int, @rowID int, @node varchar(50), @dsplLvl int, @parentNodeID int, @hasNodes tinyint, @hasCodes tinyint, @cols int, @levels int, @col smallint, @time int, @iBBFFilter varchar(4000)  if (@iExpColTable = '')   begin select @oStatus = -1 return end  if (@iStoredProcIdx = 0) begin select @oStatus = -1 return end  select  @retCode    = 0, @oStatus    = 0, @oSQLQueryTable1 = '', @oSQLQueryTable2 = '', @oNmbrOfRows   = 0, @oNmbrOfDsplLvls = 0, @execCmd    = N'', @paramDef  = N'@dsplLvl int, @nodeID int', @codesCmd  = N'', @treeCodesCmd  = N'', @columnStr  = N'', @treeID   = 0, @attachNext   = 0, @cmd   = '', @per   = 0, @toPer   = 0, @level   = 0, @levelCount  = 0, @rowOrder  = 0, @newOrder  = 0, @column   = 0, @count   = 0, @p   = '''', @id   = 0, @idWork   = 0, @nodeID   = 0, @newID   = 0, @rowID   = 0, @node   = '', @dsplLvl  = 0, @dsplLvl   = 0, @parentNodeID  = 0, @hasNodes  = 0, @hasCodes  = 0, @cols   = 0, @levels   = 0, @col   = 0, @iBBFFilter = ''  if dbo.aagMLCancelled() = 1 goto DONE  if @iDebug = 1 print '** copy into ##ExpCols **' if exists(select name from tempdb..sysobjects where name = '##ExpCols'  and type = 'U') drop table ##ExpCols select @execCmd = N'select * into ##ExpCols from ' + @iExpColTable  if @iDebug = 1 print @execCmd exec @retCode = sp_executesql @execCmd if (@retCode <> 0) return @retCode  if @iDebug = 1 print '** precheck **'  select @cols = count(*) from ##ExpCols if (@cols = 0) begin select @oStatus = -40 return end  select @levels = count(*) from ##Lvl if (@levels = 0) begin select @oStatus = -60 return end  INSERT INTO AAG30002 (aaGLHdrID,aaGLDistID,aaGLAssignID,DEBITAMT,CRDTAMNT,ORDBTAMT,ORCRDAMT,aaAssignedPercent)  SELECT aaGLHdrID,aaGLDistID,nCount + 1 as nCount,(DEBITAMT - aaAssignDbtSum) as DBTAMT, (CRDTAMNT - aaAssignCrdSum) as CRDAMT,(ORDBTAMT - aaAssignOrgDbtSum) AS ORGDBTAMT,(ORCRDAMT - aaAssignOrgCrdSum) AS ORGCRDAMT, (10000 - aaAssignmentSum) AS aaCreatePerc  FROM (  SELECT Assign.aaGLHdrID,Assign.aaGLDistID,dist.DEBITAMT,dist.CRDTAMNT,dist.ORDBTAMT,dist.ORCRDAMT,  Assign.aaAssignDbtSum,Assign.aaAssignCrdSum,Assign.aaAssignOrgDbtSum,Assign.aaAssignOrgCrdSum,Assign.aaAssignmentSum,Assign.nCount  FROM (  SELECT aaGLHdrID,aaGLDistID,SUM(aaAssignedPercent) AS aaAssignmentSum,SUM(DEBITAMT) AS aaAssignDbtSum,SUM(CRDTAMNT) AS aaAssignCrdSum,  SUM(ORDBTAMT) AS aaAssignOrgDbtSum,SUM(ORCRDAMT) AS aaAssignOrgCrdSum, Max(aaGLAssignID) as nCount FROM AAG30002   GROUP BY aaGLHdrID,aaGLDistID   HAVING SUM(aaAssignedPercent)< 10000  ) Assign   INNER JOIN AAG30000 Hdr on Hdr.aaGLHdrID = Assign.aaGLHdrID  INNER JOIN AAG30001 dist on dist.aaGLHdrID = Assign.aaGLHdrID and dist.aaGLDistID = Assign.aaGLDistID   AND LTRIM(RTRIM(dist.SOURCDOC)) = ''   ) PartialData  EXEC @retCode= aagMLStep4 0,0,@iBBFFromTable,@oStatus if ((@retCode <> 0) and (@retCode =-30)) begin select @oStatus = @retCode return end if ((@retCode <> 0) and (@retCode <>-30)) return  @retCode   if exists(select name from tempdb..sysobjects where name = '##PreCalc'    and type = 'U')   begin  set @iBBFFilter = ''  IF EXISTS(SELECT name FROM tempdb..sysobjects WHERE name = '##aaBBFSQLWhere'  AND type = 'U') drop table ##aaBBFSQLWhere    if not exists(select 1 from ##Lvl where aaColumn in(114,115,116,117))  begin  if not exists(select 1 from ##Options where aaCodeSpreadUsed = 1 and aaCodeSpreadCol in(114,115,116,117))  begin  EXEC ('select * into ##aaBBFSQLWhere from ' + @iBBFTable + '')   end  end  IF EXISTS(SELECT name FROM tempdb..sysobjects WHERE name = '##aaBBFSQLWhere'  AND type = 'U') SELECT @iBBFFilter = aaBBFFilter FROM ##aaBBFSQLWhere  EXEC @retCode = aagMLforBBF @iBBFFilter  select @retCode = count(year1) from ##PreCalc  if (@retCode = 0) begin select @oStatus = -50 return end  end exec ('delete from ' + @iBBFTable + '') create table ##Rows(rowOrder bigint not null UNIQUE, lvl smallint not null, dsplLvl smallint, descr varchar(800),  basePeriod smallint not null, attachNext tinyint not null, pageBreak tinyint not null,  totals tinyint not null)   create table #RowOrder(rowOrder bigint not null UNIQUE)  select @levelCount = count(*) from ##Lvl  if dbo.aagMLCancelled() = 1 goto DONE  declare c cursor fast_forward for select aaColumn from ##Lvl order by aaOrder open c fetch next from c into @column while (@@fetch_status <> -1) and (dbo.aagMLCancelled() = 0)  begin  select @level = @level +1   create table #Codes(dsplLvl smallint, descr varchar(800), basePeriod smallint not null,   codeID varchar(50) not null, attachNext tinyint not null, pageBreak tinyint not null,  totals tinyint not null, isNode tinyint, hasNodes tinyint, hasCodes tinyint,   rowID int not null identity)    if (select aaUseTree from ##Col where aaColumn = @column) = 1   begin  if @iDebug = 1 print '** Level ' + convert(varchar(3), @level) + ' uses tree **'   create table #Tree(id bigint, nodeID int, node varchar(50), dsplLvl int, attachNext tinyint, parentNode int,   hasNodes tinyint, hasCodes tinyint, rowID int not null identity)   select @codesCmd = convert(varchar(2000), aaSQLCodeCmd) from ##Col where aaColumn = @column  select @treeCodesCmd = convert(varchar(2000), aaSQLTreeCodeCmd) from ##Col where aaColumn = @column  select @treeID = aaTreeID from ##Col where aaColumn = @column  select @cmd = 'declare t cursor fast_forward for' + SPACE(1) + @codesCmd  if @iDebug = 1 print @cmd  exec (@cmd)  open t   fetch next from t into @nodeID, @node, @dsplLvl, @parentNodeID  while (@@fetch_status <> -1) and (dbo.aagMLCancelled() = 0)  begin   if (select aaTreeLevel from ##Col where aaColumn = @column) <> 0   begin   select @dsplLvl = 1  select @hasNodes = 0  end  else   if exists(select top 1 aaTreeID from AAG00601 where aaTreeID = @treeID and aaParentNodeID = @nodeID) select @hasNodes = 1  else select @hasNodes = 0   if exists(select aaTreeID from AAG00602 where aaTreeID = @treeID and aaNodeID = @nodeID)   begin  select @attachNext = 1  select @hasCodes = 1  end  else  begin  select @attachNext = 0  select @hasCodes = 0  end   if not exists(select nodeID from #Tree where nodeID = @parentNodeID)  begin  select @id = @id + 327  select @idWork = @id  end  else  begin  select @idWork = max(id) +1 from #Tree where parentNode = @parentNodeID  if (@idWork is null) select @idWork = max(id) +1 from #Tree where nodeID = @parentNodeID  end   insert #Tree(id, nodeID, node, dsplLvl, attachNext, parentNode, hasNodes, hasCodes)   select @idWork, @nodeID, @node, @dsplLvl, @attachNext, @parentNodeID, @hasNodes, @hasCodes  if @iDebug = 1 select * from #Tree   select @newID = 0   declare r cursor fast_forward for select rowID from #Tree order by id  open r   fetch next from r into @rowID  while (@@fetch_status <> -1)  begin  select @newID = @newID + 32700  update #Tree set id = @newID where rowID = @rowID    fetch next from r into @rowID  end  close r  deallocate r   fetch next from t into @nodeID, @node, @dsplLvl, @parentNodeID  end  close t  deallocate t  if @iDebug = 1 select * from #Tree order by id   if (select aaUseCodes from ##Col where aaColumn = @column) = 0  begin  insert #Codes(dsplLvl, descr, basePeriod, codeID, attachNext, pageBreak, totals, isNode, hasNodes, hasCodes)  select dsplLvl, node, 0, nodeID, attachNext, 0, 0, 1, hasNodes, hasCodes from #Tree order by id  end  else  begin  select @treeCodesCmd = convert(varchar(2000), aaSQLTreeCodeCmd) from ##Col where aaColumn = @column   select @execCmd = N'insert #Codes(dsplLvl, descr, basePeriod, codeID, attachNext, pageBreak, totals) ' + @treeCodesCmd    if (select aaTreeLevel from ##Col where aaColumn = @column) = 0  begin  if @iDebug = 1 print @execCmd  select @dsplLvl = 0, @nodeID = 1  exec @retCode = sp_executesql @execCmd, @paramDef, @dsplLvl = @dsplLvl, @nodeID = @nodeID  if (@retCode <> 0) begin close c deallocate c return @retCode end  if (dbo.aagMLCancelled() = 1) begin close c deallocate c goto DONE end  end   declare t cursor fast_forward for select dsplLvl, nodeID, node, hasNodes, hasCodes from #Tree order by id  open t  fetch next from t into @dsplLvl, @nodeID, @node, @hasNodes, @hasCodes  while (@@fetch_status <> -1) and (dbo.aagMLCancelled() = 0)  begin   insert #Codes(dsplLvl, descr, basePeriod, codeID, attachNext, pageBreak, totals, isNode, hasNodes, hasCodes)  select @dsplLvl, @node, 0, '0', 0, 0, 0, 1, @hasNodes, @hasCodes   exec @retCode = sp_executesql @execCmd, @paramDef, @dsplLvl = @dsplLvl, @nodeID = @nodeID  if (@retCode <> 0) begin close t deallocate t close c deallocate c return @retCode end  if (dbo.aagMLCancelled() = 1) begin close t deallocate t close c deallocate c goto DONE end   fetch next from t into @dsplLvl, @nodeID, @node, @hasNodes, @hasCodes  end  close t  deallocate t  end    drop table #Tree   end   else  if (@column) = -1   begin  if @iDebug = 1 print '** Level ' + convert(varchar(3), @level) + ' is time level **'   select @per = From_Period, @toPer = To_Period from ##Options  while @per <= @toPer  begin  insert #Codes(dsplLvl, descr, basePeriod, codeID, attachNext, pageBreak, totals)  select 1, rtrim(aaPerStr) + SPACE(1) + convert(varchar(3), @per) + '/' + convert(varchar(4), YEAR1),  convert(varchar(3), @per), '0', 1, 0, 0 from ##Options   select @per = @per +1  end  end    else  begin  if @iDebug = 1 print '** Level ' + convert(varchar(3), @level) + ' uses codes **'   if (select aaInclEmptyCodes from ##Col where aaColumn = @column) = 1   begin  if @iDebug = 1 print '** Add empty code **'   insert #Codes(dsplLvl, descr, basePeriod, codeID, attachNext, pageBreak, totals)   select 1, aaEmptyCodeStr, 0, '0', 1, 0, 0 from ##Options  end   select @codesCmd = convert(nvarchar(2000), aaSQLCodeCmd) from ##Col where aaColumn = @column  select @execCmd = N'insert #Codes(dsplLvl, descr, basePeriod, codeID, attachNext, pageBreak, totals) ' + @codesCmd    if @iDebug = 1 print @execCmd  exec @retCode = sp_executesql @execCmd  if (@retCode <> 0) begin close c deallocate c return @retCode end  if (dbo.aagMLCancelled() = 1) begin close c deallocate c goto DONE end  end   if (select count(*) from #Codes) = 0 begin close c deallocate c select @oStatus = @level return end    update #Codes set pageBreak = 0  where  #Codes.rowID = 1   update #Codes set pageBreak = aaPageBreak from ##Col where aaColumn = @column and #Codes.rowID > 1   if (select aaUseTree from ##Col where aaColumn = @column) = 0   begin   if (@level < @levelCount) update #Codes set totals = aaTotals from ##Col where aaColumn = @column  end  else   begin  if (@level = @levelCount)   begin   if (select aaUseCodes from ##Col where aaColumn = @column) = 1   update #Codes set totals = aaTotals from ##Col where aaColumn = @column and isNode = 1 and (hasCodes = 1 or hasNodes = 1)  else   update #Codes set totals = aaTotals from ##Col where aaColumn = @column and isNode = 1 and hasCodes = 0 and hasNodes = 1  end  else   begin   if (select aaUseCodes from ##Col where aaColumn = @column) = 1  begin  update #Codes set totals = aaTotals from ##Col where aaColumn = @column and isNode = 1 and (hasCodes = 1 or hasNodes = 1)  update #Codes set totals = aaTotals from ##Col where aaColumn = @column and attachNext = 1 and isNode is NULL  end  else   update #Codes set totals = aaTotals from ##Col where aaColumn = @column and isNode = 1 and (hasCodes = 1 or hasNodes = 1)  end  end   if @iDebug = 1 select * from #Codes order by rowID   select @cmd = 'alter table ##Rows ADD ' + 'L' + convert(nvarchar(3), @level) + '_codeID varchar(50) null'  if @iDebug = 1 print @cmd  exec (@cmd)   if @level = 1  begin  select @execCmd =   N'insert ##Rows(rowOrder, lvl, dsplLvl, descr, basePeriod, attachNext, pageBreak, totals, L1_codeID)' +  '  select new.rowID,' + convert(nvarchar(3), @level) + ', new.dsplLvl, new.descr, new.basePeriod, new.attachNext, new.pageBreak, new.totals,new.codeID' +  '  from #Codes new '  if  (select Top 1 aaColumn from ##Lvl order by aaOrder)<> -1  begin  select @execCmd = @execCmd + 'where (new.codeID in (select distinct L1_codeID from ##PreCalc) or new.codeID=''0'') order by new.rowID '   end  else  select @execCmd = @execCmd + 'order by new.rowID '  if @iDebug = 1 print @execCmd   exec @retCode = sp_executesql @execCmd  if (@retCode <> 0) begin close c deallocate c return @retCode end  if (dbo.aagMLCancelled() = 1) begin close c deallocate c goto DONE end  end    else   begin  select * into #Work from ##Rows where lvl = (@level -1) and attachNext = 1 order by rowOrder   select @execCmd = N'insert ##Rows(rowOrder, lvl, dsplLvl, descr, basePeriod, attachNext, pageBreak, totals'   select @count = 1  while @count <= @level  begin  select @execCmd = @execCmd + N', L' + convert(varchar(3), @count) + '_codeID'  select @count = @count +1  end   select @execCmd = @execCmd +  N') select (old.rowOrder + new.rowID),' + convert(nvarchar(3), @level) + ', (old.dsplLvl + new.dsplLvl), new.descr,' +  '     case' +   '       when old.basePeriod <> 0 then old.basePeriod' +  '       when new.basePeriod <> 0 then new.basePeriod' +  '       else 0' +  '     end,' +  '     new.attachNext,' +  '     new.pageBreak,' +  '     new.totals'   select @count = 1  while @count <= (@level -1)  begin  select @execCmd = @execCmd + ', old.L' + convert(nvarchar(3), @count) + '_codeID'  select @count = @count +1  end   select @time=0  if exists(select aaColumn from ##Lvl where aaColumn = -1)  select @time =((select aaOrder from ##Lvl where aaColumn = -1)-(select Min(aaOrder) from ##Lvl)) +1  if @level = @time   select @execCmd = @execCmd + ', new.codeID from #Work old, #Codes new order by old.rowOrder, new.rowID'  else   begin  declare p cursor fast_forward for select aaColumn from ##Lvl order by aaOrder  open p  fetch next from p into @col  begin  select @count = 1  if @col = -1  begin  fetch next from p into @col  select @count = @count +1  end  if @@fetch_status <> 0  select @execCmd = @execCmd + ', new.codeID from #Work old, #Codes new '  else   if (@level = 2 )and ((select Top 1 aaColumn from ##Lvl order by aaOrder) = -1 )  select @execCmd = @execCmd +' , new.codeID from #Work old, #Codes new where new.codeID in (select distinct L' + convert(nvarchar(3), @level ) + '_codeID from ##PreCalc ) or new.codeID=''0'' '  else  select @execCmd = @execCmd +' , new.codeID from #Work old, #Codes new where new.codeID in (select distinct L' + convert(nvarchar(3), @level ) + '_codeID from ##PreCalc where '    if not ((@level = 2 )and ((select Top 1 aaColumn from ##Lvl order by aaOrder) = -1 ))  begin  while (@@fetch_status = 0) and (@count <= (@level -1))  begin   if @col <> -1   begin  if ((select Top 1 aaColumn from ##Lvl order by aaOrder)<> -1 )  begin  if (@count > 1) select @execCmd = @execCmd + ' and '  end   else  begin  if (@count > 2) select @execCmd = @execCmd + ' and '  end  select @execCmd = @execCmd +' L' + convert(nvarchar(3), @count) + '_codeID = old.L' + convert(nvarchar(3), @count ) + '_codeID '   end  select @count = @count +1  fetch next from p into @col  if (@@fetch_status = -1 or @count = @level)   select @execCmd = @execCmd + ' ) or new.codeID=''0'' '   end  end  select @execCmd = @execCmd + ' order by old.rowOrder, new.rowID'  end  close p  deallocate p  end   if @iDebug = 1 print @execCmd   exec @retCode = sp_executesql @execCmd  if (@retCode <> 0) begin close c deallocate c return @retCode end  if (dbo.aagMLCancelled() = 1) begin close c deallocate c goto DONE end   drop table #Work  end  drop table #Codes  if ((select count(*) from ##Rows) >65536 ) begin select @oStatus = -70 return end  if (((select Max(dsplLvl) from ##Rows) + @cols)>256) begin select @oStatus = -80 return end   if @iDebug = 1 print '** Renumber level ' + convert(varchar(3), @level) + ' **'  delete from #RowOrder   insert #RowOrder(rowOrder) select rowOrder from ##Rows a order by a.rowOrder   if @level = @levelCount select @newOrder = 0  declare r cursor fast_forward for select rowOrder from #RowOrder order by rowOrder  open r  fetch next from r into @rowOrder  while (@@fetch_status <> -1) and (dbo.aagMLCancelled() = 0)  begin  if @level = @levelCount select @newOrder = @newOrder +1  else select @newOrder = @newOrder + 65600  update ##Rows set rowOrder = @newOrder where rowOrder = @rowOrder   fetch next from r into @rowOrder  end  close r  deallocate r   select @newOrder = @newOrder + 327   fetch next from c into @column  end close c deallocate c  if dbo.aagMLCancelled() = 1 goto DONE  if @iDebug = 1 print '** Prepare table ##RowImport **'  if exists(select 1 from tempdb..sysobjects where name = '##TestRows' and xtype = 'U')  begin  select @oNmbrOfDsplLvls = max(dsplLvl) from ##Rows   if (@oNmbrOfDsplLvls = 0) begin select @oStatus = -50 return end  end  else  begin  select @oNmbrOfDsplLvls = count(distinct(dsplLvl)) from ##Rows   if (@oNmbrOfDsplLvls = 0) begin select @oStatus = -10 return end  end  select @execCmd =  N'create table ##RowImport(rowOrder int not null, lvl int not null, dsplLvl int not null,' + '     pageBreak tinyint not null, totals tinyint not null'  select @count = 1 while @count <= @oNmbrOfDsplLvls  begin  select @execCmd = @execCmd + ', L' + convert(varchar(3), @count) + 'd varchar(800) null'  select @columnStr = @columnStr + ', L' + convert(varchar(3), @count) + 'd'   select @count = @count +1  end select @execCmd = @execCmd + ')'  exec @retCode = sp_executesql @execCmd if (@retCode <> 0) return @retCode  if dbo.aagMLCancelled() = 1 goto DONE  if @iDebug = 1 print @execCmd  select @execCmd = N'CREATE CLUSTERED INDEX  rowOrder_tRowImport' select @execCmd =  @execCmd + ' ON ##RowImport(rowOrder)' if @iDebug = 1 print @execCmd if dbo.aagMLCancelled() = 1 goto DONE exec @retCode = sp_executesql @execCmd if (@retCode <> 0) return @retCode  select @execCmd =  N'insert ##RowImport(rowOrder, lvl, dsplLvl, pageBreak, totals' + @columnStr + ')' + ' select rowOrder, lvl, dsplLvl, pageBreak, totals'  select @count = 1 while @count <= @oNmbrOfDsplLvls  begin  select @execCmd = @execCmd +   ', case when dsplLvl = ' + convert(nvarchar(3), @count) + ' then descr else null end'   select @count = @count +1  end select @execCmd = @execCmd + ' from ##Rows order by rowOrder'  if @iDebug = 1 print @execCmd exec @retCode = sp_executesql @execCmd if (@retCode <> 0) return @retCode  if dbo.aagMLCancelled() = 1 goto DONE  if @iDebug = 1 print '** Build QueryTable statements **'  select @cmd = 'select rowOrder'   select @count = 1 while @count <= @oNmbrOfDsplLvls  begin  select @cmd = @cmd + ',L' + ltrim(str(@count)) + 'd'   select @count = @count +1  end select @cmd = @cmd + ' from ##RowImport order by rowOrder'  if (len(@cmd) > 255) begin select @oStatus = -20 return end  if exists(select * from tempdb..sysobjects where name = '##testRowImport'    and type = 'U') drop table ##testRowImport select * into ##testRowImport from ##RowImport   EXEC @retCode= aagMLStep5 0,@iExpColTable,0,@oQueryTableCmd,@oStatus,@iBBFFilter if ((@retCode <> 0) and (@retCode =-50))  begin select @oStatus = @retCode return end if ((@retCode <> 0) and (@retCode <>-50)) return  @retCode  IF EXISTS(SELECT name FROM tempdb..sysobjects WHERE name = '##aaBBFSQLWhere'  AND type = 'U') DROP TABLE ##aaBBFSQLWhere  select @execCmd2 = '' select @execCmd1 =  N'Delete ##RowImport where rowOrder in (select c.rowOrder from ##CellImport c,##RowImport r where ' select @cols = count(*) from ##ExpCols select @count = 1 while @count <= @cols  begin  if @count <= 135  begin  if @count=1  select @execCmd1 = @execCmd1 + ' (cell' + ltrim(str(@count)) + ' =0 or cell' + ltrim(str(@count)) + ' is null)'  select @execCmd1 = @execCmd1 + ' and (cell' + ltrim(str(@count)) + ' =0 or cell' + ltrim(str(@count))+ ' is null)'  end   else   select @execCmd2 = @execCmd2 + ' and (cell' + ltrim(str(@count)) + ' =0 or cell' + ltrim(str(@count))+ ' is null)'   select @count = @count +1  end  select @execCmd2 = @execCmd2+' and (r.rowOrder=c.rowOrder) and (r.totals = 0 and r.dsplLvl=(select Max(dsplLvl) from ##Rows))) '   if LEN(@execCmd1) = 8000   begin   select @oStatus = -30   return @oStatus   end  if LEN(@execCmd2) = 8000   begin   select @oStatus = -30   return @oStatus   end  exec (@execCmd1+@execCmd2)  select @execCmd2 = '' select @execCmd1 =  N'Delete ##RowImport where rowOrder in (select c.rowOrder from ##CellImport c,##RowImport r where ' select @cols = count(*) from ##ExpCols select @count = 1 while @count <= @cols  begin  if @count <= 135  begin  if @count=1  select @execCmd1 = @execCmd1 + ' (cell' + ltrim(str(@count)) + ' =0 or cell' + ltrim(str(@count)) + ' is null)'  select @execCmd1 = @execCmd1 + ' and (cell' + ltrim(str(@count)) + ' =0 or cell' + ltrim(str(@count))+ ' is null)'  end   else   select @execCmd2 = @execCmd2 + ' and (cell' + ltrim(str(@count)) + ' =0 or cell' + ltrim(str(@count))+ ' is null)'   select @count = @count +1  end  select @execCmd2 = @execCmd2+' and (r.rowOrder=c.rowOrder) '   select @execCmd3 = ' and (select count(1) from ##RowImport r1 where r1.rowOrder BETWEEN (r.rowOrder  ) AND (select  case  when (select TOP 1 1 from ##RowImport where dsplLvl=r.dsplLvl and rowOrder>r.rowOrder)=1 then (select Top 1 rowOrder from ##RowImport where dsplLvl=r.dsplLvl and rowOrder>r.rowOrder)  else (select Max(rowOrder) from ##RowImport ) end as rowOrder  from ##RowImport where ##RowImport.rowOrder=r.rowOrder) and r1.dsplLvl=(select Max(dsplLvl) from ##Rows))=0) '  if LEN(@execCmd1) = 8000   begin   select @oStatus = -30   return @oStatus   end  if LEN(@execCmd2) = 8000   begin   select @oStatus = -30   return @oStatus   end  if LEN(@execCmd3) = 8000   begin   select @oStatus = -30   return @oStatus   end   exec (@execCmd1 + @execCmd2 + @execCmd3)  select @execCmd =  N'Delete ##CellImport where (rowOrder not in (select rowOrder from ##RowImport)) and (rowOrder <> (select Max(rowOrder) from ##CellImport))' exec @retCode = sp_executesql @execCmd if (@retCode <> 0) return @retCode  select @retCode = count(rowOrder) from ##CellImport if (@retCode = 1)   begin   Delete ##CellImport   select @oStatus=-50  return  end  select  @oSQLQueryTable1 = @cmd, @oSQLQueryTable2 = 'select rowOrder, lvl, dsplLvl, pageBreak, totals from ##RowImport order by rowOrder', @oNmbrOfRows = count(*) from ##RowImport  if @iDebug = 1 select rowOrder, lvl, dsplLvl, pageBreak, totals from ##RowImport  drop table #RowOrder  DONE: if @iDebug = 1   begin  print ''  print '*************************'  print '** aagMLStep3 finished **'  print '*************************'  print ''  end  set nocount off return 0    
GO
GRANT EXECUTE ON  [dbo].[aagMLStep3] TO [DYNGRP]
GO
