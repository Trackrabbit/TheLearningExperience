SET QUOTED_IDENTIFIER OFF
GO
SET ANSI_NULLS ON
GO
 create procedure [dbo].[rmPaidTransactionRemoval] @I_vPaidTrxTableName varchar(40) = NULL, @I_vBalanceForTableName varchar(40) = NULL, @I_tBalanceForward tinyint  = NULL, @I_tNSF tinyint  = NULL, @I_tVoid tinyint  = NULL, @I_tWaived tinyint  = NULL, @I_tPaidTransactions tinyint  = NULL, @I_tChecks tinyint  = NULL, @I_tRestrictCustomers tinyint  = NULL, @I_sCustomerRestrictBy smallint = NULL, @I_dTransactionCutoffDate datetime = NULL, @I_dCheckCutoffDate datetime = NULL, @I_tPrintReport tinyint  = NULL, @I_cStartCustomerRange varchar(65) = NULL, @I_cEndCustomerRange varchar(65)     = NULL, @I_cStartCustomerClass char(15) = NULL, @I_cEndCustomerClass char(15) = NULL, @I_tHATB tinyint  = NULL, @I_dUserDate datetime = NULL, @I_tMCRegistered tinyint  = NULL, @I_cFunctionalCurrency char(15) = NULL, @O_iErrorState                  int             = NULL output as  declare  @TRUE tinyint,  @FALSE tinyint,  @tHATB tinyint,  @tLoopControl           tinyint,  @tTransaction tinyint,  @cCustomerNumber char(15),  @cCustomerName char(65),  @cUserDefined char(21),  @sBalanceType smallint,  @tKeepTrxHistory tinyint,  @tKeepDistHistory tinyint,  @cExecCustomerNumber varchar(32),  @cExecCustomerName varchar(132),  @cExecUserDefined varchar(44),  @vChooseType varchar(255),  @vRestrictVoid varchar(255),  @vCashReceipts varchar(255),  @vSalesTrx varchar(255),  @cTransactionCutoffDate char(12),  @cCheckCutoffDate char(12),  @cKeepTrxHistory char(1),  @cKeepDistHistory char(1),  @cCustomerRestrictBy char(1),  @cMCRegistered char(1),  @vCustomerNumber varchar(15),  @cBalanceForwardNumber char(21),  @iStatus                int,  @iError                 int,  @tRecordsExist tinyint,  @min_date   datetime,  @cmin_date char(12)  select  @TRUE  = 1,  @FALSE = 0  select  @iStatus = 0,  @O_iErrorState = 0,  @vCustomerNumber = '',  @cBalanceForwardNumber = ''  select  @min_date = GETDATE() select  @min_date = DATEADD(mm,-(DATEPART(mm,@min_date))+1,@min_date) select  @min_date = DATEADD(dd,-(DATEPART(dd,@min_date))+1,@min_date) select  @min_date = DATEADD(yy,-(DATEPART(yy,@min_date))+1900,@min_date) select  @cmin_date = convert(char,@min_date)  while @tLoopControl is NULL begin  select @tLoopControl = 1   if      @I_vPaidTrxTableName is NULL or  @I_vBalanceForTableName is NULL or  @I_tBalanceForward is NULL or  @I_tNSF is NULL or  @I_tVoid is NULL or  @I_tWaived is NULL or  @I_tPaidTransactions is NULL or  @I_tChecks is NULL or  @I_tRestrictCustomers is NULL or  @I_sCustomerRestrictBy is NULL or  @I_dTransactionCutoffDate is NULL or  @I_dCheckCutoffDate          is NULL or  @I_tPrintReport is NULL or  @I_cStartCustomerRange is NULL or  @I_cEndCustomerRange is NULL or  @I_cStartCustomerClass is NULL or  @I_cEndCustomerClass is NULL or  @I_tHATB is NULL or  @I_dUserDate is NULL or  @I_tMCRegistered is NULL or  @I_cFunctionalCurrency is NULL  begin  select @O_iErrorState = 20853  break  end    if @I_tRestrictCustomers = @FALSE or  @I_sCustomerRestrictBy = 1   declare  CustomerCursor INSENSITIVE  cursor for select  CUSTNMBR,  CUSTNAME,  USERDEF1,  BALNCTYP,  KPTRXHST,  KPDSTHST  from   RM00101  where  CUSTNMBR between @I_cStartCustomerRange and @I_cEndCustomerRange  and CUSTCLAS between @I_cStartCustomerClass and @I_cEndCustomerClass  and ((BALNCTYP > 0) or  (BALNCTYP = 0 and   exists (select 1 from RM20101 where RM20101.CUSTNMBR = RM00101.CUSTNMBR)))   if @I_tRestrictCustomers = @TRUE and  @I_sCustomerRestrictBy = 2   declare  CustomerCursor INSENSITIVE  cursor for select  CUSTNMBR,  CUSTNAME,  USERDEF1,  BALNCTYP,  KPTRXHST,  KPDSTHST  from   RM00101  where  CUSTNAME between @I_cStartCustomerRange and @I_cEndCustomerRange  and CUSTCLAS between @I_cStartCustomerClass and @I_cEndCustomerClass  and ((BALNCTYP > 0) or  (BALNCTYP = 0 and   exists (select 1 from RM20101 where RM20101.CUSTNMBR = RM00101.CUSTNMBR)))   if @I_tRestrictCustomers = @TRUE and  @I_sCustomerRestrictBy = 3   declare  CustomerCursor INSENSITIVE  cursor for select  CUSTNMBR,  CUSTNAME,  USERDEF1,  BALNCTYP,  KPTRXHST,  KPDSTHST  from   RM00101  where  USERDEF1 between @I_cStartCustomerRange and @I_cEndCustomerRange  and CUSTCLAS between @I_cStartCustomerClass and @I_cEndCustomerClass  and ((BALNCTYP > 0) or  (BALNCTYP = 0 and   exists (select 1 from RM20101 where RM20101.CUSTNMBR = RM00101.CUSTNMBR)))   open CustomerCursor   insert into  RM30502(  TRXSORCE )  select  TRXSORCE  from  RM20101  where  RM20101.TRXSORCE > ''  and  NOT EXISTS(  select  1  from  RM30502  where  RM20101.TRXSORCE = RM30502.TRXSORCE )  GROUP BY  RM20101.TRXSORCE   fetch next from  CustomerCursor  into  @cCustomerNumber,  @cCustomerName,  @cUserDefined,  @sBalanceType,  @tKeepTrxHistory,  @tKeepDistHistory   create table #Documents(  CUSTNMBR char(15) not NULL,   CUSTNAME char(65) not NULL,  USERDEF1 char(21) not NULL,  RMDTYPAL smallint not NULL,   DOCNUMBR char(21) not NULL,   DOCDATE datetime not NULL,   DUEDATE datetime not NULL,   CURTRXAM numeric(19,5) not NULL,   ORTRXAMT numeric(19,5) not NULL,   SLSAMNT numeric(19,5) not NULL,   TRANSAMT numeric(19,5) not NULL,   CURNCYID char(15) not NULL,  TRANHIST smallint not NULL,   DISTHIST smallint not NULL,   TYPE smallint not NULL)    while (@@fetch_status <> -1)  begin  select @cBalanceForwardNumber = ''  select @tKeepTrxHistory = @tKeepTrxHistory + @I_tHATB  select @cKeepTrxHistory = convert(char(1),@tKeepTrxHistory)  select @cKeepDistHistory = convert(char(1),@tKeepDistHistory)  select @cCustomerRestrictBy = convert(char(1),@I_sCustomerRestrictBy)  select @cMCRegistered = convert(char(1),@I_tMCRegistered)  select @cTransactionCutoffDate = '''' + convert(char(10),@I_dTransactionCutoffDate,102) + ''''  select @cCheckCutoffDate = '''' + convert(char(10),@I_dCheckCutoffDate,102) + ''''   Exec @iStatus = smFormatStringsForExecs  @cCustomerNumber,  @cExecCustomerNumber output,  @O_iErrorState output   select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError   if (@iStatus <> 0) or (@O_iErrorState <> 0)  break   Exec @iStatus = smFormatStringsForExecs  @cCustomerName,  @cExecCustomerName output,  @O_iErrorState output   select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError   if (@iStatus <> 0) or (@O_iErrorState <> 0)  break   Exec @iStatus = smFormatStringsForExecs  @cUserDefined,  @cExecUserDefined output,  @O_iErrorState output   select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError   if (@iStatus <> 0) or (@O_iErrorState <> 0)  break   if @sBalanceType = 0   begin  select @vChooseType = ' CASE '  select @vRestrictVoid = ' and ('  if @I_tVoid = @TRUE  select @vChooseType = @vChooseType + 'WHEN VOIDSTTS = 1 THEN 1 ',  @vRestrictVoid = @vRestrictVoid + 'VOIDSTTS = 1 or '  if @I_tWaived = @TRUE  select @vChooseType = @vChooseType + 'WHEN (VOIDSTTS = 3 and DOC.RMDTYPAL = 4) THEN 2 ',  @vRestrictVoid = @vRestrictVoid + 'VOIDSTTS = 3 or '  if @I_tNSF = @TRUE  select @vChooseType = @vChooseType + 'WHEN (DOC.RMDTYPAL = 9 and VOIDSTTS = 2) THEN 3 ',  @vRestrictVoid = @vRestrictVoid + 'VOIDSTTS = 2 or '   select @vRestrictVoid = substring(@vRestrictVoid,1,(len(@vRestrictVoid)-3))   select @vChooseType = @vChooseType + 'ELSE 0 END ',  @vRestrictVoid = @vRestrictVoid + ')'   if (@I_tPaidTransactions = @TRUE) and (@I_tChecks = @FALSE)  begin  select @vSalesTrx = ' and DOC.RMDTYPAL < 9 and DOC.DOCDATE <= ' + @cTransactionCutoffDate +  ' and NOT EXISTS(select 1 from RM20201 APPLY where APTODCTY = DOC.RMDTYPAL and        APTODCNM = DOC.DOCNUMBR and POSTED = 0)'  select @vCashReceipts = ''  end  else if (@I_tPaidTransactions = @TRUE) and (@I_tChecks = @TRUE)  begin  select @vCashReceipts = ' and ((DOC.RMDTYPAL = 9 and DOC.DOCDATE <= ' + @cCheckCutoffDate +        ')'  select @vSalesTrx = ' or (DOC.RMDTYPAL < 9 and DOC.DOCDATE <= ' + @cTransactionCutoffDate +   ' and NOT EXISTS(select 1 from RM20201 APPLY where APTODCTY = DOC.RMDTYPAL and        APTODCNM = DOC.DOCNUMBR and POSTED = 0)))'  end  else if (@I_tPaidTransactions = @FALSE) and (@I_tChecks = @TRUE)  begin  select @vSalesTrx = ''  select @vCashReceipts = ' and (DOC.RMDTYPAL = 9 and DOC.DOCDATE <= ' + @cCheckCutoffDate +        ')'  end   if (@I_tVoid = @TRUE) or (@I_tWaived = @TRUE) or (@I_tNSF = @TRUE)  exec('insert into #Documents  select '  + @cExecCustomerNumber + ','  + @cExecCustomerName + ','  + @cExecUserDefined + ',  DOC.RMDTYPAL,  DOC.DOCNUMBR,  DOC.DOCDATE,  DOC.DUEDATE,  DOC.CURTRXAM,  DOC.ORTRXAMT,  DOC.SLSAMNT,  0.00,    DOC.CURNCYID,  ' + @cKeepTrxHistory + ' + REPRINT.REPRNTNT,  ' + @cKeepDistHistory + ' + REPRINT.REPRNTNT,  ' + @vChooseType + '  from  RM20101 DOC JOIN RM30502 REPRINT ON (DOC.TRXSORCE = REPRINT.TRXSORCE)  where  DOC.CUSTNMBR = ' + @cExecCustomerNumber + '  and DOC.RMDTYPAL <> 6   and DOC.DOCDATE <= ' + @cTransactionCutoffDate  + @vRestrictVoid )   if (@I_tPaidTransactions = @TRUE) or (@I_tChecks = @TRUE)  exec('insert into #Documents  select '  + @cExecCustomerNumber + ','  + @cExecCustomerName + ','  + @cExecUserDefined + ',  DOC.RMDTYPAL,  DOC.DOCNUMBR,  DOC.DOCDATE,  DOC.DUEDATE,  DOC.CURTRXAM,  DOC.ORTRXAMT,  DOC.SLSAMNT,  0.00,    DOC.CURNCYID,  ' + @cKeepTrxHistory + ' + REPRINT.REPRNTNT,  ' + @cKeepDistHistory + ' + REPRINT.REPRNTNT,  CASE  WHEN DOC.RMDTYPAL < 9 THEN  4  WHEN DOC.RMDTYPAL = 9 THEN   5  ELSE  0  END  from  RM20101 DOC JOIN RM30502 REPRINT ON (DOC.TRXSORCE = REPRINT.TRXSORCE)  LEFT OUTER JOIN MC020102 MCTRX ON (MCTRX.RMDTYPAL = DOC.RMDTYPAL and   MCTRX.DOCNUMBR = DOC.DOCNUMBR)  where  DOC.CUSTNMBR = ' + @cExecCustomerNumber + '  and DOC.VOIDSTTS = 0   and  ((DOC.CURTRXAM = 0.00)  or  (' + @cMCRegistered + ' = 1    and (ISNULL(MCTRX.ORCTRXAM,1.00) = 0.00  or   (DOC.RMDTYPAL < 7 and DOC.DINVPDOF <> ''' + @cmin_date + ''')))) '   + @vCashReceipts  + @vSalesTrx  )   end    if (@sBalanceType = 1) and (@I_tBalanceForward = @TRUE)  begin  insert into #Documents  select  @cCustomerNumber,  @cCustomerName,  @cUserDefined,  DOC.RMDTYPAL,  DOC.DOCNUMBR,  DOC.DOCDATE,  DOC.DUEDATE,  DOC.CURTRXAM,  DOC.ORTRXAMT,  DOC.SLSAMNT,  CASE  WHEN (DOC.VOIDSTTS <> 0) or (DOC.RMDTYPAL = 6) THEN  0.00  WHEN DOC.RMDTYPAL BETWEEN 1 and 5 THEN  CURTRXAM  WHEN DOC.RMDTYPAL BETWEEN 7 and 9 THEN  -CURTRXAM  END,  DOC.CURNCYID,  @tKeepTrxHistory + REPRINT.REPRNTNT,  @tKeepDistHistory + REPRINT.REPRNTNT,  6   from  RM20101 DOC JOIN RM30502 REPRINT ON (DOC.TRXSORCE = REPRINT.TRXSORCE)  where  DOC.CUSTNMBR = @cCustomerNumber  and DOC.RMDTYPAL > 0   and DOC.DOCDATE <= @I_dTransactionCutoffDate   end    if exists (select 1 from #Documents)  begin  select @tRecordsExist = @TRUE  end  else  begin  select @tRecordsExist = @FALSE  end   select @tTransaction = 0  if @@trancount = 0  begin  begin transaction  select @tTransaction = 1  end   if (@sBalanceType = 1) and (@I_tBalanceForward = @TRUE)  begin  select @vCustomerNumber = rtrim(@cCustomerNumber)  exec @iStatus = rmBalanceForwardConsolidation  @vCustomerNumber,  @I_dTransactionCutoffDate,  @I_dUserDate,  @I_cFunctionalCurrency,  @cBalanceForwardNumber output,  @O_iErrorState output   select @iError = @@error   if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if @iStatus <> 0 or @O_iErrorState <> 0  break   end    if @tRecordsExist = @TRUE  begin  exec @iStatus = rmPTRCreateHistory  @cBalanceForwardNumber,  @O_iErrorState output   select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if @iStatus <> 0 or @O_iErrorState <> 0  begin  if @tTransaction = 1  rollback transaction  break  end   end    if (@sBalanceType = 1) and (@I_tBalanceForward = @TRUE)  begin   if @tRecordsExist = @TRUE  begin  update  RM00103    set  UPFCHYTD = ISNULL((  select  sum(CURTRXAM)  from  RM20101  where  RMDTYPAL = 4  and CUSTNMBR = @cCustomerNumber), 0.00),  AGPERAMT_1 = AGPERAMT_1 - ISNULL((select sum(TRANSAMT) from #Documents),0.00),  AGPERAMT_2 = AGPERAMT_2 + ISNULL((select sum(TRANSAMT) from #Documents),0.00)  where  CUSTNMBR = @cCustomerNumber   select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError   end    update  RM00103    set  UPFCHYTD = (case when CUSTBLNC > 0.00 then  case when  UPFCHYTD > RM00103.CUSTBLNC then  CUSTBLNC  else  UPFCHYTD  end  else   0.00  end )  where  CUSTNMBR = @cCustomerNumber   select @iError = @@error   if @iStatus = 0 and @iError <> 0  select @iStatus = @iError   end    if @iStatus <> 0 or @O_iErrorState <> 0  begin  if @tTransaction = 1  rollback transaction   break  end  else if @tTransaction = 1  commit transaction   if @tRecordsExist = @TRUE  begin  if (@I_tPrintReport = @TRUE) and (@sBalanceType = 1) and (@I_tBalanceForward = @TRUE)  begin  exec('insert into ' + @I_vBalanceForTableName + '  select  CUSTNMBR,CUSTNAME,DOCNUMBR,DOCDATE,RMDTYPAL,  DUEDATE,CURTRXAM,ORTRXAMT,'''',0,  CASE  WHEN ' + @cCustomerRestrictBy + ' = 1 THEN  CUSTNMBR  WHEN ' + @cCustomerRestrictBy + ' = 2 THEN  CUSTNAME  WHEN ' + @cCustomerRestrictBy + ' = 3 THEN  (USERDEF1 + CUSTNMBR)  END  from  #Documents  where   TYPE = 6')  end    if (@I_tPrintReport = @TRUE) and (@sBalanceType = 0) and  (@I_tNSF = @TRUE or @I_tVoid = @TRUE or @I_tWaived = @TRUE or   @I_tPaidTransactions = @TRUE or @I_tChecks = @TRUE)  begin  exec('insert into ' + @I_vPaidTrxTableName + '  select  RMDTYPAL,DOCNUMBR,0,'''',0,CUSTNMBR,  '''',DOCDATE,ORTRXAMT,SLSAMNT,  CASE  WHEN ' + @cCustomerRestrictBy + ' = 1 THEN  CUSTNMBR  WHEN ' + @cCustomerRestrictBy + ' = 2 THEN  CUSTNAME  WHEN ' + @cCustomerRestrictBy + ' = 3 THEN  (USERDEF1 + CUSTNMBR)  END  from  #Documents  where   TYPE < 6')   end    end    truncate table #Documents   fetch next from  CustomerCursor  into  @cCustomerNumber,  @cCustomerName,  @cUserDefined,  @sBalanceType,  @tKeepTrxHistory,  @tKeepDistHistory   end    deallocate CustomerCursor   drop table #Documents  end   return(@iStatus)   
GO
GRANT EXECUTE ON  [dbo].[rmPaidTransactionRemoval] TO [DYNGRP]
GO
