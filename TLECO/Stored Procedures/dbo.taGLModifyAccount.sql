SET QUOTED_IDENTIFIER OFF
GO
SET ANSI_NULLS ON
GO
create procedure [dbo].[taGLModifyAccount] @O_iErrorState int = NULL output with encryption as set transaction isolation level read uncommitted set nocount on declare  @cTAFROMINDX 	int, @cTATOINDX 	int,  @cTAFROMINDXv 	char(15), @cTATOINDXv 	char(15),  @iCursorError 	int, @cStatement 	varchar(255), @iStatus 	int, @iError 	int,  @tTransaction	tinyint, @tLoop		tinyint select @O_iErrorState 	 = 0 if @@trancount = 0    begin select @tTransaction = 1 begin transaction end while ( @tLoop is NULL ) begin select @tLoop = 1 declare taAccount INSENSITIVE cursor for select TAFROMINDX,  TATOINDX, str(TAFROMINDX),  str(TATOINDX)  from TACHANGE where TATYPE = 0 and PSTNGTYP = TA_Posting_Type  open taAccount select @iCursorError = @@cursor_rows if (@iCursorError > 0) begin fetch next from taAccount into @cTAFROMINDX, @cTATOINDX,  @cTAFROMINDXv, @cTATOINDXv while (@@fetch_status <> -1) begin if (@@fetch_status = -2) begin select @O_iErrorState = 2	 break end 			 exec @iStatus = smChangeAccountIndex @cTAFROMINDX, @cTATOINDX,  @cTAFROMINDXv, @cTATOINDXv, @O_iErrorState output select @iError = @@error if @iStatus = 0 and @iError <> 0 select @iStatus = @iError if (@iStatus <> 0) or (@O_iErrorState <> 0) begin select @O_iErrorState = 2	 deallocate taAccount break end exec @iStatus = smChangeAccountIndexMfg @cTAFROMINDX, @cTATOINDX,  @cTAFROMINDXv, @cTATOINDXv, @O_iErrorState output select @iError = @@error if @iStatus = 0 and @iError <> 0 select @iStatus = @iError if (@iStatus <> 0) or (@O_iErrorState <> 0) begin select @O_iErrorState = 2	 deallocate taAccount break end fetch next from taAccount into @cTAFROMINDX, @cTATOINDX,  @cTAFROMINDXv, @cTATOINDXv end end  deallocate taAccount end  if @O_iErrorState <> 0 begin if @tTransaction = 1 rollback transaction end else if @tTransaction = 1 begin commit transaction end return  
GO
GRANT EXECUTE ON  [dbo].[taGLModifyAccount] TO [DYNGRP]
GO
