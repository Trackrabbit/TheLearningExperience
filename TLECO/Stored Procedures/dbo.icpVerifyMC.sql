SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
 create procedure [dbo].[icpVerifyMC]   @I_cOrigICID char(5)  = NULL,  @I_cOrigCurrency char(15) = NULL,  @I_dTransactionDate   datetime = NULL,  @I_tPosting tinyint  = NULL,  @O_LineMessages2 binary(4)       = NULL  output,  @O_iErrorState      int             = NULL  output as  declare  @MS_Convert int,  @MS_Item24 int,  @tTransaction          int,  @tLoop          tinyint,  @cICID char(5),  @sCompanyID smallint,  @dExchangeDate datetime,  @mExchangeRate numeric(15,7),  @cExchangeTableID char(15),  @dExchangeTime datetime,   @cRateTypeID char(15),  @dTransactionDate datetime,  @iStatus integer,  @Execstring char(30),  @FALSE tinyint,  @TRUE tinyint,  @sOrigCurrencyIndex smallint,  @sDecimalPlaces smallint,  @bMessages binary(4),  @iError     int,   @cDBName char(10),  @cCurrency char(15),  @sMCTrxState smallint   select  @O_LineMessages2 = 0x00000000,   @bMessages  = 0x00000000,   @O_iErrorState   = 0,  @iError   = 0,  @iStatus  = 0   if @@trancount = 0 begin  select @tTransaction = 1  begin transaction  end   while (@tLoop is NULL) begin    select @tLoop = 1   if      @I_cOrigICID   is NULL or  @I_cOrigCurrency is NULL or  @I_dTransactionDate is NULL or   @I_tPosting   is NULL  begin  select @O_iErrorState = 20902   break  end    select  @MS_Convert  = power(2, 16),  @MS_Item24 = power(2,15),  @FALSE  = 0,   @TRUE   = 1   declare   Companycursor INSENSITIVE  cursor for select distinct  li.IntercompanyID,  li.FunctionalCurrency,  li.CompanyID,  li.ExchangeDate,  li.ExchangeRate,   li.ExchangeTableID,  li.ExchangeTime,   li.RateTypeID,   li.DatabaseName,  li.MCTrxState  from   #LineItems li,  #Company co  where  li.IntercompanyID  <> @I_cOrigICID  and  li.FunctionalCurrency  <> @I_cOrigCurrency  and  co.IntercompanyID  = li.IntercompanyID  and co.UserAccess  = 1    open Companycursor   if @@cursor_rows <>  0  begin   fetch next from  Companycursor  into  @cICID,  @cCurrency,   @sCompanyID,  @dExchangeDate,  @mExchangeRate,  @cExchangeTableID,  @dExchangeTime,  @cRateTypeID,  @cDBName,  @sMCTrxState   while (@@fetch_status <> -1)  begin  select @bMessages = 0x00000000   select @Execstring = rtrim(@cDBName) + '..glpmcVerifyCurrency'  exec @iStatus = @Execstring   @sCompanyID,  @I_cOrigCurrency,  @dExchangeDate,   @mExchangeRate,  @cExchangeTableID,  @dExchangeTime,   @FALSE,        @FALSE,     @I_tPosting,   @FALSE,         @cRateTypeID,  @I_dTransactionDate,  @sMCTrxState,  @bMessages output,  @sOrigCurrencyIndex output,  @sDecimalPlaces   output,  @O_iErrorState output    select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError   if (@bMessages <> 0x00000000)   begin   if (convert(int,@bMessages) < 0)   begin      update  #LineItems  set   LineMessages2 = (LineMessages2 | @MS_Item24)   where   IntercompanyID = @cICID    select @bMessages = (@bMessages ^ convert(int, 0x80000000))   end   update  #LineItems   set   LineMessages2 = (LineMessages2 | (@bMessages / @MS_Convert))   where   IntercompanyID = @cICID    end      if @iStatus <> 0 or @O_iErrorState <> 0   begin      if (@bMessages <> 0x00000000) and (@I_tPosting = @TRUE)   select @O_LineMessages2 = (@bMessages / @MS_Convert)  break  end      fetch next from  Companycursor  into  @cICID,  @cCurrency,   @sCompanyID,  @dExchangeDate,  @mExchangeRate,  @cExchangeTableID,  @dExchangeTime,  @cRateTypeID,  @cDBName,  @sMCTrxState  end   end    deallocate Companycursor  end   if @O_iErrorState <> 0 begin  if @tTransaction = 1  rollback transaction  end else if @tTransaction = 1  commit transaction  return  @iStatus     
GO
GRANT EXECUTE ON  [dbo].[icpVerifyMC] TO [DYNGRP]
GO
