SET QUOTED_IDENTIFIER OFF
GO
SET ANSI_NULLS ON
GO
 create procedure [dbo].[glYearEndCloseMain]  @I_sYear smallint = NULL,  @I_sNext_Year smallint = NULL,  @I_tMCRegistered tinyint  = NULL,  @I_cFunctional_Currency char(15) = NULL,  @I_cEuroCurrency char(15) = NULL,  @I_tEuroEnabled tinyint  = NULL,  @I_cRate_Type_ID char(15) = NULL,  @I_cExchange_Table_ID char(15) = NULL,  @I_iStarting_Journal_Entry int  = NULL,  @I_cNext_Trx_Source char(13) = NULL,  @I_cUser_ID char(15) = NULL,  @I_cYEC_Table char(25) = NULL,  @I_cDiv_Close_Table char(25) = NULL,  @I_cMC_Exception_Table char(25) = NULL,  @I_iRE_Account_Index int  = NULL,  @I_iYearPostingNumber int  = NULL,  @I_iPeriodPostingNumber int  = NULL,  @I_JE_LOCAL int  = NULL,  @I_JE_IFRS int  = NULL,  @I_AllowReportingLedgers tinyint  = NULL,  @I_dYearEndDate datetime = NULL,  @I_dYearStartDate datetime = NULL,  @O_nRetained_Earnings_Total numeric(19,5) = NULL output,  @O_nUserSeqNumber int  = NULL  output,  @O_SQL_Error_State int   = NULL output as  declare   @cBBF varchar(255),  @cBalance_Brought_Forward varchar(255),  @cCLOSE varchar(255),  @cADJ varchar(255),  @cClosing_Entry varchar(255),  @cAccountNumberString char(128),  @cDatabaseName char(15),  @cDBName char(5),  @dYearPeriodZeroDate datetime,  @iStatus int,  @iError int,  @FALSE int,  @TRUE int,  @REGULAR_OFFSET int,  @NORMAL_TRX int,  @FINANCIAL int,  @UNIT_ACCT int,  @BAL_SHEET int,  @MULTIPLY int,  @DIVIDE int,  @POST_ACCT int,  @POST_ALLOC_ACCT int,  @PROFIT_AND_LOSS int,  @iLedgerID int,  @sDivAcctSegment smallint,  @tOpenToHistory   tinyint,  @tHistoryToOpen tinyint,  @tBadTrxDate tinyint,  @tKeepingAccountHistory tinyint,  @tKeepingTRXHistory tinyint,  @tKeepingMCHistory tinyint,  @tTrueREClosing tinyint,  @tBeforeSegmentLength tinyint,  @tDivisionalSegmentLength tinyint,  @tAfterSegmentLength tinyint,  @tUserIsDbo tinyint,  @tLoopControl int,  @MC_NOEURO int,  @MC_NONDENOM_TO_NONDENOM int,  @MC_NONDENOM_TO_EURO int,  @MC_NONDENOM_TO_DENOM int,  @MC_DENOM_TO_NONDENOM int,  @MC_DENOM_TO_DENOM int,  @MC_DENOM_TO_EURO int,  @MC_EURO_TO_DENOM int,  @MC_EURO_TO_NONDENOM int,  @tFunctionalEnabled tinyint,  @JournalEntry int,  @WorkingLedgerID int,  @LedgerCount int,  @nUserSeqNumber int,  @nRetained_Earnings_Total_Temp numeric(19,5)   select @O_nRetained_Earnings_Total = 0.00,  @O_SQL_Error_State  = 0  if  @I_sYear is NULL or  @I_sNext_Year is NULL or  @I_tMCRegistered is NULL or  @I_cFunctional_Currency is NULL or  @I_cEuroCurrency is NULL or  @I_tEuroEnabled is NULL or  @I_cRate_Type_ID is NULL or  @I_cExchange_Table_ID is NULL or  @I_iStarting_Journal_Entry is NULL or  @I_cNext_Trx_Source is NULL or  @I_cUser_ID is NULL or  @I_cYEC_Table is NULL or  @I_cDiv_Close_Table is NULL or  @I_cMC_Exception_Table is NULL or  @I_iRE_Account_Index is NULL or  @I_iYearPostingNumber is NULL or  @I_iPeriodPostingNumber is NULL or  @I_dYearEndDate is NULL or  @I_dYearStartDate is NULL begin  select @O_SQL_Error_State = 20856  return  end   select @cDBName = db_name()  exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'FALSE', @FALSE output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'TRUE',@TRUE output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'REGULAR_OFFSET', @REGULAR_OFFSET output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'NORMAL_TRX', @NORMAL_TRX output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'FINANCIAL', @FINANCIAL output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'UNIT_ACCT', @UNIT_ACCT output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'BAL_SHEET', @BAL_SHEET output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'POST_ACCT', @POST_ACCT output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'POST_ALLOC_ACCT', @POST_ALLOC_ACCT output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'PROFIT_AND_LOSS', @PROFIT_AND_LOSS output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'DIVIDE', @DIVIDE output,  @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'MULTIPLY', @MULTIPLY output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'MC_NOEURO', @MC_NOEURO output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'MC_NONDENOM_TO_NONDENOM', @MC_NONDENOM_TO_NONDENOM output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'MC_NONDENOM_TO_EURO', @MC_NONDENOM_TO_EURO output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'MC_NONDENOM_TO_DENOM', @MC_NONDENOM_TO_DENOM output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'MC_DENOM_TO_NONDENOM', @MC_DENOM_TO_NONDENOM output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'MC_DENOM_TO_DENOM', @MC_DENOM_TO_DENOM output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'MC_DENOM_TO_EURO', @MC_DENOM_TO_EURO output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'MC_EURO_TO_DENOM', @MC_EURO_TO_DENOM output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS.dbo.smGetConstantInt 'MC_EURO_TO_NONDENOM', @MC_EURO_TO_NONDENOM output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec    @iStatus = DYNAMICS.dbo.smGetMsgString 12030, @cDBName, @cBBF output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec    @iStatus = DYNAMICS.dbo.smGetMsgString 10023, @cDBName, @cBalance_Brought_Forward output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec    @iStatus = DYNAMICS.dbo.smGetMsgString 12052, @cDBName, @cCLOSE output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec    @iStatus = DYNAMICS.dbo.smGetMsgString 12018, @cDBName, @cADJ output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec    @iStatus = DYNAMICS.dbo.smGetMsgString 12053, @cDBName, @cClosing_Entry output, @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  create table #Year_End_Close(  ACTINDX int NOT NULL,  TRXAMNT numeric(19,5) NOT NULL,  TRXDATE datetime NOT NULL,  JRNENTRY int NOT NULL,  SOURCDOC char(10) NOT NULL,  TRXSORCE char(13) NOT NULL,  REFRENCE char(30) NOT NULL,  CURNCYID char(15) NOT NULL,  CURRNIDX smallint NOT NULL,  ORIGAMT numeric(19,5) NOT NULL,  Ledger_ID int NOT NULL)  create table #Divisional_Close(  SGMNTID char(67)  NOT NULL,  Ledger_ID int NOT NULL,  CURNCYID char(15)  NOT NULL,   CURRNIDX smallint  NOT NULL,   RTCLCMTD smallint  NOT NULL,   RATETPID char(15)  NOT NULL,   EXGTBLID char(15)  NOT NULL,   REARNAMT numeric(19,5)  NOT NULL,   ORIGAMT numeric(19,5)  NOT NULL,  RERINDX    int   NOT NULL)  create table #MC_YEC_Exception(  RERINDX    int   NOT NULL,   ACTINDX    int   NOT NULL,   CURNCYID    char(15)  NOT NULL,   CURRNIDX    smallint  NOT NULL,   FUNCTAMT    numeric(19,5)  NOT NULL,   ORIGAMT   numeric(19,5)  NOT NULL,  Ledger_ID int NOT NULL)  create table #MC_RTCLCMTD(  ACTINDX int NOT NULL,  Ledger_ID int NOT NULL,  CURNCYID char(15) NOT NULL,  RTCLCMTD smallint NOT NULL)  select @cDatabaseName = db_name()  exec @iStatus = DYNAMICS..smGetDbo  @I_cUser_ID,  @cDatabaseName,  @O_SQL_Error_State output  select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError  if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0 and @O_SQL_Error_State <> 20143) ) begin  return (@iStatus) end else if @O_SQL_Error_State = 0 begin  select @tUserIsDbo = @TRUE end  select @nUserSeqNumber = (select max(ORD) from GL50500 where USERID = @I_cUser_ID)  if (@nUserSeqNumber is NULL)  select @nUserSeqNumber = 0  select @nUserSeqNumber = @nUserSeqNumber + 1  select  @tKeepingAccountHistory = KPGACHST,  @tKeepingTRXHistory  = KPGTRXHS,  @tTrueREClosing   =  TRERCLSG,  @sDivAcctSegment  = DIVACTSG from  GL40000  select  @tKeepingMCHistory  = MNSUMHST from  MC40000  select @dYearPeriodZeroDate = PERIODDT from SY40100 where YEAR1 = @I_sYear and PERIODID = 0 and SERIES = 2  select @WorkingLedgerID = 1  if (@I_AllowReportingLedgers = 1)  select @LedgerCount = 3 else  select @LedgerCount = 1 while @WorkingLedgerID <= @LedgerCount  Begin  if @WorkingLedgerID = 1   select @JournalEntry = @I_iStarting_Journal_Entry  else if @WorkingLedgerID = 2   select @JournalEntry = @I_JE_LOCAL  else  select @JournalEntry = @I_JE_IFRS   insert into  GL20000  (OPENYEAR,  CURNCYID,  CURRNIDX,  RATETPID,  EXGTBLID,  RTCLCMTD,  XCHGRATE,  JRNENTRY,  ACTINDX,  Ledger_ID,  TRXDATE,  DEBITAMT,  CRDTAMNT,  ORDBTAMT,  ORCRDAMT,  TRXSORCE,  ORTRXSRC,  RCTRXSEQ,  SOURCDOC,  REFRENCE,  POLLDTRX,  QKOFSET,  LSTDTEDT,  LASTUSER,  USWHPSTD,  ORGNTSRC,  ORGNATYP,  SERIES,   DENXRATE,  MCTRXSTT,  PSTGNMBR,  PPSGNMBR)  select  @I_sNext_Year,  CURNCYID,   max(CURRNIDX),   '',      '',      0,      0.00,     @JournalEntry,  GL20000.ACTINDX,  GL20000.Ledger_ID,  @I_dYearEndDate,  case        when SUM(DEBITAMT) > SUM(CRDTAMNT) then  SUM(DEBITAMT) - SUM(CRDTAMNT)  else  0.0  end,  case        when SUM(DEBITAMT) <= SUM(CRDTAMNT) then  -1 * (SUM(DEBITAMT) - SUM(CRDTAMNT))  else  0.0  end,  case       when SUM(ORDBTAMT) > SUM(ORCRDAMT) then  SUM(ORDBTAMT) - SUM(ORCRDAMT)  else  0.0  end,  case       when SUM(ORDBTAMT) <= SUM(ORCRDAMT) then  -1 * (SUM(ORDBTAMT) - SUM(ORCRDAMT))  else  0.0  end,  @I_cNext_Trx_Source,  @I_cNext_Trx_Source,  0,      @cBBF,  @cBalance_Brought_Forward,  @FALSE,  @REGULAR_OFFSET,  @I_dYearEndDate,  @I_cUser_ID,  @I_cUser_ID,  @cCLOSE,  @NORMAL_TRX,  @FINANCIAL,  0.0,     0,    @I_iYearPostingNumber,  @I_iPeriodPostingNumber  from  GL20000,  GL00100  where  GL20000.ACTINDX  = GL00100.ACTINDX  and OPENYEAR  = @I_sYear  and @WorkingLedgerID = Ledger_ID  and ((GL00100.ACCTTYPE = @UNIT_ACCT and GL00100.Clear_Balance = @FALSE)  or (GL00100.PSTNGTYP = @BAL_SHEET and not (GL00100.ACCTTYPE = @UNIT_ACCT and GL00100.Clear_Balance = @TRUE)))  group by  GL20000.ACTINDX, GL20000.Ledger_ID, CURNCYID   delete  GL20000  where  OPENYEAR = @I_sNext_Year  and @WorkingLedgerID = Ledger_ID  and SOURCDOC = @cBBF  and ORDBTAMT = 0.00  and ORCRDAMT = 0.00  and DEBITAMT = 0.00  and CRDTAMNT = 0.00   if @I_tMCRegistered = @TRUE  begin  insert into  #MC_RTCLCMTD  select  ACTINDX,  Ledger_ID,  CURNCYID,  MAX(RTCLCMTD)   from  GL20000  where   OPENYEAR = @I_sYear  and @WorkingLedgerID = Ledger_ID  and  CURNCYID <> @I_cFunctional_Currency  group by ACTINDX, Ledger_ID, CURNCYID   update  GL20000  set  RTCLCMTD = tmp.RTCLCMTD  from  #MC_RTCLCMTD tmp  where  GL20000.OPENYEAR = @I_sNext_Year  and GL20000.SOURCDOC = @cBBF  and GL20000.ACTINDX  = tmp.ACTINDX  and  GL20000.Ledger_ID =  tmp.Ledger_ID  and GL20000.CURNCYID = tmp.CURNCYID   select @tFunctionalEnabled = isnull((select ENABLED from MC60400 where DENOMCURR = @I_cFunctional_Currency), @FALSE)   update  GL20000  set  RATETPID = @I_cRate_Type_ID,   EXGTBLID = @I_cExchange_Table_ID,  MCTRXSTT = case  when (@FALSE = @I_tEuroEnabled) then  @MC_NOEURO  when (@FALSE = @tFunctionalEnabled)   and (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cEuroCurrency != CURNCYID)  and (@I_cEuroCurrency != @I_cFunctional_Currency) then  @MC_NONDENOM_TO_NONDENOM  when (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cEuroCurrency = @I_cFunctional_Currency) then  @MC_NONDENOM_TO_EURO  when (@TRUE = @tFunctionalEnabled)   and (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (CURNCYID != @I_cEuroCurrency) then  @MC_NONDENOM_TO_DENOM  when (@FALSE = @tFunctionalEnabled)   and (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cEuroCurrency != @I_cFunctional_Currency) then  @MC_DENOM_TO_NONDENOM  when (@TRUE = @tFunctionalEnabled)   and (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE )) then  @MC_DENOM_TO_DENOM  when (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cFunctional_Currency = @I_cEuroCurrency) then  @MC_DENOM_TO_EURO  when (@TRUE = @tFunctionalEnabled)   and (CURNCYID = @I_cEuroCurrency) then  @MC_EURO_TO_DENOM  when (@FALSE = @tFunctionalEnabled)   and (@I_cFunctional_Currency != @I_cEuroCurrency)  and (CURNCYID = @I_cEuroCurrency) then  @MC_EURO_TO_NONDENOM  else   -1  end,  DENXRATE = case  when (@FALSE = @I_tEuroEnabled) then   0.0  when (@FALSE = @tFunctionalEnabled)   and (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cEuroCurrency != CURNCYID)  and (@I_cEuroCurrency != @I_cFunctional_Currency) then  0.0  when (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cEuroCurrency = @I_cFunctional_Currency) then  0.0  when (@TRUE = @tFunctionalEnabled)   and (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (CURNCYID != @I_cEuroCurrency) then  isnull((select DENXRATE from DYNAMICS..MC40401 where DENOMCURR = @I_cFunctional_Currency), 0.0)  when (@FALSE = @tFunctionalEnabled)   and (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cEuroCurrency != @I_cFunctional_Currency) then  isnull((select DENXRATE from DYNAMICS..MC40401 where DENOMCURR = CURNCYID),0.0)  when (@FALSE = @tFunctionalEnabled)   and (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE )) then  isnull((select DENXRATE from DYNAMICS..MC40401 where DENOMCURR = @I_cFunctional_Currency), 0.0)  when (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cFunctional_Currency = @I_cEuroCurrency) then  0.0  when (@TRUE = @tFunctionalEnabled)   and (CURNCYID = @I_cEuroCurrency) then  0.0  when (@FALSE = @tFunctionalEnabled)   and (@I_cFunctional_Currency != @I_cEuroCurrency)  and (CURNCYID = @I_cEuroCurrency) then  0.0  else   -1  end,  XCHGRATE =  case  when (@FALSE = @I_tEuroEnabled) then   case   when (ORDBTAMT - ORCRDAMT) <> 0.0 then  (DEBITAMT - CRDTAMNT)/(ORDBTAMT - ORCRDAMT)  else   0.0  end  when (@FALSE = @tFunctionalEnabled)   and (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cEuroCurrency != CURNCYID)  and (@I_cEuroCurrency != @I_cFunctional_Currency) then  case   when (ORDBTAMT - ORCRDAMT) <> 0.0 then  (DEBITAMT - CRDTAMNT)/(ORDBTAMT - ORCRDAMT)  else  0.0  end  when (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cEuroCurrency = @I_cFunctional_Currency) then  case   when (ORDBTAMT - ORCRDAMT) <> 0.0 then  (DEBITAMT - CRDTAMNT)/(ORDBTAMT - ORCRDAMT)  else  0.0  end  when (@TRUE = @tFunctionalEnabled)   and (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (CURNCYID != @I_cEuroCurrency) then  case   when (ORDBTAMT - ORCRDAMT) <> 0.0 then  cast((DEBITAMT - CRDTAMNT) as numeric(19,7))/   round ((ORDBTAMT - ORCRDAMT)/ isnull((select DENXRATE from DYNAMICS..MC40401 where DENOMCURR = @I_cFunctional_Currency), 1.0), 5)  else  0.0  end  when (@FALSE = @tFunctionalEnabled)   and (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cEuroCurrency != @I_cFunctional_Currency) then  case   when (ORDBTAMT - ORCRDAMT) <> 0.0 then  cast((DEBITAMT - CRDTAMNT) as numeric(19,7))/   round ((ORDBTAMT - ORCRDAMT)/ isnull((select DENXRATE from DYNAMICS..MC40401 where DENOMCURR = @I_cFunctional_Currency), 1.0), 5)  else  0.0  end  when (@FALSE = @tFunctionalEnabled)   and (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE )) then  isnull((select DENXRATE from DYNAMICS..MC40401 where DENOMCURR = CURNCYID), 0.0)  when (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cFunctional_Currency = @I_cEuroCurrency) then  isnull((select DENXRATE from DYNAMICS..MC40401 where DENOMCURR = CURNCYID), 0.0)  when (@TRUE = @tFunctionalEnabled)   and (CURNCYID = @I_cEuroCurrency) then  isnull((select DENXRATE from DYNAMICS..MC40401 where DENOMCURR = @I_cFunctional_Currency), 0.0)  when (@FALSE = @tFunctionalEnabled)   and (@I_cFunctional_Currency != @I_cEuroCurrency)  and (CURNCYID = @I_cEuroCurrency) then  case   when (ORDBTAMT - ORCRDAMT) <> 0.0 then  (DEBITAMT - CRDTAMNT)/(ORDBTAMT - ORCRDAMT)  else  0.0  end  else   -1  end,  RTCLCMTD =  case  when (@FALSE = @I_tEuroEnabled) then  RTCLCMTD  when (@FALSE = @tFunctionalEnabled)   and (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cEuroCurrency != CURNCYID)  and (@I_cEuroCurrency != @I_cFunctional_Currency) then  RTCLCMTD  when (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cEuroCurrency = @I_cFunctional_Currency) then  RTCLCMTD  when (@TRUE = @tFunctionalEnabled)   and (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (CURNCYID != @I_cEuroCurrency) then  RTCLCMTD  when (@FALSE = @tFunctionalEnabled)   and (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cEuroCurrency != @I_cFunctional_Currency) then  RTCLCMTD  when (@TRUE = @tFunctionalEnabled)   and (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE )) then  @DIVIDE  when (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cFunctional_Currency = @I_cEuroCurrency) then  @DIVIDE  when (@TRUE = @tFunctionalEnabled)   and (CURNCYID = @I_cEuroCurrency) then  @MULTIPLY  when (@FALSE = @tFunctionalEnabled)   and (@I_cFunctional_Currency != @I_cEuroCurrency)  and (CURNCYID = @I_cEuroCurrency) then  RTCLCMTD  else  RTCLCMTD  end  where  RTCLCMTD = @MULTIPLY  and OPENYEAR = @I_sNext_Year  and  @WorkingLedgerID = Ledger_ID  and GL20000.SOURCDOC = @cBBF  and  CURNCYID <> @I_cFunctional_Currency   update   GL20000  set  RATETPID = @I_cRate_Type_ID,   EXGTBLID = @I_cExchange_Table_ID,  MCTRXSTT = case  when (@FALSE = @I_tEuroEnabled) then  @MC_NOEURO  when (@FALSE = @tFunctionalEnabled)   and (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cEuroCurrency != CURNCYID)  and (@I_cEuroCurrency != @I_cFunctional_Currency) then  @MC_NONDENOM_TO_NONDENOM  when (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cEuroCurrency = @I_cFunctional_Currency) then  @MC_NONDENOM_TO_EURO  when (@TRUE = @tFunctionalEnabled)   and (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (CURNCYID != @I_cEuroCurrency) then  @MC_NONDENOM_TO_DENOM  when (@FALSE = @tFunctionalEnabled)   and (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cEuroCurrency != @I_cFunctional_Currency) then  @MC_DENOM_TO_NONDENOM  when (@TRUE = @tFunctionalEnabled)   and (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE )) then  @MC_DENOM_TO_DENOM  when (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cFunctional_Currency = @I_cEuroCurrency) then  @MC_DENOM_TO_EURO  when (@TRUE = @tFunctionalEnabled)   and (CURNCYID = @I_cEuroCurrency) then  @MC_EURO_TO_DENOM  when (@FALSE = @tFunctionalEnabled)   and (@I_cFunctional_Currency != @I_cEuroCurrency)  and (CURNCYID = @I_cEuroCurrency) then  @MC_EURO_TO_NONDENOM  else   -1  end,  DENXRATE = case  when (@FALSE = @I_tEuroEnabled) then   0.0  when (@FALSE = @tFunctionalEnabled)   and (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE )) then  0.0  when (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cEuroCurrency = @I_cFunctional_Currency) then  0.0  when (@TRUE = @tFunctionalEnabled)   and (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (CURNCYID != @I_cEuroCurrency) then  isnull((select DENXRATE from DYNAMICS..MC40401 where DENOMCURR = @I_cFunctional_Currency), 0.0)  when (@FALSE = @tFunctionalEnabled)   and (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cEuroCurrency != @I_cFunctional_Currency) then  isnull((select DENXRATE from DYNAMICS..MC40401 where DENOMCURR = CURNCYID),0.0)  when (@TRUE = @tFunctionalEnabled)   and (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE )) then  isnull((select DENXRATE from DYNAMICS..MC40401 where DENOMCURR = @I_cFunctional_Currency), 0.0)  when (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cFunctional_Currency = @I_cEuroCurrency) then  0.0  when (@TRUE = @tFunctionalEnabled)   and (CURNCYID = @I_cEuroCurrency) then  0.0  when (@FALSE = @tFunctionalEnabled)   and (@I_cFunctional_Currency != @I_cEuroCurrency)  and (CURNCYID = @I_cEuroCurrency) then  0.0  else   -1  end,  XCHGRATE =  case  when (@FALSE = @I_tEuroEnabled) then   case   when (DEBITAMT - CRDTAMNT) <> 0.0 then  (ORDBTAMT - ORCRDAMT)/(DEBITAMT - CRDTAMNT)  else  0.0  end  when (@FALSE = @tFunctionalEnabled)   and (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE )) then  case   when (DEBITAMT - CRDTAMNT) <> 0.0 then  (ORDBTAMT - ORCRDAMT)/(DEBITAMT - CRDTAMNT)  else  0.0  end  when (@I_cFunctional_Currency = @I_cEuroCurrency)   and (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE )) then  case   when (DEBITAMT - CRDTAMNT) <> 0.0 then  (ORDBTAMT - ORCRDAMT)/(DEBITAMT - CRDTAMNT)  else  0.0  end  when (@TRUE = @tFunctionalEnabled)   and (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (CURNCYID != @I_cEuroCurrency) then  case   when (DEBITAMT - CRDTAMNT) <> 0.0 then  round (cast((ORDBTAMT - ORCRDAMT) as numeric (19,7))/ isnull((select DENXRATE from DYNAMICS..MC40401 where DENOMCURR = @I_cFunctional_Currency), 1.0), 5)/  (DEBITAMT - CRDTAMNT)  else  0.0  end  when (@FALSE = @tFunctionalEnabled)   and (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cEuroCurrency != @I_cFunctional_Currency) then  case   when (DEBITAMT - CRDTAMNT) <> 0.0 then  round (cast((ORDBTAMT - ORCRDAMT) as numeric (19,7))/ isnull((select DENXRATE from DYNAMICS..MC40401 where DENOMCURR = @I_cFunctional_Currency), 1.0), 5)/  (DEBITAMT - CRDTAMNT)  else  0.0  end  when (@TRUE = @tFunctionalEnabled)   and (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE )) then  isnull((select DENXRATE from DYNAMICS..MC40401 where DENOMCURR = CURNCYID), 0.0)  when (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cFunctional_Currency = @I_cEuroCurrency) then  isnull((select DENXRATE from DYNAMICS..MC40401 where DENOMCURR = CURNCYID), 0.0)  when (@TRUE = @tFunctionalEnabled)   and (CURNCYID = @I_cEuroCurrency) then  isnull((select DENXRATE from DYNAMICS..MC40401 where DENOMCURR = @I_cFunctional_Currency), 0.0)  when (@FALSE = @tFunctionalEnabled)   and (@I_cFunctional_Currency != @I_cEuroCurrency)  and (CURNCYID = @I_cEuroCurrency) then  case   when (DEBITAMT - CRDTAMNT) <> 0.0 then  (ORDBTAMT - ORCRDAMT)/ (DEBITAMT - CRDTAMNT)  else  0.0  end  else   -1  end,  RTCLCMTD =  case  when (@FALSE = @I_tEuroEnabled) then  RTCLCMTD  when (@FALSE = @tFunctionalEnabled)   and (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cEuroCurrency != CURNCYID)  and (@I_cEuroCurrency != @I_cFunctional_Currency) then  RTCLCMTD  when (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cEuroCurrency = @I_cFunctional_Currency) then  RTCLCMTD  when (@TRUE = @tFunctionalEnabled)   and (@FALSE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (CURNCYID != @I_cEuroCurrency) then  RTCLCMTD  when (@FALSE = @tFunctionalEnabled)   and (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cEuroCurrency != @I_cFunctional_Currency) then  RTCLCMTD  when (@TRUE = @tFunctionalEnabled)   and (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE )) then  @DIVIDE  when (@TRUE = isnull(( select ENABLED from MC60400 where DENOMCURR = CURNCYID), @FALSE ))   and (@I_cFunctional_Currency = @I_cEuroCurrency) then  @DIVIDE  when (@TRUE = @tFunctionalEnabled)   and (CURNCYID = @I_cEuroCurrency) then  @MULTIPLY  when (@FALSE = @tFunctionalEnabled)   and (@I_cFunctional_Currency != @I_cEuroCurrency)  and (CURNCYID = @I_cEuroCurrency) then  RTCLCMTD  else  RTCLCMTD  end   where  RTCLCMTD = @DIVIDE  and OPENYEAR = @I_sNext_Year  and @WorkingLedgerID = Ledger_ID  and GL20000.SOURCDOC = @cBBF  and  CURNCYID <> @I_cFunctional_Currency  end   exec @iStatus = glYECCreateBBFTranslationOpen  @I_sYear,  @I_sNext_Year,  @I_tMCRegistered,  @I_cFunctional_Currency,  @I_cEuroCurrency,  @I_tEuroEnabled,  @tFunctionalEnabled,  @I_cRate_Type_ID,  @I_cExchange_Table_ID,  @JournalEntry,  @WorkingLedgerID,  @I_cNext_Trx_Source,  @cBBF,  @cBalance_Brought_Forward,  @cCLOSE,  @I_dYearEndDate,  @dYearPeriodZeroDate,  @tKeepingTRXHistory,  @UNIT_ACCT,  @BAL_SHEET,  @MC_NOEURO,  @MC_NONDENOM_TO_NONDENOM,  @MC_NONDENOM_TO_EURO,  @MC_NONDENOM_TO_DENOM,  @MC_DENOM_TO_NONDENOM,  @MC_DENOM_TO_DENOM,  @MC_DENOM_TO_EURO,  @MC_EURO_TO_DENOM,  @MC_EURO_TO_NONDENOM,  @MULTIPLY,  @DIVIDE,  @O_SQL_Error_State output   insert into  GL10110  (ACTINDX,  PERDBLNC,  DEBITAMT,  CRDTAMNT,  YEAR1,  PERIODID,  Ledger_ID,  ACCATNUM)  select  GL10110.ACTINDX,  SUM(PERDBLNC),  SUM(DEBITAMT),  SUM(CRDTAMNT),  @I_sNext_Year,  0,       GL10110.Ledger_ID,  GL00100.ACCATNUM  from  GL10110,  GL00100  where  GL10110.ACTINDX  = GL00100.ACTINDX  and GL10110.YEAR1  = @I_sYear  and @WorkingLedgerID = Ledger_ID  and ((GL00100.ACCTTYPE = @UNIT_ACCT and GL00100.Clear_Balance = @FALSE)  or (GL00100.PSTNGTYP = @BAL_SHEET and not (GL00100.ACCTTYPE = @UNIT_ACCT and GL00100.Clear_Balance = @TRUE)))  group by GL10110.ACTINDX, GL00100.ACCTTYPE, GL00100.ACCATNUM, GL10110.Ledger_ID   if @I_tMCRegistered = @TRUE  begin  insert into  MC00201  (ACTINDX,  OPENYEAR,  CURNCYID,   PERIODID,  Ledger_ID,  CURRNIDX,  FUNCTAMT,  ORIGAMT)  select  MC00201.ACTINDX,  @I_sNext_Year,  CURNCYID,  0,      MC00201.Ledger_ID,  max(CURRNIDX),  SUM(FUNCTAMT),  SUM(ORIGAMT)  from  MC00201,  GL00100  where  OPENYEAR   = @I_sYear  and @WorkingLedgerID = Ledger_ID  and MC00201.ACTINDX  = GL00100.ACTINDX  and ((GL00100.ACCTTYPE = @UNIT_ACCT and GL00100.Clear_Balance = @FALSE)  or (GL00100.PSTNGTYP = @BAL_SHEET and not (GL00100.ACCTTYPE = @UNIT_ACCT and GL00100.Clear_Balance = @TRUE)))  group by MC00201.ACTINDX, MC00201.Ledger_ID, CURNCYID   delete  MC00201  where  OPENYEAR = @I_sNext_Year  and @WorkingLedgerID = Ledger_ID  and FUNCTAMT = 0.00  and ORIGAMT  = 0.00  and PERIODID = 0   delete  GL10110  where  YEAR1  = @I_sNext_Year  and @WorkingLedgerID = Ledger_ID  and  PERIODID = 0  and  PERDBLNC = 0.00  and ACTINDX not in (select  distinct ACTINDX  from MC00201  where OPENYEAR = @I_sNext_Year  and PERIODID = 0)  end   else  begin  delete  GL10110  where  YEAR1   = @I_sNext_Year  and @WorkingLedgerID = Ledger_ID  and PERDBLNC  = 0.00  and PERIODID = 0  end   insert into  #Year_End_Close  select  GL20000.ACTINDX,  (sum(DEBITAMT) - sum(CRDTAMNT)) * -1,  @I_dYearEndDate,  @JournalEntry,  @cADJ,  @I_cNext_Trx_Source,  @cClosing_Entry,  CURNCYID,  max(CURRNIDX),  (sum(ORDBTAMT) - sum(ORCRDAMT)) * -1,  Ledger_ID  from  GL20000,  GL00100  where  OPENYEAR  = @I_sYear  and @WorkingLedgerID = Ledger_ID  and GL20000.ACTINDX  = GL00100.ACTINDX  and GL00100.ACCTTYPE <> @UNIT_ACCT  and GL00100.PSTNGTYP <> @BAL_SHEET  group by   GL20000.ACTINDX, Ledger_ID,CURNCYID  order by Ledger_ID, GL20000.CURNCYID    delete  #Year_End_Close  where  TRXAMNT = 0.00  and ORIGAMT = 0.00   exec @iStatus = glCalculateSegment  @sDivAcctSegment,  @tBeforeSegmentLength output,  @tDivisionalSegmentLength output,  @tAfterSegmentLength output,  @O_SQL_Error_State output   select @iError = @@error  if @iStatus = 0 and @iError <> 0  begin  select @iStatus = @iError  return(@iStatus)  end   select @tBeforeSegmentLength = @tBeforeSegmentLength + 1   if @I_tMCRegistered = @TRUE and @tTrueREClosing = @TRUE  begin   insert into  #Divisional_Close  (SGMNTID,   Ledger_ID,  CURNCYID,   CURRNIDX,   RTCLCMTD,   RATETPID,   EXGTBLID,   REARNAMT,   ORIGAMT,  RERINDX)  select  distinct substring(ACTNUMST,@tBeforeSegmentLength,@tDivisionalSegmentLength),  Ledger_ID,  CURNCYID,  max(CURRNIDX),  0,  '',  '',  SUM(DEBITAMT)-SUM(CRDTAMNT),  SUM(ORDBTAMT)-SUM(ORCRDAMT),  0  from  GL00105,  GL20000,  GL00100  where  GL00105.ACTINDX = GL20000.ACTINDX  and GL00100.ACTINDX = GL00105.ACTINDX  and GL00100.ACCTTYPE = @POST_ACCT  and GL00100.PSTNGTYP = @PROFIT_AND_LOSS  and GL20000.OPENYEAR = @I_sYear  and Ledger_ID  = @WorkingLedgerID  group by substring(ACTNUMST,@tBeforeSegmentLength,@tDivisionalSegmentLength), Ledger_ID, CURNCYID  update  #Divisional_Close   set  RTCLCMTD  =  GL20000.RTCLCMTD,  RATETPID = @I_cRate_Type_ID,  EXGTBLID = @I_cExchange_Table_ID  from  GL20000,  GL00105  where  SGMNTID = substring(ACTNUMST,@tBeforeSegmentLength, @tDivisionalSegmentLength)  and GL00105.ACTINDX = GL20000.ACTINDX  and  #Divisional_Close.CURNCYID <> @I_cFunctional_Currency   end  else if @I_tMCRegistered = @TRUE and @tTrueREClosing = @FALSE  begin  insert into  #Divisional_Close  (SGMNTID,  Ledger_ID,  CURNCYID,   CURRNIDX,    RTCLCMTD,   RATETPID,   EXGTBLID,   REARNAMT,   ORIGAMT,  RERINDX)  select  '',  Ledger_ID,  CURNCYID,  max(CURRNIDX),  0,  '',  '',  SUM(DEBITAMT) - SUM(CRDTAMNT),  SUM(ORDBTAMT) - SUM(ORCRDAMT),  0  from  GL20000,  GL00100  where  (GL00100.ACTINDX = GL20000.ACTINDX  and OPENYEAR  = @I_sYear  and Ledger_ID  = @WorkingLedgerID)  and   ((GL00100.ACCTTYPE <> @UNIT_ACCT  and GL00100.PSTNGTYP <> @BAL_SHEET  and  TRXDATE   >= @I_dYearStartDate)  or  (GL00100.PSTNGTYP <> @BAL_SHEET  and  TRXDATE   < @I_dYearStartDate))  group by   Ledger_ID, CURNCYID   update  #Divisional_Close  set  RTCLCMTD  =  GL20000.RTCLCMTD,  RATETPID = @I_cRate_Type_ID,  EXGTBLID = @I_cExchange_Table_ID  from  GL20000  where  @I_iRE_Account_Index = GL20000.ACTINDX  and #Divisional_Close.CURNCYID <> @I_cFunctional_Currency   end  else   begin  insert into  #Divisional_Close  (SGMNTID,   Ledger_ID,  CURNCYID,   CURRNIDX,   RTCLCMTD,   RATETPID,   EXGTBLID,   REARNAMT,   ORIGAMT,  RERINDX)  select  distinct substring(ACTNUMST,@tBeforeSegmentLength,@tDivisionalSegmentLength),  Ledger_ID,  '',  0,  0,  '',  '',  sum(PERDBLNC),  0.00,  0   from  GL00105,  GL10110,  GL00100  where  GL00105.ACTINDX  = GL10110.ACTINDX  and GL00105.ACTINDX  = GL00100.ACTINDX  and GL00100.ACCTTYPE = @POST_ACCT  and GL00100.PSTNGTYP = @PROFIT_AND_LOSS  and GL10110.YEAR1  = @I_sYear  and Ledger_ID  = @WorkingLedgerID  group by substring(ACTNUMST,@tBeforeSegmentLength,@tDivisionalSegmentLength), Ledger_ID   end   exec @iStatus = glYECCreatePLTranslationOpen  @I_sYear,  @WorkingLedgerID,  @I_cUser_ID,  @I_tMCRegistered,  @tBeforeSegmentLength,  @tDivisionalSegmentLength,  @tTrueREClosing,  @I_iRE_Account_Index,  @POST_ACCT,  @PROFIT_AND_LOSS,  @UNIT_ACCT,  @BAL_SHEET,  @I_cFunctional_Currency,  @I_cRate_Type_ID,  @I_cExchange_Table_ID,  @I_dYearStartDate,  @I_dYearEndDate,  @dYearPeriodZeroDate,  @nUserSeqNumber,  @O_SQL_Error_State output   select @iError = @@error  if @iStatus = 0 and @iError <> 0  begin  select @iStatus = @iError  end  if @O_SQL_Error_State <> 0  begin  select @iStatus = @O_SQL_Error_State   select @WorkingLedgerID  end   if @tTrueREClosing = @FALSE  begin     select   @nRetained_Earnings_Total_Temp = ISNULL(SUM(PERDBLNC),0.00)  from  GL10110,  GL00100  where  (GL10110.ACTINDX = GL00100.ACTINDX   and YEAR1   = @I_sYear  and Ledger_ID  = @WorkingLedgerID)  and   ((GL00100.ACCTTYPE <> @UNIT_ACCT  and PSTNGTYP   <> @BAL_SHEET  and PERIODID   >  0)  or  (PSTNGTYP  = @PROFIT_AND_LOSS  and PERIODID   = 0))  end  select @O_nRetained_Earnings_Total = @O_nRetained_Earnings_Total + @nRetained_Earnings_Total_Temp   if (select count(*) from #Divisional_Close) > 0 and @I_tMCRegistered = @TRUE  begin   select  @cAccountNumberString = ACTNUMST  from  GL00105  where  ACTINDX = @I_iRE_Account_Index   update  #Divisional_Close  set   RERINDX =  GL00105.ACTINDX  from  GL00105  where  ACTNUMST = stuff(@cAccountNumberString,@tBeforeSegmentLength,  @tDivisionalSegmentLength,rtrim(SGMNTID))   insert into  #MC_YEC_Exception  (RERINDX,   ACTINDX,   CURNCYID,   CURRNIDX,   FUNCTAMT,   ORIGAMT,  Ledger_ID)  select  distinct 0,  GL00100.ACTINDX,  CURNCYID,  CURRNIDX,  0.00,  0.00,  Ledger_ID  from  MC00201,  GL00100  where  GL00100.ACTINDX  = MC00201.ACTINDX  and GL00100.ACCTTYPE = @POST_ACCT  and GL00100.PSTNGTYP = @PROFIT_AND_LOSS  and  MC00201.OPENYEAR = @I_sYear  and Ledger_ID  = @WorkingLedgerID  and CURNCYID   <> @I_cFunctional_Currency  if @tTrueREClosing = @TRUE  begin    update  #MC_YEC_Exception  set  RERINDX = ( select  #Divisional_Close.RERINDX  from  GL00105,  #Divisional_Close  where  GL00105.ACTINDX    = #MC_YEC_Exception.ACTINDX  and #MC_YEC_Exception.CURNCYID = #Divisional_Close.CURNCYID  and #Divisional_Close.Ledger_ID = @WorkingLedgerID  and substring(ACTNUMST,@tBeforeSegmentLength,@tDivisionalSegmentLength)  = #Divisional_Close.SGMNTID)  end  else  begin  update  #MC_YEC_Exception  set  RERINDX = @I_iRE_Account_Index  end   delete   #MC_YEC_Exception  from  GL00100,  MC00200  where  GL00100.ACTINDX    = #MC_YEC_Exception.RERINDX  and MC00200.ACTINDX    = GL00100.ACTINDX  and GL00100.ACCTTYPE   = @POST_ACCT  and MC00200.CURNCYID   = #MC_YEC_Exception.CURNCYID   delete   #MC_YEC_Exception   from  GL00100  where  GL00100.ACTINDX  = #MC_YEC_Exception.RERINDX  and GL00100.ACCTTYPE = @POST_ALLOC_ACCT  and RERINDX not in (  select  distinct ACTINDX  from  GL00103  where  GL00103.ACTINDX = #MC_YEC_Exception.RERINDX  and GL00103.DSTINDX not in (  select  ACTINDX  from  MC00200  where  MC00200.ACTINDX = GL00103.DSTINDX  and MC00200.CURNCYID = #MC_YEC_Exception.CURNCYID))   if (select count(*) from #MC_YEC_Exception) > 0  begin   update  #MC_YEC_Exception  set  FUNCTAMT = ( select  isnull((SUM(MC00201.FUNCTAMT)*-1),0.00)   from  MC00201  where  #MC_YEC_Exception.ACTINDX = MC00201.ACTINDX  and #MC_YEC_Exception.CURNCYID = MC00201.CURNCYID  and MC00201.OPENYEAR   = @I_sYear),  ORIGAMT  = ( select  isnull((SUM(MC00201.ORIGAMT)*-1),0.00)   from  MC00201  where  #MC_YEC_Exception.ACTINDX = MC00201.ACTINDX  and #MC_YEC_Exception.CURNCYID = MC00201.CURNCYID  and MC00201.OPENYEAR   = @I_sYear)  end  end   if @tKeepingAccountHistory = @TRUE  begin  insert into  GL10111  (ACTINDX,  YEAR1,  PERIODID,  Ledger_ID,  ACCATNUM,  PERDBLNC,  CRDTAMNT,  DEBITAMT)  select   ACTINDX,  YEAR1,  PERIODID,  Ledger_ID,  ACCATNUM,  PERDBLNC,  CRDTAMNT,  DEBITAMT  from  GL10110  where  YEAR1 = @I_sYear  and Ledger_ID = @WorkingLedgerID   if @I_tMCRegistered = @TRUE  and @tKeepingMCHistory = @TRUE  begin  insert into  MC30001  ( CURNCYID,  CURRNIDX,  ACTINDX,  HSTYEAR,   PERIODID,  Ledger_ID,  FUNCTAMT,  ORIGAMT)  select  CURNCYID,   CURRNIDX,  ACTINDX,  OPENYEAR,   PERIODID,   Ledger_ID,  FUNCTAMT,  ORIGAMT  from  MC00201  where  OPENYEAR = @I_sYear  and Ledger_ID = @WorkingLedgerID  end  end   if @tKeepingTRXHistory = @TRUE  begin  if @tUserIsDbo = @TRUE  begin  if exists (select * from dbo.sysobjects t1, dbo.sysindexes t2  where t2.name = 'AK1GL30000'  and t2.id = t1.id   and t1.id = Object_id('GL30000') and t1.type = 'U')  begin   drop index GL30000.AK1GL30000   end   if exists (select * from dbo.sysobjects t1, dbo.sysindexes t2  where t2.name = 'AK2GL30000'  and t2.id = t1.id   and t1.id = Object_id('GL30000') and t1.type = 'U')  begin   drop index GL30000.AK2GL30000   end   if exists (select * from dbo.sysobjects t1, dbo.sysindexes t2  where t2.name = 'AK3GL30000'  and t2.id = t1.id   and t1.id = Object_id('GL30000') and t1.type = 'U')  begin   drop index GL30000.AK3GL30000   end   if exists (select * from dbo.sysobjects t1, dbo.sysindexes t2  where t2.name = 'AK4GL30000'  and t2.id = t1.id   and t1.id = Object_id('GL30000') and t1.type = 'U')  begin   drop index GL30000.AK4GL30000   end   if exists (select * from dbo.sysobjects t1, dbo.sysindexes t2  where t2.name = 'AK5GL30000'  and t2.id = t1.id   and t1.id = Object_id('GL30000') and t1.type = 'U')  begin   drop index GL30000.AK5GL30000   end   if exists (select * from dbo.sysobjects t1, dbo.sysindexes t2  where t2.name = 'AK6GL30000'  and t2.id = t1.id   and t1.id = Object_id('GL30000') and t1.type = 'U')  begin   drop index GL30000.AK6GL30000   end   if exists (select * from dbo.sysobjects t1, dbo.sysindexes t2  where t2.name = 'AK7GL30000'  and t2.id = t1.id   and t1.id = Object_id('GL30000') and t1.type = 'U')  begin   drop index GL30000.AK7GL30000   end  if exists (select * from dbo.sysobjects t1, dbo.sysindexes t2  where t2.name = 'AK8GL30000'  and t2.id = t1.id   and t1.id = Object_id('GL30000') and t1.type = 'U')  begin   drop index GL30000.AK8GL30000   end  if exists (select * from dbo.sysobjects t1, dbo.sysindexes t2  where t2.name = 'AK1GL20000'  and t2.id = t1.id   and t1.id = Object_id('GL20000') and t1.type = 'U')  begin   drop index GL20000.AK1GL20000   end   if exists (select * from dbo.sysobjects t1, dbo.sysindexes t2  where t2.name = 'AK2GL20000'  and t2.id = t1.id   and t1.id = Object_id('GL20000') and t1.type = 'U')  begin   drop index GL20000.AK2GL20000   end   if exists (select * from dbo.sysobjects t1, dbo.sysindexes t2  where t2.name = 'AK3GL20000'  and t2.id = t1.id   and t1.id = Object_id('GL20000') and t1.type = 'U')  begin   drop index GL20000.AK3GL20000   end   if exists (select * from dbo.sysobjects t1, dbo.sysindexes t2  where t2.name = 'AK4GL20000'  and t2.id = t1.id   and t1.id = Object_id('GL20000') and t1.type = 'U')  begin   drop index GL20000.AK4GL20000   end   if exists (select * from dbo.sysobjects t1, dbo.sysindexes t2  where t2.name = 'AK5GL20000'  and t2.id = t1.id   and t1.id = Object_id('GL20000') and t1.type = 'U')  begin   drop index GL20000.AK5GL20000   end   if exists (select * from dbo.sysobjects t1, dbo.sysindexes t2  where t2.name = 'AK7GL20000'  and t2.id = t1.id   and t1.id = Object_id('GL20000') and t1.type = 'U')  begin   drop index GL20000.AK7GL20000   end  if exists (select * from dbo.sysobjects t1, dbo.sysindexes t2  where t2.name = 'AK8GL20000'  and t2.id = t1.id   and t1.id = Object_id('GL20000') and t1.type = 'U')  begin   drop index GL20000.AK8GL20000   end  end    insert into  GL30000  (HSTYEAR,  JRNENTRY,  RCTRXSEQ,  SOURCDOC,  REFRENCE,  DSCRIPTN,  TRXDATE,  ACTINDX,  DEBITAMT,  CRDTAMNT,  TRXSORCE,  POLLDTRX,  LASTUSER,  LSTDTEDT,  USWHPSTD,  ORGNTSRC,  ORGNATYP,  QKOFSET,  SERIES,  ORTRXTYP,  ORCTRNUM,  ORMSTRID,  ORMSTRNM,  ORDOCNUM,  ORPSTDDT,   ORTRXSRC,  OrigDTASeries,  OrigSeqNum,  SEQNUMBR,  DTA_GL_Status,  DTA_Index,  CURNCYID,  CURRNIDX,  RATETPID,  EXGTBLID,  XCHGRATE,  EXCHDATE,  TIME1,  RTCLCMTD,  ORDBTAMT,  ORCRDAMT,  NOTEINDX,  ICTRX,  ORCOMID,  ORIGINJE,  DENXRATE,  MCTRXSTT,  DOCDATE,  PSTGNMBR,  PPSGNMBR,  CorrespondingUnit,  VOIDED,  Back_Out_JE,  Back_Out_JE_Year,  Correcting_JE,  Correcting_JE_Year,  Original_JE,  Original_JE_Seq_Num,  Original_JE_Year,  Ledger_ID,  PERIODID,  Adjustment_Transaction,  APRVLUSERID,  APPRVLDT)  select  @I_sYear,  JRNENTRY,  RCTRXSEQ,  SOURCDOC,  REFRENCE,  DSCRIPTN,  TRXDATE,  GL20000.ACTINDX,  DEBITAMT,  CRDTAMNT,  TRXSORCE,  POLLDTRX,  Case when LASTUSER = '' then @I_cUser_ID else LASTUSER end,  @I_dYearEndDate,  ISNULL(USWHPSTD,@I_cUser_ID),  ORGNTSRC,  ORGNATYP,  QKOFSET,  SERIES,  ORTRXTYP,  ORCTRNUM,  ORMSTRID,  ORMSTRNM,  ORDOCNUM,  ORPSTDDT,   ORTRXSRC,  OrigDTASeries,  OrigSeqNum,  SEQNUMBR,  DTA_GL_Status,  DTA_Index,  CURNCYID,  CURRNIDX,  RATETPID,  EXGTBLID,  XCHGRATE,  EXCHDATE,  TIME1,  RTCLCMTD,  ORDBTAMT,  ORCRDAMT,  GL20000.NOTEINDX,  ICTRX,  ORCOMID,  ORIGINJE,  DENXRATE,  MCTRXSTT,  DOCDATE,  PSTGNMBR,  PPSGNMBR,  CorrespondingUnit,  VOIDED,  Back_Out_JE,  Back_Out_JE_Year,  Correcting_JE,  Correcting_JE_Year,  Original_JE,  Original_JE_Seq_Num,  Original_JE_Year,  Ledger_ID,  PERIODID,  Adjustment_Transaction,  APRVLUSERID,  APPRVLDT  from  GL20000  where  OPENYEAR = @I_sYear  and Ledger_ID = @WorkingLedgerID  end   if @tKeepingTRXHistory = @TRUE  begin  update DTA10100  set PSTGSTUS = 3    where  TRXDATE >= @I_dYearStartDate  and TRXDATE <= @I_dYearEndDate  and PSTGSTUS = 2    end   else   begin  delete  DTA10200  from  DTA10100  where  DTA10200.DTASERIES = DTA10100.DTASERIES  and DTA10200.DTAREF = DTA10100.DTAREF  and DTA10200.ACTINDX = DTA10100.ACTINDX  and DTA10200.SEQNUMBR = DTA10100.SEQNUMBR  and DTA10200.GROUPID = DTA10100.GROUPID  and DTA10100.TRXDATE >= @I_dYearStartDate  and DTA10100.TRXDATE <= @I_dYearEndDate  and PSTGSTUS = 2     delete  DTA10100  where  DTA10100.TRXDATE >= @I_dYearStartDate  and DTA10100.TRXDATE <= @I_dYearEndDate  and PSTGSTUS = 2    end   select  @tLoopControl  = 1   while @tLoopControl  = 1  begin  set rowcount 50000    delete from  GL20000   where  OPENYEAR  = @I_sYear  and Ledger_ID = @WorkingLedgerID   if not exists (  select   1   from   GL20000   where   OPENYEAR = @I_sYear  and Ledger_ID = @WorkingLedgerID)  begin  select  @tLoopControl  = 0  end  end   set rowcount 0   delete from  GL10110  where YEAR1  = @I_sYear  and Ledger_ID = @WorkingLedgerID   select @WorkingLedgerID = @WorkingLedgerID + 1 end   exec ('insert into ' + @I_cYEC_Table + ' select * from #Year_End_Close') drop table #Year_End_Close  exec ('insert into ' + @I_cDiv_Close_Table  + ' select * from #Divisional_Close') drop table #Divisional_Close  exec ('insert into ' + @I_cMC_Exception_Table + ' select * from #MC_YEC_Exception') drop table #MC_YEC_Exception  if @tUserIsDbo = @TRUE begin  CREATE unique  nonclustered  index AK1GL20000  on dbo.GL20000(JRNENTRY, RCTRXSEQ, ACTINDX, TRXDATE, PERIODID, DEX_ROW_ID)  CREATE unique  nonclustered  index AK2GL20000  on dbo.GL20000(ACTINDX, OPENYEAR, SOURCDOC, DEX_ROW_ID)  CREATE unique  nonclustered  index AK3GL20000  on dbo.GL20000(OPENYEAR, TRXDATE, ACTINDX, DEX_ROW_ID)  CREATE unique  nonclustered  index AK4GL20000  on dbo.GL20000(JRNENTRY, QKOFSET, ACTINDX, DEX_ROW_ID)  CREATE unique  nonclustered  index AK5GL20000  on dbo.GL20000(OPENYEAR, ACTINDX, TRXDATE, PERIODID, DEX_ROW_ID)  CREATE unique  nonclustered  index AK7GL20000  on dbo.GL20000(ACTINDX, TRXDATE, OPENYEAR, Ledger_ID, DEBITAMT, CRDTAMNT, DEX_ROW_ID)  CREATE unique  nonclustered  index AK8GL20000  on dbo.GL20000(JRNENTRY, DEX_ROW_ID)    CREATE unique  nonclustered  index AK1GL30000  on dbo.GL30000(HSTYEAR, JRNENTRY, RCTRXSEQ, PERIODID, DEX_ROW_ID)  CREATE unique  nonclustered  index AK2GL30000  on dbo.GL30000(HSTYEAR, TRXDATE, ACTINDX, DEX_ROW_ID)  CREATE unique  nonclustered  index AK3GL30000  on dbo.GL30000(ACTINDX, HSTYEAR, DEX_ROW_ID)  CREATE unique  nonclustered  index AK4GL30000  on dbo.GL30000(JRNENTRY, QKOFSET, ACTINDX, DEX_ROW_ID)  CREATE unique  nonclustered  index AK5GL30000  on dbo.GL30000(HSTYEAR, ACTINDX, TRXDATE, PERIODID, DEX_ROW_ID)  CREATE unique  nonclustered  index AK6GL30000  on dbo.GL30000(HSTYEAR, ACTINDX, CURNCYID, TRXDATE, DEX_ROW_ID)  CREATE unique  nonclustered  index AK7GL30000  on dbo.GL30000(CURNCYID, DEX_ROW_ID)  CREATE unique  nonclustered  index AK8GL30000  on dbo.GL30000(ACTINDX, TRXDATE, HSTYEAR, Ledger_ID, DEBITAMT, CRDTAMNT, DEX_ROW_ID)  end   select @O_nUserSeqNumber = @nUserSeqNumber return(@iStatus)    
GO
GRANT EXECUTE ON  [dbo].[glYearEndCloseMain] TO [DYNGRP]
GO
