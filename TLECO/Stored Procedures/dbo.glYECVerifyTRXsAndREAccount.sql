SET QUOTED_IDENTIFIER OFF
GO
SET ANSI_NULLS ON
GO
 create procedure [dbo].[glYECVerifyTRXsAndREAccount]  @I_sYear smallint = NULL,  @I_iRE_Account_Index int  = NULL,  @O_sError_Flag smallint = NULL output,  @O_SQL_Error_State int   = NULL output as  declare  @tBeforeSegmentLength   tinyint,  @tDivisionalSegmentLength tinyint,  @tAfterSegmentLength tinyint,  @tTrueREClosing tinyint,  @sDivAcctSegment tinyint,  @iStatus int,  @iError int,  @FALSE int,  @TRUE int,  @POST_ACCT int,  @PROFIT_N_LOSS int,  @POST_ALLOC_ACCT int,  @VARIABLE int,  @BAL_SHEET int,  @Row_Count_Temp int,  @cRE_Account_Number_String char(66),  @cAccountSegmentSep   char(1)  select @O_SQL_Error_State = 0,  @O_sError_Flag  = 0  if  @I_sYear   is NULL or  @I_iRE_Account_Index is NULL  begin  select @O_SQL_Error_State = 20855  return  end   exec @iStatus = DYNAMICS..smGetConstantInt  'FALSE',  @FALSE output,  @O_SQL_Error_State output  select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS..smGetConstantInt  'TRUE',  @TRUE output,  @O_SQL_Error_State output  select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS..smGetConstantInt  'POST_ACCT',  @POST_ACCT output,  @O_SQL_Error_State output  select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS..smGetConstantInt  'POST_ALLOC_ACCT',  @POST_ALLOC_ACCT output,  @O_SQL_Error_State output  select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS..smGetConstantInt  'VARIABLE',  @VARIABLE output,  @O_SQL_Error_State output  select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS..smGetConstantInt  'BAL_SHEET',  @BAL_SHEET output,  @O_SQL_Error_State output  select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS..smGetConstantInt  'PROFIT_N_LOSS',  @PROFIT_N_LOSS output,  @O_SQL_Error_State output  select @iError = @@error  if @iStatus = 0 and @iError <> 0  select @iStatus = @iError if ( (@iStatus <> 0) or (@O_SQL_Error_State <> 0) )  return (@iStatus)  if exists(  select  1  from  GL20000  where  OPENYEAR = @I_sYear  and  ((VOIDED = 0) or (VOIDED = 1 and ICTRX = 0))  and ACTINDX not in  ( select   ACTINDX  from  GL00100)  and ACTINDX not in   ( select   ACTINDX  from  GL00105)) begin  select @O_sError_Flag = 1  return(@iStatus) end  create table #Accounts(  ACTINDX int NOT NULL,  ACTNUMST char(128) NOT NULL)  create table #Divisional_Segment(  SGMNTID char(66) NOT NULL,  ACTNUMST char(128) NOT NULL)  select  @tTrueREClosing  =  TRERCLSG,  @sDivAcctSegment = DIVACTSG from  GL40000  select  @cRE_Account_Number_String = ACTNUMST from  GL00105 where  ACTINDX = @I_iRE_Account_Index  if @tTrueREClosing = @TRUE begin   exec @iStatus = glCalculateSegment  @sDivAcctSegment,  @tBeforeSegmentLength output,  @tDivisionalSegmentLength output,  @tAfterSegmentLength output,  @O_SQL_Error_State output   select @iError = @@error  if @iStatus = 0 and @iError <> 0  begin  select @iStatus = @iError  return(@iStatus)  end   select @tBeforeSegmentLength = @tBeforeSegmentLength + 1   if @sDivAcctSegment = (select MAX(SGMTNUMB) from SY00300)  select @cAccountSegmentSep = ' '  else  select @cAccountSegmentSep = ACSEGSEP  from DYNAMICS..SY01500   where INTERID = db_name()   insert into  #Divisional_Segment  select  distinct substring(ACTNUMST,@tBeforeSegmentLength,@tDivisionalSegmentLength) + @cAccountSegmentSep,  ''  from  GL00105,  GL00100,  GL20000  where  GL20000.ACTINDX  =  GL00105.ACTINDX  and GL00105.ACTINDX  =  GL00100.ACTINDX  and GL20000.OPENYEAR =  @I_sYear   update  #Divisional_Segment  set   ACTNUMST = STUFF(@cRE_Account_Number_String,@tBeforeSegmentLength,  @tDivisionalSegmentLength + 1,RTRIM(SGMNTID))   select @Row_Count_Temp = @@rowcount   insert into  #Accounts  select  ACTINDX,  GL00105.ACTNUMST  from  GL00105,  #Divisional_Segment  where  GL00105.ACTNUMST = #Divisional_Segment.ACTNUMST  end else begin   select @Row_Count_Temp = 1   insert into  #Accounts  select  ACTINDX,  ACTNUMST  from  GL00105  where  ACTINDX = @I_iRE_Account_Index  end  if @@rowcount <> @Row_Count_Temp begin  select @O_sError_Flag = 21  return(@iStatus) end   if exists (  select  1  from  #Accounts,  GL00103  where  #Accounts.ACTINDX = GL00103.ACTINDX  and GL00103.DSTINDX not in (  select  ACTINDX  from  GL00100)) begin  select @O_sError_Flag = 24  return(@iStatus) end   if exists (  select  1  from  #Accounts,  GL00100  where  #Accounts.ACTINDX  = GL00100.ACTINDX  and GL00100.ACTIVE  = @FALSE  and GL00100.ACCTTYPE = @POST_ACCT) begin  select @O_sError_Flag = 6  return(@iStatus) end  if exists (  select  1  from  #Accounts,  GL00100  where  #Accounts.ACTINDX  = GL00100.ACTINDX  and GL00100.ACTIVE  = @FALSE  and GL00100.ACCTTYPE = @POST_ALLOC_ACCT) begin  select @O_sError_Flag = 6  return(@iStatus) end  if exists (  select  1  from  #Accounts,  GL00103,  GL00100  where  #Accounts.ACTINDX  = GL00103.ACTINDX  and GL00103.DSTINDX  = GL00100.ACTINDX  and GL00100.ACTIVE  = @FALSE) begin  select @O_sError_Flag = 27  return(@iStatus) end  if exists (  select  1  from  #Accounts,  GL00100  where  #Accounts.ACTINDX = GL00100.ACTINDX  and GL00100.ACCTTYPE <> @POST_ACCT  and GL00100.ACCTTYPE <> @POST_ALLOC_ACCT) begin  select @O_sError_Flag = 22  return(@iStatus) end  if exists (  select  1  from  #Accounts,  GL00100  where  #Accounts.ACTINDX = GL00100.ACTINDX  and GL00100.FXDORVAR = @VARIABLE) begin  select @O_sError_Flag = 23  return(@iStatus) end  if exists (  select  1  from  #Accounts,  GL00100  where  #Accounts.ACTINDX = GL00100.ACTINDX  and GL00100.PSTNGTYP <> @BAL_SHEET) begin  select @O_sError_Flag = 32  return(@iStatus) end  if exists (  select  1  from  #Accounts,  GL00103,  GL00100  where  #Accounts.ACTINDX  = GL00103.ACTINDX  and GL00103.DSTINDX  = GL00100.ACTINDX  and GL00100.ACCTTYPE <> @POST_ACCT) begin  select @O_sError_Flag = 25  return(@iStatus) end  if exists(  select  1  from  #Accounts  where  100 <> (select  sum(PRCNTAGE)  from  GL00103  where  #Accounts.ACTINDX  = GL00103.ACTINDX  group by GL00103.ACTINDX)) begin  select @O_sError_Flag = 28  return(@iStatus) end    
GO
GRANT EXECUTE ON  [dbo].[glYECVerifyTRXsAndREAccount] TO [DYNGRP]
GO
