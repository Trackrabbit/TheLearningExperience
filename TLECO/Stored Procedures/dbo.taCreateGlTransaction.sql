SET QUOTED_IDENTIFIER OFF
GO
SET ANSI_NULLS ON
GO
 create procedure [dbo].[taCreateGlTransaction]  @I_vINTERID char(5), @I_vDTAControlNum char(20), @I_vORMSTRID char(30), @I_vCUSTNAME char(64), @I_vCURNCYID char(15), @I_vCURRNIDX int,  @I_vDECPLCUR int, @I_vTRXDATE datetime, @I_vDEBITAMT numeric(19,5), @I_vJRNENTRY int, @I_vCASHINDEX int,  @I_vDEPINDEX int, @I_vTRXSORCE char(13), @I_vDENXRATE numeric(19,5) = 0, @I_vMCTRXSTT smallint = 0, @I_vDOCDATE datetime = '', @I_vORTRXDESC char(31) = '', @I_vORTRXTYP smallint, @O_iErrorState int = NULL output, @oErrString varchar(255) = '' output  with encryption as  set transaction isolation level read uncommitted set nocount on  declare   @iStatement int,  @incmnt int,  @secondsdgstr varchar(50),  @datedgstr varchar(50),  @DTA_Index numeric (19,5),  @date datetime,  @day int,  @month int,  @hours int,  @year int,  @seconds int,  @secondsdg int,  @datedg int,  @iStatus int,  @iError int,  @O_iBtchHdrErrState int,  @O_oErrorState int,  @iCreateBatchErrString varchar(255),  @FUNCRIDX smallint,  @CurrDate char(12),  @XCHGRATE numeric(19,7),  @RTCLCMTD smallint,  @CURNCYID char(15),  @FUNLCURR char(15),  @ISMCTRX tinyint,  @DECPLCUR int,  @sCompanyID smallint,  @aaSubLedgerHdrID int,  @PERIODID smallint,  @OPENYEAR smallint  select   @sCompanyID = '',  @iStatement = 0,  @O_iErrorState = 0,  @oErrString = '',  @iStatus = 0,  @date = getdate(),  @day = DATEPART(dd, @date),  @month = DATEPART(mm, @date),  @hours = DATEPART(hh, @date),  @year = DATEPART(yy, @date),  @seconds = DATEPART(ss, @date),  @secondsdg = @hours*3600,  @secondsdgstr = str(@secondsdg + @seconds + @month),  @incmnt = 5 - len(@secondsdgstr),  @secondsdgstr = ltrim(@secondsdgstr),  @O_iBtchHdrErrState = 0,  @FUNCRIDX = 0,  @CurrDate = convert(varchar(12),getdate()),  @XCHGRATE = 0,  @RTCLCMTD = 0,  @CURNCYID = '',  @FUNLCURR = '',  @ISMCTRX = 0,  @DECPLCUR = 0,  @aaSubLedgerHdrID = 0,  @PERIODID = 0,  @OPENYEAR = 0   while @incmnt > 0  begin  select @secondsdgstr = '0'+ ltrim(@secondsdgstr)   select @incmnt = @incmnt - 1 end  select @datedg = @day + @month * 31,  @datedgstr = substring(ltrim(str(@datedg)),1,3),  @incmnt = 3 - len(@datedgstr) while @incmnt > 0  begin  select @datedgstr = '0' + ltrim(@datedgstr)  select @incmnt = @incmnt - 1 end  select @datedgstr  = @datedgstr + substring(str(@year),3,2)   select @DTA_Index =   convert(numeric(19,5),ltrim(str(@I_vJRNENTRY))  +  rtrim(ltrim(@secondsdgstr))  +  '.'     +  rtrim(ltrim(@datedgstr)))  select @sCompanyID = CMPANYID from DYNAMICS..SY01500 c (nolock) where c.INTERID = db_name()  if exists (select top 1 1 from SOP10100 (nolock) where SOPTYPE = @I_vORTRXTYP and SOPNUMBE = @I_vDTAControlNum) begin   select @XCHGRATE = XCHGRATE,  @RTCLCMTD = RTCLCMTD,  @CURNCYID = CURNCYID  from SOP10100 (nolock) where SOPTYPE = @I_vORTRXTYP and SOPNUMBE = @I_vDTAControlNum end   else begin  select @CURNCYID = @I_vCURNCYID end  select @FUNLCURR = FUNLCURR,  @FUNCRIDX = FUNCRIDX  from MC40000 (nolock)  select @DECPLCUR = DECPLCUR - 1 from DYNAMICS..MC40200 (nolock) where CURNCYID = @FUNLCURR  if (@FUNLCURR <> @CURNCYID) begin  select @ISMCTRX = 1 end  select @OPENYEAR = YEAR1 from SY40101 a (nolock) where @I_vTRXDATE BETWEEN a.FSTFSCDY and a.LSTFSCDY select TOP(1)@PERIODID = PERIODID from SY40100 a (nolock) where a.YEAR1 = @OPENYEAR and   @I_vTRXDATE between a.PERIODDT and a.PERDENDT and a.SERIES = 2 and a.ODESCTN = 'General Entry' and CLOSED = 0 Order By PERIODID   insert into GL10000 ( BACHNUMB,  BCHSOURC,  JRNENTRY,  SOURCDOC,  REFRENCE,  TRXDATE,  PSTGSTUS,  USWHPSTD,  SQNCLINE,  SERIES,  ORPSTDDT,  ORTRXSRC,  DTAControlNum,  DTATRXType,  DTA_Index,  CURNCYID,  CURRNIDX,  PRNTSTUS,  DENXRATE,  MCTRXSTT,  DOCDATE,  Tax_Date,  VOIDED,      Original_JE,     Original_JE_Year,    Original_JE_Seq_Num,    Correcting_Trx_Type,    PERIODID,  Ledger_ID  ) select  @I_vTRXSORCE,  'GL_Normal',  @I_vJRNENTRY,  'CRJ',  'Sales Deposits',    @I_vTRXDATE,  1,      'sa',      16384,      3,      @CurrDate,     @I_vTRXSORCE,  @I_vDTAControlNum,  @I_vORTRXTYP,  convert(numeric (19,5), @DTA_Index),  @I_vCURNCYID,  @I_vCURRNIDX,  1,      @I_vDENXRATE,  @I_vMCTRXSTT,  @I_vDOCDATE,  '',      0,      0,      0,      0,      0,       @PERIODID,  1 if @@error <> 0 begin  select @O_iErrorState = 27    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  insert into GL10001 (  BACHNUMB,  JRNENTRY,  SQNCLINE,  ACTINDX,  DSCRIPTN,  CURRNIDX,  ACCTTYPE,  DECPLACS,  ORCTRNUM,  ORDOCNUM,  ORMSTRID,  ORMSTRNM,  ORTRXDESC,  DTA_GL_Status,  INTERID,  DEBITAMT,  ORDBTAMT,  DENXRATE,  MCTRXSTT,  LNESTAT,  ORTRXTYP  ) select    @I_vTRXSORCE,  @I_vJRNENTRY,  16384,  @I_vCASHINDEX,  'CASH',  @FUNCRIDX,   1,  @I_vDECPLCUR,  @I_vDTAControlNum,  @I_vDTAControlNum,  @I_vORMSTRID,  @I_vCUSTNAME,  @I_vORTRXDESC,  40,  @I_vINTERID,  @I_vDEBITAMT,  @I_vDEBITAMT,  @I_vDENXRATE,  @I_vMCTRXSTT,  5,  @I_vORTRXTYP if @@error <> 0 begin  select @O_iErrorState = 578    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  insert into GL10001 ( BACHNUMB,  JRNENTRY,  SQNCLINE,  ACTINDX,  DSCRIPTN,  CURRNIDX,  ACCTTYPE,  DECPLACS,  ORCTRNUM,  ORDOCNUM,  ORMSTRID,  ORMSTRNM,  ORTRXDESC,  DTA_GL_Status,  INTERID,  CRDTAMNT,  ORCRDAMT,  DENXRATE,  MCTRXSTT,  LNESTAT,  ORTRXTYP  ) select    @I_vTRXSORCE,  @I_vJRNENTRY,  32768,  @I_vDEPINDEX,  'DEPOSITS',  @FUNCRIDX,   1,  @I_vDECPLCUR,  @I_vDTAControlNum,  @I_vDTAControlNum,  @I_vORMSTRID,  @I_vCUSTNAME,  @I_vORTRXDESC,  40,  @I_vINTERID,  @I_vDEBITAMT,  @I_vDEBITAMT,  @I_vDENXRATE,  @I_vMCTRXSTT,  5,  @I_vORTRXTYP if @@error <> 0 begin  select @O_iErrorState = 577    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  if (@ISMCTRX = 1) begin  if (@RTCLCMTD = 0)  begin  select @I_vDEBITAMT = round(@I_vDEBITAMT * @XCHGRATE, @DECPLCUR)  end  else  begin  select @I_vDEBITAMT = round(@I_vDEBITAMT / @XCHGRATE, @DECPLCUR)  end end  select @I_vDEBITAMT = (@I_vDEBITAMT*2)  exec @iStatus = taCreateUpdateBatchHeaderRcd  @I_vBACHNUMB = @I_vTRXSORCE,  @I_vSERIES = 2,  @I_vGLPOSTDT = @I_vTRXDATE,  @I_vBCHSOURC = 'GL_Normal',  @I_vDOCAMT = @I_vDEBITAMT,  @I_vORIGIN = 1,  @I_vNUMOFTRX = 1,  @I_vBRKDNALL = 1,  @O_iErrorState = @O_iBtchHdrErrState output,  @oErrString = @iCreateBatchErrString output select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError if (@iStatus <> 0) or (@O_iBtchHdrErrState <> 0) begin  select @oErrString = rtrim(isnull(@oErrString, '')) + ' ' + @iCreateBatchErrString  select @O_iErrorState = 579       exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState) end  if exists(select 1 from DYNAMICS..sysobjects (nolock) where name  = 'AAG00102') begin  if exists(select 1 from DYNAMICS..AAG00102 (nolock) where CMPANYID = @sCompanyID)  begin   select @aaSubLedgerHdrID = isnull(aaSubLedgerHdrID,0) from AAG20000 (nolock)  where DOCTYPE = case  when @I_vORTRXTYP = 9  then 9  when @I_vORTRXTYP = 8  then 8  when @I_vORTRXTYP = 7  then 7  else  2  end   and DOCNUMBR = @I_vDTAControlNum   if @aaSubLedgerHdrID <> 0  begin  exec @iStatus = aagCreateVoideRecordInGLForBR  @aaSubLedgerHdrID = @aaSubLedgerHdrID,   @JRNENTRY = @I_vJRNENTRY,   @lastDist = 0,   @GLPOSTDT = @I_vTRXDATE,   @CompanyID = @sCompanyID,  @MCRegistered = @ISMCTRX    if (@@error <> 0)   begin  select @O_iErrorState = 8199    exec @iStatus = taUpdateString  @O_iErrorState,  @oErrString,  @oErrString output,  @O_oErrorState output  return (@O_iErrorState)  end  end  end end  return (@O_iErrorState)   
GO
GRANT EXECUTE ON  [dbo].[taCreateGlTransaction] TO [DYNGRP]
GO
