SET QUOTED_IDENTIFIER OFF
GO
SET ANSI_NULLS ON
GO
 create procedure [dbo].[smRuleCreateTask]   @BARULEID int,  @cDBName  char(6) as  declare @TaskMsg  varchar(255),   @TaskMsgPost varchar(255),   @ruledesc  varchar(30),    @ruledescPost  varchar(30),  @compname  varchar(64),    @subjectln varchar(255),   @busalert  varchar(15),    @userid   varchar(101),    @histid  varchar(255),   @cStatement varchar(255),  @cStatement2 varchar(255),  @cStatement3 varchar(255),  @cStatement4 varchar(255),  @tablename varchar(30),    @RecNum    numeric(19, 5),  @incres    int,     @keephist  int,     @iError    int,      @iStatus    int,  @CH_SPACE char(1),   @CH_DASH char(1),   @NOTIFTYPE varchar(15),  @SAUSER char(2),  @NoUserMsg varchar(255),  @vAlert varchar(20),  @iErrorState integer,  @iStringPos integer,  @stringlength int,  @OutStringLength int,  @iCount int,  @cStringCharacter char(1)  exec    @iStatus = DYNAMICS.dbo.smGetMsgString 2838, @cDBName, @vAlert output, @iErrorState output select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError if ( (@iStatus <> 0) or (@iErrorState <> 0) )  return (@iStatus)  exec    @iStatus = DYNAMICS.dbo.smGetMsgString 7697, @cDBName, @NoUserMsg output, @iErrorState output select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError if ( (@iStatus <> 0) or (@iErrorState <> 0) )  return (@iStatus)  exec    @iStatus = DYNAMICS.dbo.smGetMsgString 3158, @cDBName, @compname output, @iErrorState output select @iError = @@error if @iStatus = 0 and @iError <> 0  select @iStatus = @iError if ( (@iStatus <> 0) or (@iErrorState <> 0) )  return (@iStatus)  exec @iStatus = DYNAMICS..smGetConstantString  'CH_DASH',   @CH_DASH output,  @iErrorState output  select @iError = @@error if @iStatus <> 0 or @iError <> 0 or @iErrorState <> 0  return (@iStatus)  exec @iStatus = DYNAMICS..smGetConstantString  'CH_SPACE',   @CH_SPACE output,  @iErrorState output  exec @iStatus = DYNAMICS..smGetConstantString  'ST_TASK',   @NOTIFTYPE output,  @iErrorState output  select @iError = @@error if @iStatus <> 0 or @iError <> 0 or @iErrorState <> 0  return (@iStatus)  exec @iStatus = DYNAMICS..smGetConstantString  'ST_SA',   @SAUSER output,  @iErrorState output  select @iError = @@error if @iStatus <> 0 or @iError <> 0 or @iErrorState <> 0  return (@iStatus)  select  @busalert = BUSALRTID, @ruledesc = DSCRIPTN, @TaskMsg = EMAILMSG,  @incres = INCLDRSLTS,@keephist = KEEPHIST from  SY40500 where  BARULEID = @BARULEID  select  @iCount = 1,  @OutStringLength = 1,  @TaskMsgPost = ' ',  @stringlength = len(@TaskMsg)   while @iCount <= @stringlength  begin  select @cStringCharacter = substring(@TaskMsg,@iCount,1)   if @cStringCharacter = ''''  begin  select @TaskMsgPost = substring(@TaskMsgPost,1,@OutStringLength) + REPLICATE('''',2)  select @OutStringLength = @OutStringLength + 2  end  else  begin  select @TaskMsgPost = substring(@TaskMsgPost,1,@OutStringLength) + REPLICATE(@cStringCharacter,1)  select @OutStringLength = @OutStringLength + 1  end   select @iCount = @iCount + 1  end  select @TaskMsg = rtrim(@TaskMsgPost)  select @TaskMsg = ltrim(@TaskMsg)  select  @iCount = 1,  @ruledescPost = ' ',  @OutStringLength = 1,  @stringlength = len(@ruledesc)   while @iCount <= @stringlength  begin  select @cStringCharacter = substring(@ruledesc,@iCount,1)   if @cStringCharacter = ''''  begin  select @ruledescPost = substring(@ruledescPost,1,@OutStringLength) + REPLICATE('''',2)  select @OutStringLength = @OutStringLength + 2  end  else  begin  select @ruledescPost = substring(@ruledescPost,1,@OutStringLength) + REPLICATE(@cStringCharacter,1)  select @OutStringLength = @OutStringLength + 1  end   select @iCount = @iCount + 1  end  select @ruledesc = rtrim(@ruledescPost)  select @ruledesc = ltrim(@ruledesc)  select @RecNum = max(CMRECNUM) from SY01403 select @RecNum = ISNULL(@RecNum, 0) select @histid = ''   declare Task_cursor CURSOR for select NOTFCTNID   from SY40505  where BARULEID = @BARULEID  and NOTIFTYPE = @NOTIFTYPE set nocount on OPEN Task_cursor FETCH NEXT FROM Task_cursor INTO @userid  while (@@FETCH_STATUS <> -1) begin  if NOT EXISTS(select USERID from SY01400 where USERID = @userid)  BEGIN  select @cStatement2 = ''''+ rtrim(REPLACE(@NoUserMsg, '%1', rtrim(@userid)))  select @cStatement2 = REPLACE(@cStatement2, '%2', rtrim(@ruledesc))  select @cStatement3 = ''''  select @userid = @SAUSER  END  ELSE  BEGIN  if @ruledesc = ''  BEGIN  select @cStatement2 = ''''  select @cStatement3 = rtrim(@compname)  END  else  BEGIN   select @cStatement2 = '''' + SUBSTRING ( rtrim(@ruledesc), 1, 254)  select @cStatement3 = ' - ' + rtrim(@compname)  END  if @TaskMsg = ''  select @cStatement4 = ''''  else  select @cStatement4 = + ' - ' + SUBSTRING ( rtrim(@TaskMsg),1 ,250 ) + ''''  END  select @histid = ltrim(@histid) + @CH_SPACE + rtrim(@userid)  select @RecNum = @RecNum + 1  select @cStatement = 'insert into SY01403 (USERID, CMPANYID, CMRECNUM, Status, DUEDATE, LinkTo, TXTFIELD)'  select @cStatement = @cStatement + ' select ' + '''' + rtrim(@userid) + '''' + ',0,' + str(@RecNum) + ',1,' + '''' + rtrim(convert(char(12), GETDATE(),112)) + '''' + ',1,'  exec (@cStatement + @cStatement2 + @cStatement3 + @cStatement4)   FETCH NEXT FROM Task_cursor INTO @userid end   if @iError <> 0   BEGIN  DEALLOCATE Task_cursor   select @tablename ='##smRuleID' + ltrim(str(@BARULEID))  exec ('drop table ' + @tablename)  RETURN  END  if @keephist = 1   BEGIN  insert into SY40506   values(@BARULEID,CONVERT(char(12), GETDATE(), 102),CONVERT(char(12), GETDATE(), 108),@histid)   END  update SY40500  set NMBRTIME = NMBRTIME + 1  where BARULEID = @BARULEID  DEALLOCATE Task_cursor  select @tablename ='##smRuleID' + ltrim(str(@BARULEID)) exec ('drop table ' + @tablename)    
GO
GRANT EXECUTE ON  [dbo].[smRuleCreateTask] TO [DYNGRP]
GO
